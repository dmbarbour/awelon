std

@doc.aoi
"aoi is a simplistic imperative REPL for AO, implemented in Haskell. This tool will default to loading the 'aoi' dictionary (i.e. seaching for 'aoi.ao' on AO_PATH). The aoi REPL is NOT intended for long-term use, and it should eventually be replaced by a spreadsheet metaphor with better effects models and proper compilation.
 
 The aoi application model is very trivial. A single, linear powerblock is provided to the program, of type roughly µP.[a→(P*b)], then the word 'prelude.aoi' is invoked if it exists. Effects are achieved by passing messages to the powerblock, which is supported implicitly by `iomsg.aoi`, `readFile`, etc. assuming the powerblock is in its standard location:
 
     (stack * (hand * (powerblock * ...)))
 
 The aoi effects model is inadequate for safety, efficiency, scalability, and open system security. It is not recommended. I would not use it even in aoi, if it were not for how trivially it is to implement.
 
 AOI does have a little extra support to help bootstrap a proper REPL/interpreter. See @doc.switchAOI for more information!
~
 
@doc.wrapE.aoi "wrap initial powerblock in standard environment"
@wrapE.aoi %v "" %vrrvrwvrrwr
@prelude.aoi wrapE.aoi

@doc.iomsg.aoi "invoke linear powerblock with message from stack"
@iomsg.aoi %zwl .apply xf %rwz

@doc.switchAOI 
"An interpreter function has roughly type:
 
     type iFn = [e0 t -- e0' t']  (iFn must be copyable, too)
 
 Here, `e0` is the value presented to the user, `t` is the text interpreted, and `t'` is the leftover text that should be reprocessed. In each interpreter step, the previous text is appended with any new input and reprocessed. The interpreter has its own environment, `eI`, in which the above `iFn` is processed. A full interpreter consists of a pair: the function and the initial environment (minus text and world).
 
     type interpreter = ([iFn] * eI)
 
 The `switchAOI` word will swap out the current interpreter with a new one.
 
     switchAOI :: interpreter -- interpreter'
 
 Note that the prior interpreter is returned as a value, so that developers can model stacks of interpreters, temporary interpreters, and similar. The real motivation for switchAOI is to help bootstrap new interpreter/REPL models.
~ 
@switchAOI "switchAOI" pf iomsg.aoi

@doc.loadWord "text -- (1 + [x→y]); load word (if it exists) from AOI dictionary"
@loadWord  "loadWord" pf iomsg.aoi

@doc.frame.aoi 
"The Haskell AO compiler adds annotations to help track call stack 
 locations for debugging purposes. AOI provides 'pushFrame' and 'popFrame'
 for similar reasons. The input to pushFrame must be simple text.
 
 Be sure to keep popFrame balanced with pushFrame! 
~
@doc.pushFrame "frameText --; see @doc.frame.aoi"
@doc.popFrame "--; see @doc.frame.aoi"
@doc.getFrameStack "-- list of texts"
@pushFrame "pushFrameText" pf iomsg.aoi
@popFrame intro1 "popFrameText" pf iomsg.aoi
@getFrameStack intro1 "getFrameStack" pf iomsg.aoi

@doc.readFile "filename -- (1(err) + text)"
@doc.writeFile "text filename -- (1(err) + 1(ok))"
@readFile "readFile" pf iomsg.aoi
@writeFile pf "writeFile" pf iomsg.aoi

@doc.getEnv.iomsg "varname -- text; traditional environment variables!"
@getEnv "getOSEnv" pf iomsg.aoi

