std

@doc.aoi
"aoi is an imperative REPL for AO, implemented in Haskell. This tool will default to loading the 'aoi' dictionary (i.e. seaching for 'aoi.ao' on AO_PATH). The aoi REPL is NOT intended for long-term use, and it should eventually be replaced by a spreadsheet metaphor with better effects models and proper compilation.
 
 The aoi application model is simplistic. The application starts in a standard environment that is empty except for a linear powerblock. The powerblock has type roughly `µP.[msg→(P*ans)]` where 'msg' is a (label * contents) pair. Use of `iomsg.aoi` will send an ad-hoc message to the powerblock and leave the answer on the stack. All implemented operations also have dedicated words like `readFile`.
 
 The aoi effects model is inadequate for safety, efficiency, scalability, and open system security. Because it is not safe, it also isn't compatible with ambiguity. It is not recommended in general. I would not use it even in aoi, if it were not for how trivial it is to implement as a bootstrap model.
 
 AOI does have a little extra support to help bootstrap a proper REPL/interpreter. See @doc.switchAOI for more information!
~

@doc.iomsg.aoi "invoke linear powerblock with message from stack"
@iomsg.aoi %zwl .apply xf %rwz

@doc.switchAOI 
"An interpreter function has roughly type:
 
     type iFn = [e0 t -- e0' t']  (iFn must be copyable, too)
 
 Here, `e0` is the value presented to the user, `t` is the text interpreted, and `t'` is the leftover text that should be reprocessed. In each interpreter step, the previous text is appended with any new input and reprocessed. The interpreter has its own environment, `eI`, in which the above `iFn` is processed. A full interpreter consists of a pair: the function and the initial environment (minus text and world).
 
     type interpreter = ([iFn] * eI)
 
 The `switchAOI` word will swap out the current interpreter with a new one.
 
     switchAOI :: interpreter -- interpreter'
 
 Note that the prior interpreter is returned as a value, so that developers can model stacks of interpreters, temporary interpreters, and similar. The real motivation for switchAOI is to help bootstrap new interpreter/REPL models.
~ 
@switchAOI "switchAOI" pf iomsg.aoi

@doc.loadWord "text -- (1 + [x→y]); load word (if it exists) from AOI dictionary"
@loadWord  "loadWord" pf iomsg.aoi

@doc.frame.aoi 
"The Haskell AO compiler adds annotations to help track call stack 
 locations for debugging purposes. AOI provides 'pushFrame' and 'popFrame'
 for similar reasons. The input to pushFrame must be simple text.
 
 Be sure to keep popFrame balanced with pushFrame! 
~
@doc.pushFrame "frameText --; see @doc.frame.aoi"
@doc.popFrame "--; see @doc.frame.aoi"
@pushFrame "pushFrame" pf iomsg.aoi
@popFrame intro1 "popFrame" pf iomsg.aoi elim1

@doc.getEnv.iomsg "varname -- text; traditional environment variables!"
@getEnv "getOSEnv" pf iomsg.aoi

@doc.randomBytes "count -- (list of octets); secure random source"
@randomBytes "randomBytes" pf iomsg.aoi

@doc.reload "reload dictionary from filesystem (i.e. to see updates)"
@reload intro1 "reloadDictionary" pf iomsg.aoi elim1

@doc.readFile "filename -- (1(err) + text)"
@doc.writeFile "text filename -- (1(err) + 1(ok))"
@readFile "readFile" pf iomsg.aoi
@writeFile pf "writeFile" pf iomsg.aoi

@doc.destroy "destroy will drop any input, including relevant blocks; useful to clean the environment, but not very safe"
@destroy "destroy" pf iomsg.aoi elim1

@doc.clear "clear the current environment (except hand and powerblock)"
@reset introE swapE destroy

@doc.exit "gracefully halt the program"
@exit intro1 "exit" pf iomsg.aoi elim1

