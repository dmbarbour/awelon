
@doc.import.std "one big starting point for AO systems"

@doc.NamingConventions
"The naming convention for AO places context to the right and type to the left. Example types include 'doc', 'test', and 'ioapp'. Type, in this sense, determines how the word is processed by the larger programming environment - e.g. 'test' results in automatic testing. Context provides extra information about where the word is needed or used. It may identify a project, user, DSL, framework, and so on. 
 
 A good programming environment should replace structured suffixes or popular prefixes with style and color upon rendering. This feature improves parsimony and readability. It may also improve ability to recognize usage patterns in a zoomable view of a word's expansion. This replaces syntax highlighting, which isn't very relevant in AO.
 
 There is a distinct naming convention for spreadsheet elements, of form `b3$foo` to indicate cell b3 in a spreadsheet called foo. The names for cells imply location in a spreadsheet.
~

@doc.StandardEnvironment
"The required environment for AO is a pair: (s*e). Literals, such as blocks, numbers, and text, are of type `(s*e) → ((L*s)*e)`. The idea is that 's' represents the current stack, while 'e' is kept stable and represents the remainder of the environment.
 
 The standard environment elaborates 'e' with a structure designed for flexible workflows and dataflows, concurrency, and extensibility. The type is roughly:
 
     (s * (h * (p * ((sn * lns) * ex))))
 
 Where:
   s: the current stack, where most operations apply
   h: the hand, a temporary store and semantic clipboard
   p: a powerblock, to observe or influence real world
   sn: name of current stack, used when switching stacks
   lns: list of (name*stack) pairs for workspaces and registers
   ex: unused, available for experimental extensions
 
 Thus AO's standard environment supports stack programming, but the extra stacks and powerblocks are very convenient and expressive.
 
 Many basic stack manipulators are borrowed from Factor and FORTH. Also, operations on the stack are often documented using a simple notation for stack effects. "x y z -- y x z" means the top item on the stack (z) remains in place, and the two below it are swapped.
 
 TODO: develop a more compositional environment model for Awelon project, perhaps based on navigating a kd-tree by zipper while carrying an inventory of tools, plus programmable lenses & HUD.
~

@doc.FirstPrincipleIsComposition
"Awelon project favors compositional abstraction. By 'favors' I mean 'with extreme prejudice', prioritizing composition over ad-hoc higher order or parametric abstractions.
 
 There isn't a true conflict: some abstractions are both higher order and compositional. However, prioritizing composition does sacrifice many non-compositional higher-order programming abstractions that have become conventional or established practice in academia and industry today. State machines, records, nominative types, procedural loops, conventional conditional expressions, and even parametric abstraction (where a model is parameterized by a value of *ad-hoc* type) are NOT compositional. Instead, Awelon favors grammars, tables, structural types, incremental processes, sum types, parser combinators, and make systems (staged) or reader monads for dependency injection.
 
 I use 'composition' in the formal sense of a trinity: components, operators, and properties. Components determine expressiveness and what can be described, whether it be 'functions' or 'diagrams' or 'grammars'. Operators determine flexibility. Each operator provides a means to combine two components into a third. Operators must be closed under composition. Properties determine scalability. Every compositional property must be *invariant* (a law) or *inductive* over operators and components. Composional properties enable users to reason about abstract models without knowing deep implementation details.
 
 The challenge of composition is that we must make domain-specific tradeoffs between the three aspects. In a specialized domain, like 'diagrams', we can have many operators and useful properties, but the set of components is small. In a general domain, like functions, we have few common composition operators (compose, left, first) and a few general compositional properties (structural type).
 
 To enable specialized tradeoffs for different parts of a system, Awelon project uses *layering* such that the result of processing one compositional model is another compositional model. Partial evaluation and specialization enable performance even with deep layers. Program search can mitigate the first-order nature of many component models, by abstracting over details. With care, dependent types can be leveraged for safety analysis across diverse layers.
 
 Awelon project provides the features needed for great composition.
 
 Every part of Awelon project is designed with composition as the first principle. In AO we have juxtaposition as composition, words as software components, and effects model via capability security. In ABC, we have concatenative bytecodes, spatial idempotence, causal commutativity, and a non-conventional link model with `{#secureHash}` sources as software components (which may be separately compiled).
 
 But AO is the middle layer. Composition must also be prioritized for higher abstractions: documents, diagrams, geometries, scene-graphs, stories, lenses, grammars, functions, relations, constraints, traits, and so on. I ask that all AO developers embrace composition as first design principle, pervasively, with priority above other features.
 
 Composition provides a formal foundation for long-term benefits.
~
 
@doc.id " -- "
@doc.dup "(Copyable x) ⇒ x -- x x"
@doc.dupd "(Copyable x) ⇒ x y -- x x y"
@doc.over "(Copyable x) ⇒ x y -- x y x"
@doc.tuck "(Copyable y) ⇒ x y -- y x y"
@doc.pick "(Copyable x) ⇒ x y z -- x y z x"
@doc.drop "(Droppable x) ⇒ x -- "
@doc.nip  "(Droppable x) ⇒ x y -- y"
@doc.nip2 "(Droppable x,y) ⇒ x y z -- z"
@doc.swap "y x -- x y"
@doc.swapd "x y z -- y x z"
@doc.rot "x y z -- y z x"
@doc.unrot "y z x -- x y z"
@doc.roll "w x y z -- x y z w"
@doc.unroll "x y z w -- w x y z"
@doc.spin "x y z -- z y x"
@doc.assocl "y x -- (x*y)"
@doc.assocr "(x*y) -- y x"
@doc.intro1 " -- Unit"
@doc.elim1 "Unit -- "

@id 
@dup %r^wzlwl
@dupd swap dup rot
@over dupd swap
@tuck swap over
@pick %rw over %wl swap
@drop %r%
@nip swap drop
@nip2 unrot drop2
@swap  %rwr      %wzw      %lwl
@swapd %rwr %wzr %wzw %lzw %lwl
@rot swapd swap
@unrot swap swapd
@spin swap swapd swap
@roll %rw roll3 %wl swap
@unroll swap %rw unrot %wl
@assocl %rwrzwll
@assocr %rrwzlwl
@intro1 %vvrwlcl
@elim1 %rvrwlcc

@doc.roll{N} "synonyms for swap, rot, roll"
@roll2 swap
@roll3 rot
@roll4 roll

@doc.pswap "(x*y) -- (y*x)"
@doc.xf "(x*y) -- y x"
@doc.xs "(x*y) -- x y"
@doc.pf "y x -- (x*y)"
@doc.ps "y x -- (y*x)"
@pswap %rrwll
@xf assocr
@xs pswap assocr
@pf assocl
@ps assocl pswap

@doc.prefix.id "typeful identity functions for testing optimizers"
@id.swap swap swap
@id.swapd swapd swapd
@id.rot rot rot rot
@id.unrot unrot unrot unrot
@id.roll roll roll roll roll
@id.unroll unroll unroll unroll unroll
@id.spin spin spin
@id.introElim intro1 elim1
@id.elimIntro elim1 intro1
@id.assoclr assocl assocr
@id.assocrl assocr assocl
@id.pswap pswap pswap
@id.dupdrop dup drop
@id.dupSwapDrop dup swap drop
@id.dupSwapdDropSwap dup swapd drop swap
@id.dup2drop2 dup2 drop2
@id.quoteUnquote quote unquote
@id.unquoteQuote unquote quote

@relevant %rkl
@affine   %rfl
@linear   relevant affine
@doc.relevant "mark block on stack as relevant (not Droppable)"
@doc.affine "mark block on stack as affine (not Copyable)"
@doc.linear "mark block on stack as linear (neither Copyable nor Droppable)"

@reifyStack intro1 %rwl
@restoreStack %rwl elim1
@doc.reifyStack "(s*e)→((s*Unit)*e) : stack becomes object on fresh stack"
@doc.restoreStack "((s*Unit)*e)→(s*e) : single object on stack becomes stack"

@doc.drop2 "(Droppable x,y) ⇒ x y -- "
@doc.drop3 "(Droppable x,y,z) ⇒ x y z -- "
@doc.drop4 "(Droppable w,x,y,z) ⇒ w x y z -- "
@drop2 drop drop
@drop3 drop drop drop
@drop4 drop drop drop drop

@doc.dup2 "(Copyable x,y) ⇒ x y -- x y x y"
@doc.dup3 "(Copyable x,y,z) ⇒ x y z -- x y z x y z"
@doc.dup4 "(Copyable w,x,y,z) ⇒ w x y z -- w x y z w x y z"
@dup2 assocl dup %rw 
      assocr %wl
      assocr
@dup3 assocl assocl dup %rw 
      assocr assocr %wl 
      assocr assocr
@dup4 assocl assocl assocl dup %rw 
      assocr assocr assocr %wl 
      assocr assocr assocr

@doc.Quotable
"Most values in AO are quotable, except in contexts where an AO program models a distributed behavior. Distributed values are not quotable; all values entering a quote must have the same location.
 
 A quotation is simply a block that reproduces a value. Quotations can be utilized together with composition for partial application.
 
 If a block with affine or relevant properties is quoted, the quote will inherit these properties. 
~
@doc.quote "(Quotable x) ⇒ x -- [1→x]"
@doc.unquote "[1→x] -- x"
@quote %r'l
@unquote intro1 swap .apply

@doc.Hands
"In AO, the hand is modeled as a second stack. It can be used as a temporary storage for deep operations on the current stack, and also serves as a semantic clipboard for ad-hoc data shuffling.
 
     (currentStack * (hand * ... ))
 
 Developers can:
 
 * take top item from stack into hand
 * put top item from hand onto stack
 * juggle (rotate) a few items
 * discard a value from the hand
 * copy an item from the stack into hand
 * paste an item in the hand onto the stack
 
 In addition, hands are stable when developers use navigational metaphors, i.e. to operate in different workspaces. 
 
 AO encourages a "clean hands" policy: most words should have a neutral effect on the hand, and not affect or observe the values already held by it. The exception is words like `take` and `put` where the purpose is to manipulate the hand. The `apply` word enforces this policy by hiding the current hand when applying a block.
~

@take %rzlw
@put  %wrzl
@discard put drop
@copy dup take
@paste put copy

@take2 take take
@take3 take take take
@take4 take take take take
@put2  put  put
@put3  put  put  put
@put4  put  put  put  put
@juggle2 %w roll2 %w
@juggle3 %w roll3 %w
@juggle4 %w roll4 %w

@doc.take "move value at top of stack to top of hand"
@doc.put "move value at top of hand to top of stack"
@doc.discard "drop and destroy value in hand"
@doc.copy "copy object from top of stack into hand (copy/paste metaphor)"
@doc.paste "paste object from hand onto top of stack (copy/paste metaphor)"

@reifyHand %w reifyStack %w
@restoreHand %w restoreStack %w
@doc.reifyHand "hand becomes single object in fresh hand"
@doc.restoreHand "single object in hand becomes hand"

@id.takePut take put
@id.putTake put take
@id.juggle3 juggle3 juggle3 juggle3
@id.copyDiscard copy discard
@id.pasteDiscardTake paste discard take
@id.reifyRestoreHand reifyHand restoreHand
@id.take3put3 take3 put3

@doc.MakingWithBlocks
"A block in AO consists of code wrapped in square brackets, of form: `[put swap take]` or `[2 add]`. The meaning of a block is a first-class function that may be applied later. Blocks are essential in AO for:
 
 * representing loop behaviors by copying and applying blocks
 * modeling conditional behavior, apply block on just one branch
 * direct models of higher order programs and behavioral abstraction
 * transporting access and authority to resources and side-effects
 
 Best practices for use of blocks have not fully been established. Awelon project favors compositional abstractions to such an extent that use of ad-hoc parametric abstraction is discouraged. (See @doc.FirstPrincipleIsComposition.) My expectation is that blocks will be de-emphasized for behavioral abstraction in favor of indirect mechanisms - e.g. structured DSLs, symbolic expressions, free monads, staged programming. In this sense, AO discourages conventional 'functional programming' in favor of a more 'language oriented programming'.
 
 Nonetheless, blocks remain essential for loops, effects, and conditions. Also, blocks make an effective compilation target, an alternative to interpretation, and they can help an embedded DSL model corner cases.
 
 Blocks can be composed.  Composition working together with quotation can also model such features as partial, concurrent, and conditional application.
 
     o       :: [x→y] [y→z] -- [x→z]      (sequential)
     .curry  :: x [(x*y)→z] -- [y→z]      (partial)
     .first  :: [x→x'] -- [(x*e)→(x'*e)]  (concurrent)
     .left   :: [x→x'] -- [(x+e)→(x'+e)]  (conditional)
 
 Some readers might be familiar with the notions of 'first' and 'left' from John Hughes' arrow model, which was an important foundation for AO and RDP.
 
 Above, I described primitive forms. The 'curry', 'first', and 'left' words must more generally be sensitive to the programming environment. (Unfortunately, I lack a good notation for effects on a multi-stack environment. I plan to rely on automatic visualization features to explain such things.)
 
 In addition, blocks may be constructed by quotation of a value:
 
     quote   :: (Quotable x) ⇒ x -- [1→x]
     unquote :: [1→x] -- x
 
 After construction, blocks can be applied in various ways. Developers will mostly use 'apply', which applies a block to the current environment except for the hand. Items in the current hand are hidden. But there are other operations that include (potentially) useful patterns for data hiding and application.
 
     .apply :: x [x→y] -- y (apply block on stack to next value on stack)
     .dip   :: (apply block to everything except top object on stack)
     apply  :: (apply block on stack to full environment, hiding current hand)
     inline :: (apply block on stack as if written inline, i.e. hand is visible)
     dip    :: (hides hand and top items on stack)
     bi     :: (Copyable x) ⇒ x [x→y] [x→z] -- y z
 
 The set of application words will undoubtedly evolve with experience.
~


@o pf %rrol
@.apply pf %rr$l
@.dip %rwrzwvrwr %$ %wlcl
@apply reifyHand put .dip take restoreHand
@inline %rvr$c
@dip  take  apply put
@dip2 take2 apply put2
@dip3 take3 apply put3
@dip4 take4 apply put4

@doc.PrimitiveMath
"The intention is for AO to operate easily with units and matrices. The prefix '.' is used for primitive math operations on naked, scalar numbers. These operators include `.add`, `.multiply`, `.negate`, `.invert`, `.divMod`, `.subtract`, and `.divide`. The same operations without the prefix will eventually refer to versions that contain dispatch logic for common value types, requiring very aggressive optimization.
 
 More generally, AO will be leaning towards symbolic math libraries, i.e. such that we build expressions in a math DSL rather than directly compute results. This enables much richer analysis and optimization to be performed within the language, at expense of making it difficult to directly optimize the language (except by partial evaluation).
~

@.multiply pf %rr*l
@.add      pf %rr+l
@.negate   %r-l
@.invert   %r/l
@.divMod   pf %rrQll xs
@.subtract .negate .add
@.divide   .invert .multiply

@doc..multiply "N(b) N(a) -- N(a*b)"
@doc..add "N(b) N(a) -- N(a+b)"
@doc..negate "N(a) -- N(-a)"
@doc..invert "N(a) -- N(1/a); a must be non-zero"
@doc..divMod "N(a) N(b) -- N(r) N(q) where a=q*b+r and r in (b,0] or [0,b)"
@doc..subtract "N(a) N(b) -- N(a-b)"
@doc..divide "N(a) N(b) -- N(a/b)"

@id.mul1 1 .multiply
@id.div1 1 .divide
@id.add0 0 .add
@id.sub0 0 .subtract



@doc.EnvironmentManipulation
"AO developers aren't limited to a single instance of the standard environment. Subprograms may be computed in their own complete environments, and objects may be shifted from one environment to another (using the hand, by default, for data shuffling). 
 
 Developers can:
 
   * create a fresh, empty environment on the stack
   * safely destroy an empty environment on the stack
   * swap environment on the stack with the current 
   * apply a function in a fresh environment
 
 (TODO: make the above possible with simple words)
 
 When swapping to a new environment, the current hand and powerblock come with the user (at least by the standard functions). It isn't difficult to abstract motion that also switches hands and tools.
 
 Environments can simplify reasoning about subprogram interactions. 
~

@doc.TODO
"Much to do about AO
  * functions on lists, association lists, records
  * optimizers and compilers for ABC, AMBC, and AO
  * simplified app type for quick integration with Haskell? (use plugins?)
  * 2D-3D scene-graphs based on enneatrees and zippers
  * secure pseduo-random number generators; probabilistic programs
  * math libs - linear algebra, symbolic maths
  * knowledge databases as words (or sets thereof) in dictionary
  *   unicode
  *   countries, flags, populations, maps
  *   project Gutenberg novels
 
 AO's design philosophy is actually similar to Wolfram's - that code should have easy access to vast quantities of useful, maintainable data. AO provides this access in the form of words in a very large dictionary.
~

@JUNK

% Environment Manipulations
%
%  (todo) fix for new environment model... need to choose name for
%  initial stack? Maybe "main"?
%
%  wrapE - wrap a value in a fresh environment; wrapped value becomes
%    the only element in a fresh env's current stack. If `wrapE` is 
%    called without a specific target, it captures the current 
%    environment.
%  wrapS - capture current stack as a value, which is afterwards the
%    only value on the current stack. 
%  unwrapE/unwrapS - reverse these manipulations.
%
% The normal block applicators will wrap a new environment around the
% arguments before applying the block. This allows subprograms to use
% the multi-stack and hands concept, but prevents accidental coupling
% with the current environment. 
%
%wrapE = intro1 swap intro1 swap intro1 intro1 intro1 assocl swap
%unwrapE = swap assocr elim1 elim1 elim1 swap elim1 swap elim1
%wrapS = assocr intro1 rot3 pzip assocl rot2 assocl
%unwrapS = swap rot3 assocr rot2 elim1 rot3 rot3 swap


% Combinators: remove a block from top of the current stack, and 
%   apply it to all or part of the environment.
%
%   apply: target whole environment (as if block is coded inline)
%   appX: target top item on stack (without fresh environment)
% 
% Note that these do not wrap the input in a fresh environment, so
% only `appE` is directly usable.
%
apply = assocr intro1 swap assocr first swap elim1
appX = assocr rot2 assocr rot3 first assocl

@doc.Zippers
"The zipper data structure was described by Gérard Huet in 1997. It enables navigation and modification of tree-structured data in a purely functional context. At any time, the original tree structure can be recovered with the modifications. For Awelon project, zippers are widely useful for modeling navigation through scene graphs or documents, and document-like structures. They may also be used for raycasting and rendering.
 
 To support user intuitions, zippers should be specialized for common data structures. However, AO does provide a few standard primitives for zippers on AO's product data type.
~

@doc.HigherOrderZippers
"Zippers are a first derivative on a data structure. However, higher derivatives are also very useful. For example, first derivative can focus on a single character in text, but second derivative models an expandable selection of text. In a scene graph, such could model a mobile bounding volume. 
 
 I don't grasp third derivatives yet, but my intuition is that it can help structurally abstract sweeps or convolutions, e.g. the process of casting a ray through a scene-graph.
~ 



@doc.ioapp
"'ioapp' names a trivial application model.
 
 An ioapp application takes a single input, just a linear block called 'powerblock' roughly of form `[{io}]` and type:
 
     µ P . [message → (P * result)]
 
 Effects are achieved by directly messaging the powerblock. Responses include a new linear powerblock and a result value. Operations on the powerblock are single-threaded, protecting AO's assumption of causal commutativity and spatial idempotence. Depending on the message set, asynchronous or multi-threaded operations are quite feasible.
 
 This model is useful for quickly bootstrapping. However, it does not offer many other advantages for safety, parallelism, optimization, documentation. It is very ad-hoc. The intention is to deprecate this model quickly.
~ 

@JUNK

% 
% In Awelon, zipper operations apply to top object on current stack. 
%
%    zwrap - prepare zipper; stack object is initial target
%    zf - if target was (x*y), x is now target; undo with zuf
%    zs - if target was (x*y), y is now target; undo with zus
%    zu - undoes last zipper navigation (selects zuf or zus)
%    zunwrap - fully exit and unwrap zipper, even if deep
%    zunwrap_ - just unwrap zipper
%
% Knowing the representation of the zipper structure isn't essential,
% but it might be interesting to some people. 
%
%    zwrap :: x <~> x*(1*1) :: zunwrap_ (on stack)
%    zf    :: (x*y)*(l*r) <~> x*(1*(y*(l*r))) :: zuf
%    zs    :: (x*y)*(l*r) <~> y*((x*l)*r)     :: zus
%
% The 'zu' and 'zunwrap' operations must perform introspection. 
%
% To manipulate the zipper target, developers will usually use an
% operation such as:
%   
%    zswap - switch target of zipper (2nd) with object on stack (1st)
%    zpop  - move target to top of stack (unit placeholder)
%    zpush - undo zpop
%
zwrap = intro1 intro1 assocl rot2 pzip assocl  
zunwrap_ = assocr pzip rot2 assocr elim1 elim1  
zf = assocr xf intro1 assocl roll2 assocl 
zuf = assocr roll2 assocr elim1 cf assocl
zs = assocr xf roll3 cs roll2 assocl
zus = assocr roll2 xf roll3 cs assocl
zswap = cf assocr roll2 assocl xf
zpop = intro1S zswap
zpush = zswap elim1S
% TODO: zu, zu*
zu = % look at wrapper to decide step back
zu* = % iterative zu
zunwrap = zu* zunwrap_

@doc.rgb "usage: `1/3 5/7 4/5 rgb` in red-green-blue order"
@rgb 1 rgba
@rgba ps ps ps "rgba" pf
@rgb/8 
    take2 fracOfOctet
    put   fracOfOctet
    put   fracOfOctet
    rgba
@fracOfOctet 1/255 .multiply

@doc.prefix.# "prefix '#' is for widely useful named constants."
@doc.Colors "Following Elm's example - using the [Tango](http://tango.freedesktop.org/Tango_Icon_Theme_Guidelines) pallette, with simple names."

@#lightRed      0xef 0x29 0x29 rgb/8
@#red           0xcc 0x00 0x00 rgb/8
@#darkRed       0xa4 0x00 0x00 rgb/8 
@#lightOrange   0xfc 0xaf 0x3e rgb/8
@#orange        0xf5 0x79 0x00 rgb/8
@#darkOrange    0xce 0x5c 0x00 rgb/8
@#lightYellow   0xfc 0xe9 0x4f rgb/8
@#yellow        0xed 0xd4 0x00 rgb/8
@#darkYellow    0xc4 0xa0 0x00 rgb/8
@#lightGreen    0x8a 0xe2 0x34 rgb/8
@#green         0x73 0xd2 0x16 rgb/8
@#darkGreen     0x4e 0x9a 0x06 rgb/8
@#lightBlue     0x72 0x9f 0xcf rgb/8
@#blue          0x34 0x65 0xa4 rgb/8
@#darkBlue      0x20 0x4a 0x87 rgb/8
@#lightPurple   0xad 0x7f 0xa8 rgb/8
@#purple        0x75 0x50 0x7b rgb/8
@#darkPurple    0x5c 0x35 0x66 rgb/8
@#lightBrown    0xe9 0xb9 0x6e rgb/8
@#brown         0xc1 0x7d 0x11 rgb/8
@#darkBrown     0x8f 0x59 0x02 rgb/8
@#white         0xff 0xff 0xff rgb/8
@#lightGrey     0xee 0xee 0xec rgb/8
@#grey          0xd3 0xd7 0xcf rgb/8
@#darkGrey      0xba 0xbd 0xb6 rgb/8
@#lightCharcoal 0x88 0x8a 0x85 rgb/8
@#charcoal      0x55 0x57 0x53 rgb/8
@#darkCharcoal  0x23 0x34 0x36 rgb/8
@#black         0x00 0x00 0x00 rgb/8

@#gray      #grey
@#lightGray #lightGrey
@#darkGray  #darkGrey

@doc.prefix.` "prefix '`' is for units on numbers."
@`g  1/1000 .multiply `kg


