
@doc.import.std "one big starting point for AO systems"

@doc.NamingConventions
"AO makes heavy use of naming conventions. Common prefixes suggest automatic processing or type information. For example, 'doc.' indicates documentation for a word, and 'test.' indicates automatic testing in a mockup environment, and 'id.' indicates that a given expression should be equivalent to identity for all the types it accepts. Similarly, suffixes connote context. A suffix might identify a specific framework, project, or programmer.
 
 Multi-part words unfortunately make AO verbose and difficult to read. 
 
 The intention is to mitigate this issue in the editor. A set of rules (configurable per user or project) will translate common prefixes and suffixes into rendering with colors and styles. Also, fuzzy autocomplete mechanisms can eliminate need to fully write out large words.
~

@doc.prefix.doc
"AO does not have 'comments' in the usual sense. Instead, it has documentation words. A word that starts with 'doc' should add documentation in a common format, such as markdown text. If a word is too complicated to effectively document this way, consider factoring its definition into smaller pieces!
~

@doc.StandardEnvironment
"AO is not a stack-based programming language. One might better call it pair-based, but even that is somewhat misleading. AO is value-based. The value involved may be composed from six basic structural types: product (pair), sum, unit, void, number, and block (function). AO words will analyze and manipulate this tacit value.
 
 However, by convention, the tacit value will model a stack-based programming environment plus extensibility features. Literals in AO have form `"foo" :: (s*e)→((Text*s)*e)`, effectively treating `s` as an implicit stack and `e` as a stable environment. The standard environment elaborates 'e' with structure for flexible workflows and dataflows, concurrency, and extensibility. Standard data shuffling words are designed assuming the standard environment. The type is roughly:
 
     (s * (h * (p * ((sn * rns) * ex))))
 
 Where:
   s: the current stack, where most operations apply
   h: the hand, temporary store and semantic clipboard
   p: a powerblock, to observe or influence real world
   sn: name of current stack, used when switching stacks
   rns: record of (name*stack) pairs for workspaces and registers
   ex: unused; available for experimental extensions
 
 As mentioned above, `s` is the primary active stack. That's where all stack shufflers apply, where all math is performed. However, AO is unlike most other stack-based languages, e.g. with respect to its capability-based effects and causal commutativity. As a consequence of these differences, AO can be very implicitly concurrent - i.e. by modeling different computations on different stacks. Non-deterministic concurrency can also be modeled, using oracle machine idioms.
 
 Stack manipulations are often described using 'stack effect' strings, as used in Factor or Forth. For example, "x y z -- y x z" suggests that the top item on the current stack (z) remains in place, and the elements below it are swapped. Such annotations are for documentation purposes. AO does not have any built-in support for type description, beyond assertions and merges.
 
 This particular computing environment is suitable for text-based programming environments. I have an alternative in mind for Awelon project, which involves navigation metaphors (spatial/kd-trees by zipper) while wielding an inventory of recomposable tools including programmable glasses (lenses, HUD).
~

@doc.id " -- "
@doc.dup "(Copyable x) ⇒ x -- x x"
@doc.dupd "(Copyable x) ⇒ x y -- x x y"
@doc.over "(Copyable x) ⇒ x y -- x y x"
@doc.tuck "(Copyable y) ⇒ x y -- y x y"
@doc.pick "(Copyable x) ⇒ x y z -- x y z x"
@doc.drop "(Droppable x) ⇒ x -- "
@doc.nip  "(Droppable x) ⇒ x y -- y"
@doc.nip2 "(Droppable x,y) ⇒ x y z -- z"
@doc.swap "y x -- x y"
@doc.swapd "x y z -- y x z"
@doc.rot "x y z -- y z x"
@doc.unrot "y z x -- x y z"
@doc.roll "w x y z -- x y z w"
@doc.unroll "x y z w -- w x y z"
@doc.spin "x y z -- z y x"
@doc.intro1 " -- Unit"
@doc.elim1 "Unit -- "

@id 
@dup %r^wzlwl
@dupd swap dup rot
@over dupd swap
@tuck swap over
@pick %rw over %wl swap
@drop %r%
@nip swap drop
@nip2 unrot drop2
@swap  %rwr %wzw %lwl
@swapd %rw swap %wl
@rot swapd swap
@unrot swap swapd
@spin swap swapd swap
@roll %rw rot %wl swap
@unroll swap %rw unrot %wl
@intro1 %vvrwlcl
@elim1 %rvrwlcc
@roll2 swap
@roll3 rot
@roll4 roll

@doc.pw "(x*y) -- (y*x)"
@doc.xf "(x*y) -- y x"
@doc.xs "(x*y) -- x y"
@doc.pf "y x -- (x*y)"
@doc.ps "y x -- (y*x)"
@pw %rrwll
@xf %rrwzlwl
@xs pw xf
@pf %rwrzwll
@ps pf pw

@doc.swapStackName "text -- text; replace name for current stack"
@doc.setStackName "text -- ; set name for the current stack"
@doc.getStackName "-- text ; get name for current stack"
@swapStackName %lzrzrzwrwzwlwzlzlzr
@setStackName swapStackName drop
@getStackName intro1 swapStackName copy swapStackName elim1 put
@id.swapStackName swapStackName swapStackName
@id.getSetStackName getStackName setStackName

@doc.swapPowerBlock "power -- power; replace powerblock in standard env"
@swapPowerBlock %zrwzwlz
@id.swapPowerBlock swapPowerBlock swapPowerBlock

@doc.prefix.eqv 
"There are many cases where two different expressions should be equivalent. Explicitly asserting so is useful! Not only may equivalencies serve as documentation, but they also can support automatic tests or provide hints for optimizers and refactoring tools. So prefix 'eqv' provides a generic way to suggest that two expressions should be equivalent.
 
 The type of an 'eqv.foo' word should be:  ( -- [a→b] [a→b]). 
 
 That is, developers should simply add two blocks to the current stack, which should have equivalent behavior modulo typeful identity. Use of the 'eqv' prefix enables external tools to systematically discover, document, and validate these assertions. 
 
 A more specialized equivalency is also available with prefix 'id'. Eventually, there may be specialized prefixes for for idempotence (`f f = f`) and commutativity (`f g = g f`), and similar properties (plus associativity) for binary functions. However, for now, these may be expressed by eqv.
~
@eqv.takeSwapPut.swapd [take swap put] [swapd]
@eqv.swap.pfxs [pf xs] [swap]
@eqv.swap.psxf [ps xf] [swap]
@eqv.pf1drop2 [pf drop] [drop2]
@eqv.pf2drop3 [pf pf drop] [drop3]
@eqv.pf3drop4 [pf pf pf drop] [drop4]
@eqv.ps2drop3 [ps ps drop] [drop3]
@eqv.commutative.affine&relevant [affine relevant] [relevant affine]
@eqv.idempotent.linear [linear linear] [linear]
@eqv.idempotent.affine [affine affine] [affine]
@eqv.idempotent.relevant [relevant relevant] [relevant]
@eqv.dupSwap [dup swap] [dup]

@doc.prefix.id 
"There are many cases where a sequence of operations should have operations should have no total, observable effect. For example, `swap swap` is the same as taking no action. These sequences are essentially instances of the 'identity' behavior, modulo slight differences on the required input type - i.e. they are 'typeful' identities. 
 
 The 'id' prefix is a specialized equivalence that also implies idempotence and commutativity. Look into the 'idempotent', 'commutative', and 'eqv' prefixes.
 
 Use of prefix words to declare properties such as identity, idempotence, associativity, and commutativity is useful for documentation, automatic validation, and development of optimizers. Developers are encouraged to do so.
~ 

@id.swap swap swap
@id.swapd swapd swapd
@id.rot rot rot rot
@id.unrot unrot unrot unrot
@id.roll roll roll roll roll
@id.unroll unroll unroll unroll unroll
@id.spin spin spin
@id.introElim intro1 elim1
@id.elimIntro elim1 intro1
@id.pfxf pf xf
@id.xfpf xf pf
@id.pw pw pw
@id.dupdrop dup drop
@id.dupSwapDrop dup swap drop
@id.dupSwapdDropSwap dup swapd drop swap
@id.dup2drop2 dup2 drop2
@id.quoteUnquote quote unquote
@id.unquoteQuote unquote quote
@id.textDrop "text" drop

@id.pfxsswap pf xs swap
@id.swappfxs swap pf xs

@relevant %rkl
@affine   %rfl
@linear   relevant affine
@doc.relevant "mark block on stack as relevant (not Droppable)"
@doc.affine "mark block on stack as affine (not Copyable)"
@doc.linear "mark block on stack as linear (neither Copyable nor Droppable)"

@reifyStack intro1 %rwl
@restoreStack %rwl elim1
@doc.reifyStack "(s*e)→((s*Unit)*e) : stack becomes object on fresh stack"
@doc.restoreStack "((s*Unit)*e)→(s*e) : single object on stack becomes stack"

@doc.drop2 "(Droppable x,y) ⇒ x y -- "
@doc.drop3 "(Droppable x,y,z) ⇒ x y z -- "
@doc.drop4 "(Droppable w,x,y,z) ⇒ w x y z -- "
@drop2 drop drop
@drop3 drop drop drop
@drop4 drop drop drop drop

@doc.dup2 "(Copyable x,y) ⇒ x y -- x y x y"
@doc.dup3 "(Copyable x,y,z) ⇒ x y z -- x y z x y z"
@doc.dup4 "(Copyable w,x,y,z) ⇒ w x y z -- w x y z w x y z"
@dup2 pf dup %rw xf %wl xf
@dup3 pf pf dup %rw xf xf %wl xf xf 
@dup4 pf pf pf dup %rw xf xf xf %wl xf xf xf

@doc.Quotable
"Most values in AO are quotable, except in contexts where an AO program models a distributed behavior. Distributed values are not quotable; all values entering a quote must have the same location.
 
 A quotation is simply a block that reproduces a value. Quotations can be utilized together with composition for partial application.
 
 If a block with affine or relevant properties is quoted, the quote will inherit these properties. 
~
@doc.quote "(Quotable x) ⇒ x -- [1→x]"
@doc.unquote "[1→x] -- x"
@quote %r'l
@unquote intro1 swap .apply

@doc.Hands
"In AO, the hand is modeled as a second stack. It can be used as a temporary storage for deep operations on the current stack, and also serves as a semantic clipboard for ad-hoc data shuffling.
 
     (currentStack * (hand * ... ))
 
 Developers can:
 
 * take item from stack into hand
 * put top item from hand onto stack
 * juggle (rotate) a few items
 * discard a value from the hand
 * copy an item from the stack into hand
 * paste an item in the hand onto the stack
 
 In addition, hands are stable when developers use navigational metaphors, i.e. to operate in different workspaces or environments. Also, hands are hidden by some operations, such as `apply`.
 
 AO encourages a "clean hands" policy: most words should have a neutral effect on the hand, and not affect or observe the values already held by it. The exception is words like `take` and `put` where the purpose is to manipulate the hand. Some common words, such as `apply`, will hide the hand - making
~

@take %rzlw
@put  %wrzl
@discard put drop
@copy dup take
@paste put copy

@take2 take take
@take3 take take take
@take4 take take take take
@put2  put  put
@put3  put  put  put
@put4  put  put  put  put
@juggle2 %w roll2 %w
@juggle3 %w roll3 %w
@juggle4 %w roll4 %w

@taked swap take
@putd put swap

@doc.take "move value at top of stack to top of hand"
@doc.put "move value at top of hand to top of stack"
@doc.discard "drop and destroy value in hand"
@doc.copy "copy object from top of stack into hand (copy/paste metaphor)"
@doc.paste "paste object from hand onto top of stack (copy/paste metaphor)"
@doc.taked "take second item from stack"
@doc.putd "put below first item on stack"

@reifyHand %w reifyStack %w
@restoreHand %w restoreStack %w
@doc.reifyHand "hand becomes single object in fresh hand"
@doc.restoreHand "single object in hand becomes hand"
@doc.swapHands "swap reified hand on stack with current hand"
@swapHands %rwzwl

@id.takePut take put
@id.putTake put take
@id.juggle3 juggle3 juggle3 juggle3
@id.takeJugglePutSwap take2 juggle2 put2 swap
@id.takeSwapPutSwapd take swap put swapd
@id.copyDiscard copy discard
@id.pasteDiscardTake paste discard take
@id.reifyRestoreHand reifyHand restoreHand
@id.take3put3 take3 put3

@doc.MakingWithBlocks
"A block in AO consists of code wrapped in square brackets, of form: `[put swap take]` or `[2 add]`. The meaning of a block is a first-class function that may be applied later. Blocks are essential in AO for:
 
 * representing loop behaviors by copying and applying blocks
 * modeling conditional behavior, apply block on just one branch
 * direct models of higher order programs and behavioral abstraction
 * transporting access and authority to resources and side-effects
 
 Best practices for use of blocks have not fully been established. Awelon project favors compositional abstractions to such an extent that use of ad-hoc parametric abstraction is discouraged. (See @doc.FirstPrincipleIsComposition.) My expectation is that blocks will be de-emphasized for behavioral abstraction in favor of indirect mechanisms - e.g. structured DSLs, symbolic expressions, free monads, staged programming. In this sense, AO discourages conventional 'functional programming' in favor of a more 'language oriented programming'.
 
 Nonetheless, blocks remain essential for loops, effects, and conditions. Also, blocks make an effective compilation target, an alternative to interpretation, and they can help an embedded DSL model corner cases.
 
 Blocks can be composed.  Composition working together with quotation can also model such features as partial, concurrent, and conditional application.
 
     compose :: [x→y] [y→z] -- [x→z]      (sequential)
     .curry  :: x [(x*y)→z] -- [y→z]      (partial)
     .bfirst :: [x→y] -- [(x*e)→(y*e)]    (concurrent)
     .bleft  :: [x→y] -- [(x+e)→(y+e)]    (conditional)
 
 Some readers might be familiar with the notions of 'first' and 'left' from John Hughes' arrow model, which was an important foundation for AO and RDP. The primitive forms of '.curry' and '.bfirst', etc.. aren't very useable in the standard environment, but derived forms will also be available. 
 
 In addition, blocks may be constructed by quotation of a value:
 
     quote   :: (Quotable x) ⇒ x -- [1→x]
     unquote :: [1→x] -- x
 
 After construction, blocks can be applied in various ways. Developers will mostly use 'apply', which applies a block to the current environment except for the hand. Items in the current hand are hidden. But there are other operations that include (potentially) useful patterns for data hiding and application.
 
     .apply :: x [x→y] -- y (apply block to just top object on stack)
     .dip   :: (apply block to everything except top object on stack)
     apply  :: (apply block on stack to full environment, hiding current hand)
     inline :: (apply block on stack as if written inline, i.e. hand is visible)
     dip    :: (hides hand and top item on stack)
     keep   :: copies top item on stack before apply, then replaces them.
     applyP :: hide the powerblock in the hand during apply 
 
 The set of application words will undoubtedly evolve with experience.
~

@doc.compose "[x→y] [y→z] -- [x→z]; compose functions"
@doc.composel "[y→z] [x→y] -- [x→z]; compose on left"

@compose pf %rrol
@composel swap compose
@.apply pf %rr$l
@.dip %rwrzwvrwr %$ %wlcl
@apply reifyHand put .dip take restoreHand
@applyP intro1 swapPowerBlock take apply put swapPowerBlock elim1
@inline %rvr$c
@dip   take take juggle2 put apply put
@dip2  take pf take juggle2 put apply put xf
@dip3  take pf pf take juggle2 put apply put xf xf
@dip4  take pf pf pf take juggle2 put apply put xf xf xf
@keep  take copy juggle2 put apply put
@keep2 take pf copy xf juggle2 put apply put xf
@keep3 take pf pf copy xf xf juggle2 put apply put xf xf
@keep4 take pf pf pf copy xf xf xf juggle2 put apply put xf xf xf

@id.apply.id [id] apply
@id.applyP.id [id] applyP
@id.compose [id] compose
@id.swap.compose [id] swap compose
@id.inline.id [id] inline

@doc..first "(a*b) [a→a'] -- (a'*b)"
@doc..second "(a*b) [b→b'] -- (a*b')"
@doc..applyP "(a*b) [a→a'] [b→b'] -- (a'*b')"
@.first take xf put .apply pf
@.second take pw put .first pw
@.applyP take .first put .second

@eqv.cca [.applyP] [swap take2 pw put2 .applyP pw]

@doc.PrimitiveMath
"The intention is for AO to operate easily with units and matrices. The prefix '.' is used for primitive math operations on naked, scalar numbers. These operators include `.add`, `.multiply`, `.negate`, `.invert`, `.divMod`, `.subtract`, and `.divide`. The same operations without the prefix will eventually refer to versions that contain dispatch logic for common value types, requiring very aggressive optimization.
 
 More generally, AO will be leaning towards symbolic math libraries, i.e. such that we build expressions in a math DSL rather than directly compute results. This enables much richer analysis and optimization to be performed within the language, at expense of making it difficult to directly optimize the language (except by partial evaluation).
~

@.mul pf %rr*l
@.add pf %rr+l
@.neg %r-l
@.inv %r/l
@.divMod pf %rrQll xs
@.quot .divMod nip
@.rem  .divMod drop
@.sub .neg .add
@.div .inv .mul

@doc..mul "N(b) N(a) -- N(a*b)"
@doc..add "N(b) N(a) -- N(a+b)"
@doc..neg "N(a) -- N(-a)"
@doc..inv "N(a) -- N(1/a); a must be non-zero"
@doc..divMod "N(a) N(b) -- N(r) N(q) where a=q*b+r and r in (b,0] or [0,b)"
@doc..quot "just the quotient from .divMod"
@doc..rem "just the remainder from .divMod"
@doc..sub "N(a) N(b) -- N(a-b)"
@doc..div "N(a) N(b) -- N(a/b)"

@id.mul1 1 .mul
@id.div1 1 .div
@id.add0 0 .add
@id.sub0 0 .sub

@doc.ConditionalBehavior
"Awelon expresses conditional behavior using sum types. 
 
 A sum type, `(a + b)`, indicates a value that is either left in `a` or right in `b`. A boolean, having two values, could be modeled as `(1 + 1)` where 1 is the unit type (having one value). However, AO does not heavily use booleans. For example, the output of comparing two values will initially contain the compared values, such that no information is lost. 
 
 In AO, a sum type is the result of an *observation*. For primitive observations, one may ask whether a value (other than unit) is a pair, sum, number, or block. Numbers and complex products or sums of numbers may also be compared, e.g. to test whether one number is greater than another. Unit may only be compared against unit. (The limitations against observing unit help developers model static structure.)
 
 By convention, when observing a binary condition `(a + b)`, the right answer `b` indicates truth or success. The left answer `a` indicates falsehood or failure. Standard words are developed using this convention. AO's variation of the 'not' word simply mirrors left and right, i.e. `not :: (a + b) -- (b + a)`.
 
 Conditional behavior is expressed by applying a block on just one condition. The block must be droppable (because it might not apply). Compared to most languages, ABC is unusually precise regarding distribution of data across a condition. However, coarse-grained if/then/else or Haskell-like 'either' idioms may be expressed.
~

@isPair   %rPl
@isSum    %rSl
@isNumber %rNl
@isBlock  %rBl
@not      %rVRWLCl

@id.isPairMerge  isPair merge
@id.isSumMerge   isSum merge
@id.isNumMerge   isNumber merge
@id.isBlockMerge isBlock merge
@id.notnot       not not

@doc.inR "b -- (0 + b); wrap 'b' in success, mark true"
@doc.inL "a -- (a + 0); wrap 'a' in failure, mark false"
@inR %rVVRWLCl
@inL %rVl

@doc.gt "a b -- ((a*b) + (b*a)); a > b?"
@doc.lt "a b -- ((b*a) + (a*b)); a < b?"
@doc.gte "a b -- ((a*b) + (b*a)); a >= b?"
@doc.lte "a b -- ((b*a) + (a*b)); a =< b?"
@gt  pf %rr>l
@lt  swap gt
@gte lt not
@lte gt not

@doc.compare "a b -- (((LT(a*b) + EQ(b*a)) + GT(b*a))"
@doc.eq  "a b -- ((LT(a*b) + GT(b*a)) + EQ(b*a))"
@doc.neq "a b -- (EQ(b*b) + (LT(a*b) + GT(b*a)))"
@compare gt [%vv xs lt not %cc] .left
@eq neq not
@neq compare %rRWl

@doc.factorp "((a*b)+(c*d)) -- (b + d) (a + c)"
@doc.merge   "(a + a') -- a; a and a' must be future compatible"
@doc.factor  "((a+b)+(a'+d)) -- (b+c) a"
@factor_p %rFll xf
@merge    %rMl
@factor   factor_p merge

@doc.distrib "(a + b) c -- ((c*a) + (c*b))"
@distrib pf %rrDl

@doc..left  "(a + b) [a→a'] -- (a' + b); apply block on left condition"
@doc..right "(a + b) [b→b'] -- (a + b'); apply block on right condition"
@doc..either "(a + b) [a→a'] [b→b'] -- (a' + b')"
@.left pf %rr?l
@.right take not put .left not
@.either take .left put .right

@eqv.cca+ [.either] [swap take2 not put2 .either not]

@doc..distribE
"Distribute the environment minus the top element on the stack, using the condition expressed in the second item on the stack. This doesn't require a standard environment, beyond the current stack:
 
    (k*((a+b)*s)*e→(((a*s)*e)+((b*s)*e))*k
 
 Note: this operation is not entirely parametric in context of spatial-temporal types. Relevantly, we cannot always distribute an observed condition (+) to a remote or heterogeneous partition.
~
@.distribE 
   %rvrwlc    "(((a+b)*s)*e)*k" drop
   %rrwzlD    "(s*e)*((a+b)*k)" drop
   %D         "(((s*e)*a)+((s*e)*b))*k" drop
   [%vrwlcl] %r? %VRWLC
   [%vrwlcl] %r? %VRWLC
   
@doc..factorE "reverses @.distribE"

@doc.leftE "(a+b) [a -- a'] -- (a'+b); left with full env"
@doc.rightE "(a+b) [b -- b'] -- (a+b'); right with full env"

@leftE 
pf reifyHand put swap take @TODO
@rightE take not put leftE not

@doc.assert 
"AO and ABC offer a primitive mechanism to assert that a condition is not false, i.e. that `(a + b)` is not in `a`. (The condition is not necessarily true, i.e. it may be that the assertion itself is dead code.) Since the condition after a successful assertion is not false, we eliminate the sum type and just continue with `b`.
 
     assert :: (a + b) -- b
 
 In addition, specialized asserts can be much easier to use. These operate as identity functions, but with a limited acceptance criteria.
 
     assertPair, assertBlock, assertSum, assertNumber, assertUnit -- basic type
     assertLT, assertLTE -- assert upper bounds for a comparable value
     assertGT, assertGTE -- assert lower bounds for a comparable value
 
 And common number assertions...
 
     assertNumber, assertInteger -- assertions on number types
     assertGTz, assertGTEz -- assert greater than or equal to zero
     assertEQz, assertNEQz -- assert equal or not equal to zero
     assertLTz, assertLTEz -- assert less than or equal to zero
     assertNatural -- integer greater than or equal to zero
     assertNatural+ -- integer greater than or equal to one
     assertChar -- integer between 0 and 1114111 inclusive
     assertProb -- rational number between 0 inclusive and 1 inclusive
     assertUniform -- rational number between 0 inclusive and 1 exclusive
 
 To clarify, `assert` is primarily intended for *static* analysis. It provides a means to express some preconditions, postconditions, and refinement types. These conditions should ideally be computable via partial evaluation, such that developers can receive compile time errors or warnings or errors based on whether an asserted condition is disproven or unproven.
 
 In an effectful program, some assertions may have dynamic nature. In that case, modulo use of capabilities designed to isolate failure, a dynamic assertion failure causes the whole program to be halted as quickly and cleanly as feasible.
~
@assert   %rKl

@assertLT   lt assert xs
@assertLTE  lte assert xs
@assertGT   gt assert xf
@assertGTE  gte assert xf
@assertEQ   eq assert xf
@assertNEQ  neq assert [%vrwlc] .left merge xf

@assertLTz  assertNumber 0 assertLT drop
@assertLTEz assertNumber 0 assertLTE drop
@assertGTz  assertNumber 0 assertGT drop
@assertGTEz assertNumber 0 assertGTE drop
@assertEQz  0 assertEQ drop
@assertNEQz assertNumber 0 assertNEQ drop

@assertPair   isPair assert
@assertNumber isNumber assert
@assertBlock  isBlock assert
@assertSum    isSum assert
@assertUnit   elim1 intro1

@assertInteger  dup 1 .rem assertEQz drop
@assertNatural  assertGTEz assertInteger
@assertNatural+ assertGTz  assertInteger
@assertChar     assertNatural 0x10ffff assertLTE drop
@assertProb     assertGTEz 1 assertLTE drop
@assertUniform  assertGTEz 1 assertLT drop

@id.assertInR inR assert
@id.assertPair assertPair
@id.assertNumber assertNumber
@id.assertBlock assertBlock
@id.assertSum assertSum
@id.assertUnit assertUnit
@id.assertLT assertLT
@id.assertLTE assertLTE
@id.assertGT assertGT
@id.assertGTE assertGTE
@id.assertEQ assertEQ
@id.assertNEQ assertNEQ
@id.assertLTz assertLTz
@id.assertGTz assertGTz
@id.assertGTEz assertGTEz
@id.assertLTEz assertLTEz
@id.assertEQz assertEQz
@id.assertInteger assertInteger
@id.assertNatural assertNatural
@id.assertNatural+ assertNatural+
@id.assertChar assertChar
@id.assertProb assertProb
@id.assertUniform assertUniform

@doc.EnvironmentManipulation
"AO developers aren't limited to a single instance of the standard environment. Subprograms may be computed in their own complete environments, and objects may be shifted from one environment to another (using the hand, by default, for data shuffling). 
 
 Developers can:
 
 * create a fresh, empty environment on the stack (introE)
 * safely destroy an empty environment on the stack (elimE)
 * swap current environment with environment on stack (swapE)
 * apply function to top of stack in a fresh environment (top)
 
 When swapping environments, the current hand and powerblock will follow the user. Moving objects between environments involves use of the hand. A initial stack name for an environment is simply the empty string (which is equivalent to number 3). 
~

@doc.introE "adds empty environment object to stack"
@doc.elimE "deletes empty environment object ('drop' also works, but less safe)"
@doc.swapE "switch current environment with env on stack; keep hand and power"
@doc.top "apply block of type [x -- y] in a fresh environment."
@introE "" %r %vrvrwvrr %vrwlc %l
@elimE  %r %vrwlc %llcwlclc %l drop
@swapE %zrzwlz %vrwlc %zrwzl

@id.introElimE introE elimE
@id.swapE swapE swapE


@doc.TODO
"Much to do about AO
  * functions on lists, association lists, records
  *   binary to base64, binary to text, text to binary
  * contraint models for staged dependency/policy/typeclass injection 
  * project euler?
  * optimizers and compilers for ABC, AMBC, and AO
  * simplified app type for quick integration with Haskell? (use plugins?)
  * 2D-3D scene-graphs based on enneatrees and zippers
  * secure pseduo-random number generators; probabilistic programs
  * math libs - linear algebra, symbolic maths
  * knowledge database or encyclopaedia?
  *   unicode
  *   world data? (countries, flags, populations, maps)
 
 AO's design philosophy is actually similar to Wolfram's - that code should have easy access to vast quantities of useful, maintainable data. AO provides this access in the form of words in a very large dictionary.
~

@doc.Loops
"Loops in AO are modeled as words that repeatedly copy and apply a block until some halting condition is observed. Example loop words:
 
 * each - apply block with each element in list
 * repeat - inline block a given number of times
 * while - process while condition is observed
 
 These words are ultimately derived from fixpoint combinators, which are notoriously difficult to grok. Fortunately, it is not difficult to learn and use a loop word, nor to build new loop words above existing ones. Any loop variables, such as the block being applied, are hidden from the loop body (cf. `.dip`).
 
 *Note:* Loops in AO are required to terminate. Static analysis may raise an error if a loop provably does not terminate, or a warning if a loop cannot be proven to terminate. Long running behaviors in AO are not modeled by explicit loops. Instead, long-running behavior should be represented using workflows, incremental processes (µP.[a→(P*b)]), or reactive models. Each incremental step should be guaranteed to terminate. This property is very useful for control, abstraction, composition, and extension of processes.
~

@doc..until "[a→b]*((a+b)*e)→(b*e)"
@doc..map.list  "[(a*e)→(b*e')]*(a`L*e)→(b`L)*e'"
@doc..each.list "[(a*e)→b']*(a`L*e)→e'"

@doc.while1 "b [b -- (a + b)] -- a"
@doc.until1 "a [a -- (a + b)] -- b"
@doc.while  "(a + b) [b -- (a + b)] -- a"
@doc.until  "(a + b) [a -- (a + b)] -- b"
@doc.repeat "[] n --; inline block n times (for now, repeat 3 times)"
@doc.enum   "[i --] n m --; repeat with index in range [n,m)"
@doc.each   "a`L [a --] --; apply block to each element in list, left to right"
@doc.map    "a`L [a -- b] -- b`L; process each element in list, left to right"

@while1 swap inR swap while
@until1 swap inL swap until
@while swap not swap [not] compose until
@repeat drop take paste inline paste inline put inline
@until


@doc.Lists
"Lists in AO consist of a sequence of pairs ending in a number. For example, a list of four values might have structure:
 
     (a * (b * (c * (d * N(x))))
 
 In type signatures, this structure might be abbreviated as a`L, for a list of a. Lists are processed by asking of each element 'are you a pair?'. If so, the first item is an element in the list, and the second is the rest of the list. 
 
 The terminating number is not part of the list, but a convention of AO is to make use of small numbers to weakly indicate different types, e.g. to support rendering and optimization. A few common numbers:
 
     0: generic list terminator
     3: text (list of integers between 0 and 0x10ffff)
     8: binary (list of integers between 0 and 255)
 
 Relevantly, ending with different number does impact comparison functions, and developers may freely assert on list terminals to resist accidents, but it is generally a bad idea to observe a terminal to decide type (though it might be a useful heuristic for rendering values in external debuggers or REPL loops).
 
 Lists can be used for simple maps and fold operations.
 
 *Aside:* Lists are simplistic, in the sense that they are often overly simple. AO's standard dictionaries should include other data structures more suitable for efficient ad-hoc manipulations. These will include finger-trees, ropes built on finger-trees, and zippers. 
~


@doc.Zippers
"The zipper data structure was described by Gérard Huet in 1997. It enables navigation and modification of tree-structured data in a purely functional context. At any time, the original tree structure can be recovered with the modifications. For Awelon project, zippers are widely useful for modeling navigation through scene graphs or documents, and document-like structures. They may also be used for raycasting and rendering.
 
 To support user intuitions, zippers should be specialized for common data structures. However, AO does provide a few standard primitives for zippers on AO's product data type.
~

@doc.HigherOrderZippers
"Zippers are a first derivative on a data structure. However, higher derivatives are also very useful. For example, first derivative can focus on a single character in text, but second derivative models an expandable selection of text. In a scene graph, such could model a mobile bounding volume. 
 
 I don't grasp third derivatives yet, but my intuition is that it can help structurally abstract sweeps or convolutions, e.g. the process of casting a ray through a scene-graph.
~ 

@OLD-AO-ZIPPERS

"
 % 
 % In Awelon, zipper operations apply to top object on current stack. 
 %
 %    zwrap - prepare zipper; stack object is initial target
 %    zf - if target was (x*y), x is now target; undo with zuf
 %    zs - if target was (x*y), y is now target; undo with zus
 %    zu - undoes last zipper navigation (selects zuf or zus)
 %    zunwrap - fully exit and unwrap zipper, even if deep
 %    zunwrap_ - just unwrap zipper
 %
 % Knowing the representation of the zipper structure isn't essential,
 % but it might be interesting to some people. 
 %
 %    zwrap :: x <~> x*(1*1) :: zunwrap_ (on stack)
 %    zf    :: (x*y)*(l*r) <~> x*(1*(y*(l*r))) :: zuf
 %    zs    :: (x*y)*(l*r) <~> y*((x*l)*r)     :: zus
 %
 % The 'zu' and 'zunwrap' operations must perform introspection. 
 %
 % To manipulate the zipper target, developers will usually use an
 % operation such as:
 %   
 %    zswap - switch target of zipper (2nd) with object on stack (1st)
 %    zpop  - move target to top of stack (unit placeholder)
 %    zpush - undo zpop
 %
 zwrap = intro1 intro1 assocl rot2 pzip assocl  
 zunwrap_ = assocr pzip rot2 assocr elim1 elim1  
 zf = assocr xf intro1 assocl roll2 assocl 
 zuf = assocr roll2 assocr elim1 cf assocl
 zs = assocr xf roll3 cs roll2 assocl
 zus = assocr roll2 xf roll3 cs assocl
 zswap = cf assocr roll2 assocl xf
 zpop = intro1S zswap
 zpush = zswap elim1S
 % TODO: zu, zu*
 zu = % look at wrapper to decide step back
 zu* = % iterative zu
 zunwrap = zu* zunwrap_
~

@doc.rgb "usage: `1/3 5/7 4/5 rgb` in red-green-blue order, with range 0 to 1 inclusive. Also see @doc.rgb/24 for the typical 8-bit color."
@doc.rgb/24 "usage: `0x5c 0x35 0x66 rgb/24` in red-green-blue order"
@rgb 1 rgba
@rgba ps ps ps "rgba" pf
@rgb/24 
    take2 fracOfOctet
    put   fracOfOctet
    put   fracOfOctet
    rgb
@fracOfOctet 1/255 .mul
@doc.fracOfOctet "divide by 255, such that numbers of range 0..255 result in a range 0 to 1 (inclusive)"

@doc.color 
"Following Elm's example, I'm using the [Tango](http://tango.freedesktop.org/Tango_Icon_Theme_Guidelines) pallette, with simpler names: red, orange, yellow, green, blue, purple, brown, gray, and charcoal - each with light and dark variations.
~

@color.lightRed      0xef 0x29 0x29 rgb/24
@color.red           0xcc 0x00 0x00 rgb/24
@color.darkRed       0xa4 0x00 0x00 rgb/24 
@color.lightOrange   0xfc 0xaf 0x3e rgb/24
@color.orange        0xf5 0x79 0x00 rgb/24
@color.darkOrange    0xce 0x5c 0x00 rgb/24
@color.lightYellow   0xfc 0xe9 0x4f rgb/24
@color.yellow        0xed 0xd4 0x00 rgb/24
@color.darkYellow    0xc4 0xa0 0x00 rgb/24
@color.lightGreen    0x8a 0xe2 0x34 rgb/24
@color.green         0x73 0xd2 0x16 rgb/24
@color.darkGreen     0x4e 0x9a 0x06 rgb/24
@color.lightBlue     0x72 0x9f 0xcf rgb/24
@color.blue          0x34 0x65 0xa4 rgb/24
@color.darkBlue      0x20 0x4a 0x87 rgb/24
@color.lightPurple   0xad 0x7f 0xa8 rgb/24
@color.purple        0x75 0x50 0x7b rgb/24
@color.darkPurple    0x5c 0x35 0x66 rgb/24
@color.lightBrown    0xe9 0xb9 0x6e rgb/24
@color.brown         0xc1 0x7d 0x11 rgb/24
@color.darkBrown     0x8f 0x59 0x02 rgb/24
@color.white         0xff 0xff 0xff rgb/24
@color.lightGrey     0xee 0xee 0xec rgb/24
@color.grey          0xd3 0xd7 0xcf rgb/24
@color.darkGrey      0xba 0xbd 0xb6 rgb/24
@color.lightCharcoal 0x88 0x8a 0x85 rgb/24
@color.charcoal      0x55 0x57 0x53 rgb/24
@color.darkCharcoal  0x23 0x34 0x36 rgb/24
@color.black         0x00 0x00 0x00 rgb/24

@color.gray      color.grey
@color.lightGray color.lightGrey
@color.darkGray  color.darkGrey


@doc.CompositionIsFirstPrinciple
"Every compositional model consists of a trinity: components, operators, and properties. Compositional operators are algebraically or categorically closed; they combine two components into a third component. Compositional properties are invariant or inductive over the operators. The set of components may be domain specific (such as diagrams, documents, sounds, and scene-graphs) or more general purpose (such as functions, arrows, matrices, grammars). 
 
 Composition is useful as a formal foundation for scalability and modularity. Compositional properties enable developers to reason about components without knowledge of the implementation details. Composition operators are also convenient due to their uniformity, i.e. we aren't forced to develop or learn a new language or interface for every object.
 
 Many models in common practice - including state machines, records, process loops, nominative types, conventional conditional expressions, even parametric abstraction - are not compositional. 
 
 Compositional alternatives are available. Grammars can operate as state machines (via parsing). Datalog or relational algebras generalize records. Processes can be compositional if we instead model them as partial and incremental (i.e. small-step processes; `µP.a→(P*b)`). Nominative types can be replaced with structural types. If/then/else and ad-hoc pattern-case conditional expressions can be replaced with a structural sum types. Ad-hoc parametric abstraction can often be replaced with staging and a reader monad.
 
 Awelon project strongly favors compositional models and designs. This should be reflected in AO's dictionaries and ontologies. I ask that all AO developers embrace composition as first design principle, pervasively, with priority above other features.
 
 Effective use of composition often requires domain-specific tradeoffs between the three aspects. For example, by limiting what we talk about (just diagrams) we can achieve more specialized properties (e.g. bounding areas, efficient occlusion) and more operators (add, scale, rotate, translate, etc.). It is possible to switch between compositional models primarily by layering them, such that the output of one compositional model becomes another compositional model. At a lower layer, a generic compositional model enables integration of domain-specific models.
 
 AO is designed to serve as that generic compositional layer. AO's words are software components. AO's compositional properties - especially causal commutativity, spatial idempotence, and capability security - are very useful in this role. AO is also designed to mitigate common weaknesses of deeply layered abstractions by aggressive use of partial evaluation, dependent type analysis, and program search.
~


