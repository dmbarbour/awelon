 plumbing hands stdenv 
 blocks conditionals 
 loops streams lists sequences
 math stats
 adverbs

@doc.import.std "viable starting point for AO dictionaries"

@doc.NamingConventions
"AO makes heavy use of naming conventions. Common prefixes suggest automatic processing or type information. For example, 'doc.' indicates documentation for a word, and 'test.' indicates automatic testing in a mockup environment, and 'id.' indicates that a given expression should be equivalent to identity for all the types it accepts. Conversely, suffixes connote context. A suffix might identify a specific framework, project, spreadsheet, or programmer.
 
 Multi-part words unfortunately make plain-text AO verbose and difficult to read. 
 
 The intention is to mitigate this issue in the editor. A set of rules (configurable per user, view, or project) shall translate common prefixes and suffixes into rendering with colors and styles and possible icons. Also, fuzzy autocomplete mechanisms can eliminate need to fully write out large words, and may be weakly type sensitive.
~

@doc.prefix.doc
"AO does not have 'comments' in the usual sense. Instead, it has documentation words. A word that starts with 'doc.' should introduce documentation in a common format. If a word is too complicated to effectively document this way, consider factoring its definition into smaller pieces!
~

@doc.prefix.test
"Automated testing is an effective means to maintain software quality, avoid regressions, and achieve confidence in code. Test driven design can keep designs well grounded and incremental.  
 
 In AO, automatic testing is expressed simply by using the prefix 'test.' in the definitions of words. Test words can be systematically executed in a standard environment with a confined powerblock. A test can fail due to type errors, assertion failures, taking too much time or space, or emitting an error message effectfully through the powerblock.
 
 Testing has limits. You cannot prove, through testing, that bugs are absent. AO developers are encouraged also to leverage symbolic analysis, which is also expressed in a relatively dynamic manner in AO (e.g. use of the 'eqv.' or 'id.' prefixes).
~
@doc.warn.test "warnMsg --; emit message"
@doc.error.test "errMsg --; emit message and fail"
@warn.test "warn" p cmd.test
@error.test "error" p cmd.test
@cmd.test %zwl .apply x %rwz

@doc.prefix.eqv 
"There are many cases where two different expressions should be equivalent. Explicitly asserting so is useful! Not only may equivalencies serve as documentation, but they also can support automatic tests or provide hints for optimizers and refactoring tools. So prefix 'eqv' provides a generic way to suggest that two expressions should be equivalent.
 
 The type of an 'eqv.foo' word should be:  ( -- [a→b] [a→b]). 
 
 That is, developers should simply add two blocks to the current stack, which should have equivalent behavior modulo typeful identity. Use of the 'eqv' prefix enables external tools to systematically discover, document, and validate these assertions. 
 
 A more specialized equivalency is also available with prefix 'id'. Eventually, there may be specialized prefixes for for idempotence (`f f = f`) and commutativity (`f g = g f`), and similar properties (plus associativity) for binary functions. However, for now, these may be expressed by eqv.
~

@doc.prefix.id 
"There are many cases where a sequence of operations should have operations should have no total, observable effect. For example, `swap swap` is the same as taking no action. These sequences are essentially instances of the 'identity' behavior, modulo slight differences on the required input type - i.e. they are 'typeful' identities. 
 
 The 'id' prefix is a specialized equivalence that also implies idempotence and commutativity. Look into the 'idempotent', 'commutative', and 'eqv' prefixes.
 
 Use of prefix words to declare properties such as identity, idempotence, associativity, and commutativity is useful for documentation, automatic validation, and development of optimizers. Developers are encouraged to do so.
~ 

@doc.TODO
"Much to do about AO
  * automatic testing (run all 'test' words)
  * functions for lists, streams
  * functions for association lists, maps, records
  * functions for sequences (finger-trees/ropes)
  * functions for parser combinators
  * AO bootstrap; optimizers and compilers for ABC, AO
  *   eventually do typechecking
  *   eventually get to AMBC
  * develop a colors model? 
  *   named palette plus RGB? meh. 
  *   a DSL for mixing, lightening, and darkening colors?
  *   maybe a richer 'materials' model (cf. POV-ray) 
  *     with shine, roughness, transparency, etc.
  *     procedural texture generation, perlin noise
  *     automatic generation from images
  * functions for text, utf-8, binary, base64
  * functions for kd-trees, geometries, scene-graphs
  * contraint models for staged dependency/policy/typeclass injection 
  * project euler? rosetta code? a simple tetris/breakout game?
  * simplified app type for quick integration with Haskell? (use plugins?)
  * 2D-3D scene-graphs based on enneatrees and zippers
  * secure pseduo-random number generators; probabilistic programs
  * math libs - linear algebra, symbolic maths
  * knowledge database or encyclopaedia?
  *   unicode
  *   world data? (countries, flags, populations, maps)
 
 AO's design philosophy is actually similar to Wolfram's - that code should have easy access to vast quantities of useful, maintainable data. AO provides this access in the form of words in a very large dictionary.
~


@doc.Zippers
"The zipper data structure was described by Gérard Huet in 1997. It enables navigation and modification of tree-structured data in a purely functional context. At any time, the original tree structure can be recovered with the modifications. For Awelon project, zippers are widely useful for modeling navigation through scene graphs or documents, and document-like structures. They may also be used for raycasting and rendering.
 
 To support user intuitions, zippers should be specialized for common data structures. However, AO does provide a few standard primitives for zippers on AO's product data type.
~

@doc.HigherOrderZippers
"Zippers are a first derivative on a data structure. However, higher derivatives are also very useful. For example, first derivative can focus on a single character in text, but second derivative models an expandable selection of text. In a scene graph, such could model a mobile bounding volume. 
 
 I don't grasp third derivatives yet, but my intuition is that it can help structurally abstract sweeps or convolutions, e.g. the process of casting a ray through a scene-graph.
~ 

@OLD-AO-ZIPPERS

"
 % 
 % In Awelon, zipper operations apply to top object on current stack. 
 %
 %    zwrap - prepare zipper; stack object is initial target
 %    zf - if target was (x*y), x is now target; undo with zuf
 %    zs - if target was (x*y), y is now target; undo with zus
 %    zu - undoes last zipper navigation (selects zuf or zus)
 %    zunwrap - fully exit and unwrap zipper, even if deep
 %    zunwrap_ - just unwrap zipper
 %
 % Knowing the representation of the zipper structure isn't essential,
 % but it might be interesting to some people. 
 %
 %    zwrap :: x <~> x*(1*1) :: zunwrap_ (on stack)
 %    zf    :: (x*y)*(l*r) <~> x*(1*(y*(l*r))) :: zuf
 %    zs    :: (x*y)*(l*r) <~> y*((x*l)*r)     :: zus
 %
 % The 'zu' and 'zunwrap' operations must perform introspection. 
 %
 % To manipulate the zipper target, developers will usually use an
 % operation such as:
 %   
 %    zswap - switch target of zipper (2nd) with object on stack (1st)
 %    zpop  - move target to top of stack (unit placeholder)
 %    zpush - undo zpop
 %
 zwrap = intro1 intro1 assocl rot2 pzip assocl  
 zunwrap_ = assocr pzip rot2 assocr elim1 elim1  
 zf = assocr x intro1 assocl roll2 assocl 
 zuf = assocr roll2 assocr elim1 p assocl
 zs = assocr x roll3 pw roll2 assocl
 zus = assocr roll2 x roll3 pw assocl
 zswap = p assocr roll2 assocl x
 zpop = intro1S zswap
 zpush = zswap elim1S
 % TODO: zu, zu*
 zu = % look at wrapper to decide step back
 zu* = % iterative zu
 zunwrap = zu* zunwrap_
~

@doc.ValueSealing
"AO allows seal/unseal actions to be hard-coded using inline ABC. These are represented as:
 
     %{:foo}       seal value with sealer 'foo'
     %{.foo}       unseal value from sealer 'foo'
 
 The token 'foo' may be replaced by any arbitrary text. A sealed value cannot be observed or manipulated without first unsealing it with the same token. Of course, hard-coded tokens are not secure. (Secure value sealing involves construction of unique sealer/unsealer pairs.) To avoid even the illusion of security, and to simplify debugging, hard-coded sealers should favor simple, self-documenting tokens.
 
 Despite being insecure, hard-coded sealers are useful. They simplify reasoning and search for which code can access a value. They help document that some intermediate structures from an API are intended to be private or opaque. Introducing a new token for a test can help developers enforce parametricity. Value sealing can guard against accidental bindings, similar to 'newtype' in some other languages.
~

@doc.prefix.seal "seal the first item on the stack"
@doc.prefix.unseal "unseal the first item on the stack"

@doc.seal "guard a value against accidental observation"
@doc.unseal "unseal a value guarded by 'seal'"
@seal [%{:0}] .apply
@unseal [%{.0}] .apply

@doc.CompositionIsFirstPrinciple
"Every compositional model consists of a trinity: components, operators, and properties. Compositional operators are algebraically or categorically closed; they combine two components into a third component. Compositional properties are invariant or inductive over the operators. The set of components may be domain specific (such as diagrams, documents, sounds, and scene-graphs) or more general purpose (such as functions, arrows, matrices, grammars). 
 
 Composition is useful as a formal foundation for scalability and modularity. Compositional properties enable developers to reason about components without knowledge of the implementation details. Composition operators are also convenient due to their uniformity, i.e. we aren't forced to develop or learn a new language or interface for every object.
 
 Many models in common practice - including state machines, records, process loops, nominative types, conventional conditional expressions, even parametric abstraction - are not compositional. 
 
 Compositional alternatives are available. Grammars can operate as state machines (via parsing). Datalog or relational algebras generalize records. Processes can be compositional if we instead model them as partial and incremental (i.e. small-step processes; `µP.a→(P*b)`). Nominative types can be replaced with structural types. If/then/else and ad-hoc pattern-case conditional expressions can be replaced with a structural sum types. Ad-hoc parametric abstraction can often be replaced with staging and a reader monad.
 
 Awelon project strongly favors compositional models and designs. This should be reflected in AO's dictionaries and ontologies. I ask that all AO developers embrace composition as first design principle, pervasively, with priority above other features.
 
 Effective use of composition often requires domain-specific tradeoffs between the three aspects. For example, by limiting what we talk about (just diagrams) we can achieve more specialized properties (e.g. bounding areas, efficient occlusion) and more operators (add, scale, rotate, translate, etc.). It is possible to switch between compositional models primarily by layering them, such that the output of one compositional model becomes another compositional model. At a lower layer, a generic compositional model enables integration of domain-specific models.
 
 AO is designed to serve as that generic compositional layer. AO's words are software components. AO's compositional properties - especially causal commutativity, spatial idempotence, and capability security - are very useful in this role. AO is also designed to mitigate common weaknesses of deeply layered abstractions by aggressive use of partial evaluation, dependent type analysis, and program search.
~


