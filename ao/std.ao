
@doc.import.std "one big starting point for AO systems"

@doc.NamingConventions
"The naming convention for AO places context to the right and type to the left. Example types include 'doc', 'test', and 'ioapp'. Type, in this sense, determines how the word is processed by the larger programming environment - e.g. 'test' results in automatic testing. Context provides extra information about where the word is needed or used. It may identify a project, user, DSL, framework, and so on. 
 
 A good programming environment should replace structured suffixes or popular prefixes with style and color upon rendering. This feature improves parsimony and readability. It may also improve ability to recognize usage patterns in a zoomable view of a word's expansion. This replaces syntax highlighting, which isn't very relevant in AO.
 
 There is a distinct naming convention for spreadsheet elements, of form `b3$foo` to indicate cell b3 in a spreadsheet called foo. The names for cells imply location in a spreadsheet.
~

@doc.StandardEnvironment
"The required environment for AO is a pair: (s*e). Literals, such as blocks, numbers, and text, are of type `(s*e) → ((L*s)*e)`. The idea is that 's' represents the current stack, while 'e' is kept stable and represents the remainder of the environment.
 
 The standard environment elaborates 'e' with a structure designed for flexible workflows and dataflows, concurrency, and extensibility. The type is roughly:
 
     (s * (h * (p * ((sn * rns) * ex))))
 
 Where:
   s: the current stack, where most operations apply
   h: the hand, temporary store and semantic clipboard
   p: a powerblock, to observe or influence real world
   sn: name of current stack, used when switching stacks
   rns: record of (name*stack) pairs for workspaces and registers
   ex: unused, available for experimental extensions
 
 Remember, this isn't built into AO. It really is just a plain old value that happens to model a multi-stack programming environment, and AO could just as easily work in another environment (though it may require developing new data shuffling metaphors and vocabulary). Multiple stacks are very convenient when modeling multiple concurrent tasks and workflows. 
 
 Many basic stack manipulators are borrowed from Factor and FORTH. Also, operations on the stack are often documented using a simple notation for stack effects. "x y z -- y x z" means the top item on the stack (z) remains in place, and the two below it are swapped.
 
 This particular computing environment is suitable for text-based programming environments. I have an alternative in mind for Awelon project, which involves navigation metaphors (spatial/kd-trees by zipper) while wielding an inventory of recomposable tools including programmable glasses (lenses, HUD).
~

@doc.id " -- "
@doc.dup "(Copyable x) ⇒ x -- x x"
@doc.dupd "(Copyable x) ⇒ x y -- x x y"
@doc.over "(Copyable x) ⇒ x y -- x y x"
@doc.tuck "(Copyable y) ⇒ x y -- y x y"
@doc.pick "(Copyable x) ⇒ x y z -- x y z x"
@doc.drop "(Droppable x) ⇒ x -- "
@doc.nip  "(Droppable x) ⇒ x y -- y"
@doc.nip2 "(Droppable x,y) ⇒ x y z -- z"
@doc.swap "y x -- x y"
@doc.swapd "x y z -- y x z"
@doc.rot "x y z -- y z x"
@doc.unrot "y z x -- x y z"
@doc.roll "w x y z -- x y z w"
@doc.unroll "x y z w -- w x y z"
@doc.spin "x y z -- z y x"
@doc.assocl "y x -- (x*y)"
@doc.assocr "(x*y) -- y x"
@doc.intro1 " -- Unit"
@doc.elim1 "Unit -- "

@id 
@dup %r^wzlwl
@dupd swap dup rot
@over dupd swap
@tuck swap over
@pick %rw over %wl swap
@drop %r%
@nip swap drop
@nip2 unrot drop2
@swap  %rwr      %wzw      %lwl
@swapd %rw swap %wl
@rot swapd swap
@unrot swap swapd
@spin swap swapd swap
@roll %rw roll3 %wl swap
@unroll swap %rw unrot %wl
@assocl %rwrzwll
@assocr %rrwzlwl
@intro1 %vvrwlcl
@elim1 %rvrwlcc

@doc.roll{N} "synonyms for swap, rot, roll"
@roll2 swap
@roll3 rot
@roll4 roll

@doc.pswap "(x*y) -- (y*x)"
@doc.xf "(x*y) -- y x"
@doc.xs "(x*y) -- x y"
@doc.pf "y x -- (x*y)"
@doc.ps "y x -- (y*x)"
@pswap %rrwll
@xf assocr
@xs pswap assocr
@pf assocl
@ps assocl pswap

@doc.prefix.id "typeful identity functions for testing optimizers"
@id.swap swap swap
@id.swapd swapd swapd
@id.rot rot rot rot
@id.unrot unrot unrot unrot
@id.roll roll roll roll roll
@id.unroll unroll unroll unroll unroll
@id.spin spin spin
@id.introElim intro1 elim1
@id.elimIntro elim1 intro1
@id.assoclr assocl assocr
@id.assocrl assocr assocl
@id.pswap pswap pswap
@id.dupdrop dup drop
@id.dupSwapDrop dup swap drop
@id.dupSwapdDropSwap dup swapd drop swap
@id.dup2drop2 dup2 drop2
@id.quoteUnquote quote unquote
@id.unquoteQuote unquote quote
@id.textDrop "text" drop

@relevant %rkl
@affine   %rfl
@linear   relevant affine
@doc.relevant "mark block on stack as relevant (not Droppable)"
@doc.affine "mark block on stack as affine (not Copyable)"
@doc.linear "mark block on stack as linear (neither Copyable nor Droppable)"

@reifyStack intro1 %rwl
@restoreStack %rwl elim1
@doc.reifyStack "(s*e)→((s*Unit)*e) : stack becomes object on fresh stack"
@doc.restoreStack "((s*Unit)*e)→(s*e) : single object on stack becomes stack"

@doc.drop2 "(Droppable x,y) ⇒ x y -- "
@doc.drop3 "(Droppable x,y,z) ⇒ x y z -- "
@doc.drop4 "(Droppable w,x,y,z) ⇒ w x y z -- "
@drop2 drop drop
@drop3 drop drop drop
@drop4 drop drop drop drop

@doc.dup2 "(Copyable x,y) ⇒ x y -- x y x y"
@doc.dup3 "(Copyable x,y,z) ⇒ x y z -- x y z x y z"
@doc.dup4 "(Copyable w,x,y,z) ⇒ w x y z -- w x y z w x y z"
@dup2 assocl dup %rw 
      assocr %wl
      assocr
@dup3 assocl assocl dup %rw 
      assocr assocr %wl 
      assocr assocr
@dup4 assocl assocl assocl dup %rw 
      assocr assocr assocr %wl 
      assocr assocr assocr

@doc.Quotable
"Most values in AO are quotable, except in contexts where an AO program models a distributed behavior. Distributed values are not quotable; all values entering a quote must have the same location.
 
 A quotation is simply a block that reproduces a value. Quotations can be utilized together with composition for partial application.
 
 If a block with affine or relevant properties is quoted, the quote will inherit these properties. 
~
@doc.quote "(Quotable x) ⇒ x -- [1→x]"
@doc.unquote "[1→x] -- x"
@quote %r'l
@unquote intro1 swap .apply

@doc.Hands
"In AO, the hand is modeled as a second stack. It can be used as a temporary storage for deep operations on the current stack, and also serves as a semantic clipboard for ad-hoc data shuffling.
 
     (currentStack * (hand * ... ))
 
 Developers can:
 
 * take top item from stack into hand
 * put top item from hand onto stack
 * juggle (rotate) a few items
 * discard a value from the hand
 * copy an item from the stack into hand
 * paste an item in the hand onto the stack
 
 In addition, hands are stable when developers use navigational metaphors, i.e. to operate in different workspaces. 
 
 AO encourages a "clean hands" policy: most words should have a neutral effect on the hand, and not affect or observe the values already held by it. The exception is words like `take` and `put` where the purpose is to manipulate the hand. The `apply` word enforces this policy by hiding the current hand when applying a block.
~

@take %rzlw
@put  %wrzl
@discard put drop
@copy dup take
@paste put copy

@take2 take take
@take3 take take take
@take4 take take take take
@put2  put  put
@put3  put  put  put
@put4  put  put  put  put
@juggle2 %w roll2 %w
@juggle3 %w roll3 %w
@juggle4 %w roll4 %w

@doc.take "move value at top of stack to top of hand"
@doc.put "move value at top of hand to top of stack"
@doc.discard "drop and destroy value in hand"
@doc.copy "copy object from top of stack into hand (copy/paste metaphor)"
@doc.paste "paste object from hand onto top of stack (copy/paste metaphor)"

@reifyHand %w reifyStack %w
@restoreHand %w restoreStack %w
@doc.reifyHand "hand becomes single object in fresh hand"
@doc.restoreHand "single object in hand becomes hand"

@id.takePut take put
@id.putTake put take
@id.juggle3 juggle3 juggle3 juggle3
@id.takeJugglePutSwap take2 juggle2 put2 swap
@id.takeSwapPutSwapd take swap put swapd
@id.copyDiscard copy discard
@id.pasteDiscardTake paste discard take
@id.reifyRestoreHand reifyHand restoreHand
@id.take3put3 take3 put3

@doc.MakingWithBlocks
"A block in AO consists of code wrapped in square brackets, of form: `[put swap take]` or `[2 add]`. The meaning of a block is a first-class function that may be applied later. Blocks are essential in AO for:
 
 * representing loop behaviors by copying and applying blocks
 * modeling conditional behavior, apply block on just one branch
 * direct models of higher order programs and behavioral abstraction
 * transporting access and authority to resources and side-effects
 
 Best practices for use of blocks have not fully been established. Awelon project favors compositional abstractions to such an extent that use of ad-hoc parametric abstraction is discouraged. (See @doc.FirstPrincipleIsComposition.) My expectation is that blocks will be de-emphasized for behavioral abstraction in favor of indirect mechanisms - e.g. structured DSLs, symbolic expressions, free monads, staged programming. In this sense, AO discourages conventional 'functional programming' in favor of a more 'language oriented programming'.
 
 Nonetheless, blocks remain essential for loops, effects, and conditions. Also, blocks make an effective compilation target, an alternative to interpretation, and they can help an embedded DSL model corner cases.
 
 Blocks can be composed.  Composition working together with quotation can also model such features as partial, concurrent, and conditional application.
 
     o       :: [x→y] [y→z] -- [x→z]      (sequential)
     .curry  :: x [(x*y)→z] -- [y→z]      (partial)
     .first  :: [x→x'] -- [(x*e)→(x'*e)]  (concurrent)
     .left   :: [x→x'] -- [(x+e)→(x'+e)]  (conditional)
 
 Some readers might be familiar with the notions of 'first' and 'left' from John Hughes' arrow model, which was an important foundation for AO and RDP.
 
 Above, I described primitive forms. The 'curry', 'first', and 'left' words must more generally be sensitive to the programming environment. (Unfortunately, I lack a good notation for effects on a multi-stack environment. I plan to rely on automatic visualization features to explain such things.)
 
 In addition, blocks may be constructed by quotation of a value:
 
     quote   :: (Quotable x) ⇒ x -- [1→x]
     unquote :: [1→x] -- x
 
 After construction, blocks can be applied in various ways. Developers will mostly use 'apply', which applies a block to the current environment except for the hand. Items in the current hand are hidden. But there are other operations that include (potentially) useful patterns for data hiding and application.
 
     .apply :: x [x→y] -- y (apply block to just top object on stack)
     .dip   :: (apply block to everything except top object on stack)
     apply  :: (apply block on stack to full environment, hiding current hand)
     inline :: (apply block on stack as if written inline, i.e. hand is visible)
     dip    :: (hides hand and top items on stack)
     keep   :: copies top item on stack before apply, then replaces them.
     top    :: apply block to top of stack in fresh environment... must have single value result
 
 The set of application words will undoubtedly evolve with experience.
~

@o pf %rrol
@.apply pf %rr$l
@.dip %rwrzwvrwr %$ %wlcl
@apply reifyHand put .dip take restoreHand
@inline %rvr$c
@dip  take  apply put
@dip2 take2 apply put2
@dip3 take3 apply put3
@dip4 take4 apply put4
@keep  take copy juggle2 put apply put
@keep2 take pf copy xf juggle2 put apply put xf
@keep3 take pf pf copy xf xf juggle2 put apply put xf xf
@keep4 take pf pf pf copy xf xf xf juggle2 put apply put xf xf xf

@doc.PrimitiveMath
"The intention is for AO to operate easily with units and matrices. The prefix '.' is used for primitive math operations on naked, scalar numbers. These operators include `.add`, `.multiply`, `.negate`, `.invert`, `.divMod`, `.subtract`, and `.divide`. The same operations without the prefix will eventually refer to versions that contain dispatch logic for common value types, requiring very aggressive optimization.
 
 More generally, AO will be leaning towards symbolic math libraries, i.e. such that we build expressions in a math DSL rather than directly compute results. This enables much richer analysis and optimization to be performed within the language, at expense of making it difficult to directly optimize the language (except by partial evaluation).
~

@.multiply pf %rr*l
@.add      pf %rr+l
@.negate   %r-l
@.invert   %r/l
@.divMod   pf %rrQll xs
@.subtract .negate .add
@.divide   .invert .multiply

@doc..multiply "N(b) N(a) -- N(a*b)"
@doc..add "N(b) N(a) -- N(a+b)"
@doc..negate "N(a) -- N(-a)"
@doc..invert "N(a) -- N(1/a); a must be non-zero"
@doc..divMod "N(a) N(b) -- N(r) N(q) where a=q*b+r and r in (b,0] or [0,b)"
@doc..subtract "N(a) N(b) -- N(a-b)"
@doc..divide "N(a) N(b) -- N(a/b)"

@id.mul1 1 .multiply
@id.div1 1 .divide
@id.add0 0 .add
@id.sub0 0 .subtract

@doc.ConditionalBehavior

@doc.EnvironmentManipulation
"AO developers aren't limited to a single instance of the standard environment. Subprograms may be computed in their own complete environments, and objects may be shifted from one environment to another (using the hand, by default, for data shuffling). 
 
 Developers can:
 
 * create a fresh, empty environment on the stack (introE)
 * safely destroy an empty environment on the stack (elimE)
 * swap current environment with environment on stack (swapE)
 * apply function to top of stack in a fresh environment (top)
 
 When swapping environments, the current hand and powerblock will follow the user. Moving objects between environments involves use of the hand. A initial stack name for an environment is simply the empty string (which is equivalent to number 3). 
~

@doc.introE "adds empty environment object to stack"
@doc.elimE "deletes empty environment object ('drop' also works, but less safe)"
@doc.swapE "switch current environment with env on stack; keep hand and power"
@doc.top "apply block of type [x -- y] in a fresh environment."
@introE "" %r %vrvrwvrr %vrwlc %l
@elimE  %r %vrwlc %llcwlclc %l drop
@swapE %zrzwlz %vrwlc %zrwzl
@top take2 introE swapE put2 rot take apply put swap take swapE elimE put

@id.introElimE introE elimE
@id.swapE swapE swapE

@doc.TODO
"Much to do about AO
  * functions on lists, association lists, records
  * optimizers and compilers for ABC, AMBC, and AO
  * simplified app type for quick integration with Haskell? (use plugins?)
  * 2D-3D scene-graphs based on enneatrees and zippers
  * secure pseduo-random number generators; probabilistic programs
  * math libs - linear algebra, symbolic maths
  * knowledge databases as words (or sets thereof) in dictionary
  *   unicode
  *   countries, flags, populations, maps
  *   project Gutenberg novels
 
 AO's design philosophy is actually similar to Wolfram's - that code should have easy access to vast quantities of useful, maintainable data. AO provides this access in the form of words in a very large dictionary.
~

@JUNK

% Environment Manipulations
%
%  (todo) fix for new environment model... need to choose name for
%  initial stack? Maybe "main"?
%
%  wrapE - wrap a value in a fresh environment; wrapped value becomes
%    the only element in a fresh env's current stack. If `wrapE` is 
%    called without a specific target, it captures the current 
%    environment.
%  wrapS - capture current stack as a value, which is afterwards the
%    only value on the current stack. 
%  unwrapE/unwrapS - reverse these manipulations.
%
% The normal block applicators will wrap a new environment around the
% arguments before applying the block. This allows subprograms to use
% the multi-stack and hands concept, but prevents accidental coupling
% with the current environment. 
%
%wrapE = intro1 swap intro1 swap intro1 intro1 intro1 assocl swap
%unwrapE = swap assocr elim1 elim1 elim1 swap elim1 swap elim1
%wrapS = assocr intro1 rot3 pzip assocl rot2 assocl
%unwrapS = swap rot3 assocr rot2 elim1 rot3 rot3 swap


% Combinators: remove a block from top of the current stack, and 
%   apply it to all or part of the environment.
%
%   apply: target whole environment (as if block is coded inline)
%   appX: target top item on stack (without fresh environment)
% 
% Note that these do not wrap the input in a fresh environment, so
% only `appE` is directly usable.
%
apply = assocr intro1 swap assocr first swap elim1
appX = assocr rot2 assocr rot3 first assocl

@doc.Zippers
"The zipper data structure was described by Gérard Huet in 1997. It enables navigation and modification of tree-structured data in a purely functional context. At any time, the original tree structure can be recovered with the modifications. For Awelon project, zippers are widely useful for modeling navigation through scene graphs or documents, and document-like structures. They may also be used for raycasting and rendering.
 
 To support user intuitions, zippers should be specialized for common data structures. However, AO does provide a few standard primitives for zippers on AO's product data type.
~

@doc.HigherOrderZippers
"Zippers are a first derivative on a data structure. However, higher derivatives are also very useful. For example, first derivative can focus on a single character in text, but second derivative models an expandable selection of text. In a scene graph, such could model a mobile bounding volume. 
 
 I don't grasp third derivatives yet, but my intuition is that it can help structurally abstract sweeps or convolutions, e.g. the process of casting a ray through a scene-graph.
~ 

@JUNK

% 
% In Awelon, zipper operations apply to top object on current stack. 
%
%    zwrap - prepare zipper; stack object is initial target
%    zf - if target was (x*y), x is now target; undo with zuf
%    zs - if target was (x*y), y is now target; undo with zus
%    zu - undoes last zipper navigation (selects zuf or zus)
%    zunwrap - fully exit and unwrap zipper, even if deep
%    zunwrap_ - just unwrap zipper
%
% Knowing the representation of the zipper structure isn't essential,
% but it might be interesting to some people. 
%
%    zwrap :: x <~> x*(1*1) :: zunwrap_ (on stack)
%    zf    :: (x*y)*(l*r) <~> x*(1*(y*(l*r))) :: zuf
%    zs    :: (x*y)*(l*r) <~> y*((x*l)*r)     :: zus
%
% The 'zu' and 'zunwrap' operations must perform introspection. 
%
% To manipulate the zipper target, developers will usually use an
% operation such as:
%   
%    zswap - switch target of zipper (2nd) with object on stack (1st)
%    zpop  - move target to top of stack (unit placeholder)
%    zpush - undo zpop
%
zwrap = intro1 intro1 assocl rot2 pzip assocl  
zunwrap_ = assocr pzip rot2 assocr elim1 elim1  
zf = assocr xf intro1 assocl roll2 assocl 
zuf = assocr roll2 assocr elim1 cf assocl
zs = assocr xf roll3 cs roll2 assocl
zus = assocr roll2 xf roll3 cs assocl
zswap = cf assocr roll2 assocl xf
zpop = intro1S zswap
zpush = zswap elim1S
% TODO: zu, zu*
zu = % look at wrapper to decide step back
zu* = % iterative zu
zunwrap = zu* zunwrap_

@doc.rgb "usage: `1/3 5/7 4/5 rgb` in red-green-blue order"
@rgb 1 rgba
@rgba ps ps ps "rgba" pf
@rgb/8 
    take2 fracOfOctet
    put   fracOfOctet
    put   fracOfOctet
    rgba
@fracOfOctet 1/255 .multiply
@doc.fracOfOctet "divide by 255, such that numbers of range 0..255 result in a range 0 to 1 (inclusive)"

@doc.color "Following Elm's example, I'm using the [Tango](http://tango.freedesktop.org/Tango_Icon_Theme_Guidelines) pallette, with simpler names: red, orange, yellow, green, blue, purple, brown, gray, and charcoal - each with light and dark variations."

@color.lightRed      0xef 0x29 0x29 rgb/8
@color.red           0xcc 0x00 0x00 rgb/8
@color.darkRed       0xa4 0x00 0x00 rgb/8 
@color.lightOrange   0xfc 0xaf 0x3e rgb/8
@color.orange        0xf5 0x79 0x00 rgb/8
@color.darkOrange    0xce 0x5c 0x00 rgb/8
@color.lightYellow   0xfc 0xe9 0x4f rgb/8
@color.yellow        0xed 0xd4 0x00 rgb/8
@color.darkYellow    0xc4 0xa0 0x00 rgb/8
@color.lightGreen    0x8a 0xe2 0x34 rgb/8
@color.green         0x73 0xd2 0x16 rgb/8
@color.darkGreen     0x4e 0x9a 0x06 rgb/8
@color.lightBlue     0x72 0x9f 0xcf rgb/8
@color.blue          0x34 0x65 0xa4 rgb/8
@color.darkBlue      0x20 0x4a 0x87 rgb/8
@color.lightPurple   0xad 0x7f 0xa8 rgb/8
@color.purple        0x75 0x50 0x7b rgb/8
@color.darkPurple    0x5c 0x35 0x66 rgb/8
@color.lightBrown    0xe9 0xb9 0x6e rgb/8
@color.brown         0xc1 0x7d 0x11 rgb/8
@color.darkBrown     0x8f 0x59 0x02 rgb/8
@color.white         0xff 0xff 0xff rgb/8
@color.lightGrey     0xee 0xee 0xec rgb/8
@color.grey          0xd3 0xd7 0xcf rgb/8
@color.darkGrey      0xba 0xbd 0xb6 rgb/8
@color.lightCharcoal 0x88 0x8a 0x85 rgb/8
@color.charcoal      0x55 0x57 0x53 rgb/8
@color.darkCharcoal  0x23 0x34 0x36 rgb/8
@color.black         0x00 0x00 0x00 rgb/8

@color.gray      color.grey
@color.lightGray color.lightGrey
@color.darkGray  color.darkGrey

@doc.prefix.` "prefix '`' is for units on numbers."
@`g  1/1000 .multiply `kg
@`km 1000 .multiply `m


@doc.CompositionIsFirstPrinciple
"Every compositional model consists of a trinity: components, operators, and properties. Compositional operators are algebraically closed; they often combine two components into a third. Compositional properties are invariant or inductive over the operators. The set of components may be domain specific (such as diagrams, documents, sounds, and scene-graphs) or more general purpose (such as functions, arrows, matrices, grammars). 
 
 Composition is useful as a formal foundation for scalability and modularity. Compositional properties enable developers to reason about components without knowledge of the implementation details. Composition operators are also convenient due to their uniformity, i.e. we aren't forced to develop or learn a new language or interface for every object.
 
 Many models in common practice - including state machines, records, process loops, nominative types, conventional conditional expressions, even parametric abstraction - are not compositional. 
 
 Compositional alternatives are available. Grammars can operate as state machines (via parsing). Datalog or relational algebras generalize records. Processes can be compositional if we instead model them as partial and incremental (i.e. small-step processes; `µP.a→(P*b)`). Nominative types can be replaced with structural types. If/then/else and ad-hoc pattern-case conditional expressions can be replaced with a structural sum types. Ad-hoc parametric abstraction can often be replaced with staging and a reader monad.
 
 Awelon project strongly favors compositional models and designs. This should be reflected in AO's dictionaries and ontologies. I ask that all AO developers embrace composition as first design principle, pervasively, with priority above other features.
 
 Effective use of composition often requires domain-specific tradeoffs between the three aspects. For example, by limiting what we talk about (just diagrams) we can achieve more specialized properties (e.g. bounding areas, efficient occlusion) and more operators (add, scale, rotate, translate, etc.). It is possible to switch between compositional models primarily by layering them, such that the output of one compositional model becomes another compositional model. At a lower layer, a generic compositional model enables integration of domain-specific models.
 
 AO is designed to serve as that generic compositional layer. AO's words are software components. AO's compositional properties - especially causal commutativity, spatial idempotence, and capability security - are very useful in this role. AO is also designed to mitigate common weaknesses of deeply layered abstractions by aggressive use of partial evaluation, dependent type analysis, and program search.
~


