
@doc.import.std "viable starting point for AO dictionaries"

@doc.NamingConventions
"AO makes heavy use of naming conventions. Common prefixes suggest automatic processing or type information. For example, 'doc.' indicates documentation for a word, and 'test.' indicates automatic testing in a mockup environment, and 'id.' indicates that a given expression should be equivalent to identity for all the types it accepts. Similarly, suffixes connote context. A suffix might identify a specific framework, project, or programmer.
 
 Multi-part words unfortunately make AO verbose and difficult to read. 
 
 The intention is to mitigate this issue in the editor. A set of rules (configurable per user or project) will translate common prefixes and suffixes into rendering with colors and styles. Also, fuzzy autocomplete mechanisms can eliminate need to fully write out large words.
~

@doc.prefix.doc
"AO does not have 'comments' in the usual sense. Instead, it has documentation words. A word that starts with 'doc.' should introduce documentation in a common format. If a word is too complicated to effectively document this way, consider factoring its definition into smaller pieces!
~

@doc.StandardEnvironment
"AO is not a stack-based programming language. One might better call it pair-based, but even that is somewhat misleading. AO is value-based. The value involved may be composed from six basic structural types: product (pair), sum, unit, void, number, and block (function). AO words will analyze and manipulate this tacit value.
 
 However, by convention, the tacit value will model a stack-based programming environment plus extensibility features. Literals in AO have form `"foo" :: (s*e)→((Text*s)*e)`, effectively treating `s` as an implicit stack and `e` as a stable environment. The standard environment elaborates 'e' with structure for flexible workflows and dataflows, concurrency, and extensibility. Standard data shuffling words are designed assuming the standard environment. The type is roughly:
 
     (s * (h * (p * ((sn * rns) * ex))))
 
 Where:
   s: the current stack, where most operations apply
   h: the hand, temporary store and semantic clipboard
   p: a powerblock, to observe or influence real world
   sn: name of current stack, used when switching stacks
   rns: record of (name*stack) pairs for workspaces and registers
   ex: unused; available for experimental extensions
 
 As mentioned above, `s` is the primary active stack. That's where all stack shufflers apply, where all math is performed. However, AO is unlike most other stack-based languages, e.g. with respect to its capability-based effects and causal commutativity. As a consequence of these differences, AO can be very implicitly concurrent - i.e. by modeling different computations on different stacks. Non-deterministic concurrency can also be modeled, using oracle machine idioms.
 
 Stack manipulations are often described using 'stack effect' strings, as used in Factor or Forth. For example, "x y z -- y x z" suggests that the top item on the current stack (z) remains in place, and the elements below it are swapped. Such annotations are for documentation purposes. AO does not have any built-in support for type description, beyond assertions and merges.
 
 This particular computing environment is suitable for text-based programming environments. I have an alternative in mind for Awelon project, which involves navigation metaphors (spatial/kd-trees by zipper) while wielding an inventory of recomposable tools including programmable glasses (lenses, HUD).
~

@doc.prefix.test
"Automated testing is an effective means to maintain software quality. Tests cannot discover every problem, but they can resist errors, prevent regressions, and generally improve confidence in code. In AO, automatic testing is expressed simply by using the prefix 'test.' in the definitions of words.
 
 Tests are systematically executed in a standard environment with a confined powerblock. A test is said to fail if there are any type errors, assertion failures, or explicit failures (reported via powerblock). In addition, developers can issue warnings through the powerblock. Unless otherwise indicated, a test passes and (in many cases) developers are free to examine the test output.
 
 In addition to conventional tests, AO developers can express desire for symbolic analysis using 'eqv.' and 'id.' prefixes.
~

@doc.id " -- "
@doc.dup "(Copyable x) ⇒ x -- x x"
@doc.dupd "(Copyable x) ⇒ x y -- x x y"
@doc.over "(Copyable x) ⇒ x y -- x y x"
@doc.tuck "(Copyable y) ⇒ x y -- y x y"
@doc.pick "(Copyable x) ⇒ x y z -- x y z x"
@doc.drop "(Droppable x) ⇒ x -- "
@doc.nip  "(Droppable x) ⇒ x y -- y"
@doc.nip2 "(Droppable x,y) ⇒ x y z -- z"
@doc.swap "y x -- x y"
@doc.swapd "x y z -- y x z"
@doc.rot "x y z -- y z x"
@doc.unrot "y z x -- x y z"
@doc.roll "w x y z -- x y z w"
@doc.unroll "x y z w -- w x y z"
@doc.spin "x y z -- z y x"
@doc.intro1 " -- Unit"
@doc.elim1 "Unit -- "

@id 
@dup %r^wzlwl
@dupd swap dup rot
@over dupd swap
@tuck swap over
@pick %rw over %wl swap
@drop %r%
@nip swap drop
@nip2 unrot drop2
@dropd swap drop
@swap  %rwr %wzw %lwl
@swapd %rw swap %wl
@rot swapd swap
@unrot swap swapd
@spin swap swapd swap
@roll %rw rot %wl swap
@unroll swap %rw unrot %wl
@intro1 %vvrwlcl
@elim1 %rvrwlcc
@roll2 swap
@roll3 rot
@roll4 roll

@doc.ShorthandDataShuffling
"This dictionary defines a few single character data shufflers for an object on the stack, to compactly support simple manipulations. These operations include:
 
     p :: y x -- (x*y)
     x :: (x*y) -- y x
     w :: (x*y) -- (y*x)
     z :: ((a*b)*(c*d)) -- ((a*c)*(b*d))
     l :: (a*(b*c)) -- ((a*b)*c)
     r :: ((a*b)*c) -- (a*(b*c))
 
  Common combinations are also defined, such as `pw` and `wx`, which pair or extract the second element. The meanings here aren't quite the same as in ABC under the hood, but they are sometimes useful.
~
@doc.p "y x -- (x*y)"
@doc.x "(x*y) -- y x"
@doc.w "(x*y) -- (y*x)"
@doc.l "(x*(y*z)) -- ((x*y)*z)"
@doc.r "((x*y)*z) -- (x*(y*z))"
@p %rwrzwll
@x %rrwzlwl
@w %rrwll
@l %rrwrzwlll
@r %rrrwzlwll
@pw p w
@wx w x
@pwx p w x

@doc.head "(x*y) -- x"
@doc.tail "(x*y) -- y"
@head wx drop
@tail x drop

@id.wl³ w l w l w l
@id..wl³ .swap %l .swap %l .swap %l
@id.wr³ w r w r w r
@id..wr³ .swap %r .swap %r .swap %r
@id.lw³ l w l w l w
@id..lw³ %l .swap %l .swap %l .swap
@id.rw³ r w r w r w
@id..rw³ %r .swap %r .swap %r .swap
@id.lr l r
@id.rl r l

@doc..swap "(x*y)→(y*x); primitive swap"
@.swap %vrwlc

@doc.swapStackName "newSN -- oldSN; replace name for current stack"
@doc.setStackName "SN -- ; set name for the current stack"
@doc.getStackName "-- SN ; get name for current stack"
@swapStackName %lzrzrzwrwzwlwzlzlzr
@setStackName swapStackName drop
@getStackName intro1 swapStackName copy swapStackName elim1 put
@id.swapStackName swapStackName swapStackName
@id.getSetStackName getStackName setStackName

@doc.swapPowerBlock "power -- power; replace powerblock in standard env"
@swapPowerBlock %zrwzwlz
@id.swapPowerBlock swapPowerBlock swapPowerBlock

@doc.prefix.eqv 
"There are many cases where two different expressions should be equivalent. Explicitly asserting so is useful! Not only may equivalencies serve as documentation, but they also can support automatic tests or provide hints for optimizers and refactoring tools. So prefix 'eqv' provides a generic way to suggest that two expressions should be equivalent.
 
 The type of an 'eqv.foo' word should be:  ( -- [a→b] [a→b]). 
 
 That is, developers should simply add two blocks to the current stack, which should have equivalent behavior modulo typeful identity. Use of the 'eqv' prefix enables external tools to systematically discover, document, and validate these assertions. 
 
 A more specialized equivalency is also available with prefix 'id'. Eventually, there may be specialized prefixes for for idempotence (`f f = f`) and commutativity (`f g = g f`), and similar properties (plus associativity) for binary functions. However, for now, these may be expressed by eqv.
~
@eqv.takeSwapPut.swapd [take swap put] [swapd]
@eqv.swap.pwx [p w x] [swap]
@eqv.p1drop2 [p drop] [drop2]
@eqv.p2drop3 [p p drop] [drop3]
@eqv.p3drop4 [p p p drop] [drop4]
@eqv.pw2drop3 [pw pw drop] [drop3]
@eqv.commutative.affine&relevant [affine relevant] [relevant affine]
@eqv.idempotent.linear [linear linear] [linear]
@eqv.idempotent.affine [affine affine] [affine]
@eqv.idempotent.relevant [relevant relevant] [relevant]
@eqv.dupSwap [dup swap] [dup]

@doc.prefix.id 
"There are many cases where a sequence of operations should have operations should have no total, observable effect. For example, `swap swap` is the same as taking no action. These sequences are essentially instances of the 'identity' behavior, modulo slight differences on the required input type - i.e. they are 'typeful' identities. 
 
 The 'id' prefix is a specialized equivalence that also implies idempotence and commutativity. Look into the 'idempotent', 'commutative', and 'eqv' prefixes.
 
 Use of prefix words to declare properties such as identity, idempotence, associativity, and commutativity is useful for documentation, automatic validation, and development of optimizers. Developers are encouraged to do so.
~ 

@id.swap swap swap
@id.swapd swapd swapd
@id.rot rot rot rot
@id.unrot unrot unrot unrot
@id.roll roll roll roll roll
@id.unroll unroll unroll unroll unroll
@id.spin spin spin
@id.introElim intro1 elim1
@id.elimIntro elim1 intro1
@id.px p x
@id.xp x p
@id.ww w w
@id.pwxswap p w x swap
@id.swappwx swap p w x
@id.dupdrop dup drop
@id.dupSwapDrop dup swap drop
@id.dupSwapdDropSwap dup swapd drop swap
@id.dup2drop2 dup2 drop2
@id.quoteUnquote quote unquote
@id.unquoteQuote unquote quote
@id.textDrop "text" drop

@relevant %rkl
@affine   %rfl
@linear   relevant affine
@doc.relevant "mark block on stack as relevant (not Droppable)"
@doc.affine "mark block on stack as affine (not Copyable)"
@doc.linear "mark block on stack as linear (neither Copyable nor Droppable)"

@reifyStack intro1 %rwl
@restoreStack %rwl elim1
@doc.reifyStack "(s*e)→((s*Unit)*e) : stack becomes object on fresh stack"
@doc.restoreStack "((s*Unit)*e)→(s*e) : single object on stack becomes stack"

@doc.drop2 "(Droppable x,y) ⇒ x y -- "
@doc.drop3 "(Droppable x,y,z) ⇒ x y z -- "
@doc.drop4 "(Droppable w,x,y,z) ⇒ w x y z -- "
@drop2 drop drop
@drop3 drop drop drop
@drop4 drop drop drop drop

@doc.dup2 "(Copyable x,y) ⇒ x y -- x y x y"
@doc.dup3 "(Copyable x,y,z) ⇒ x y z -- x y z x y z"
@doc.dup4 "(Copyable w,x,y,z) ⇒ w x y z -- w x y z w x y z"
@dup2 p dup %rw x %wl x
@dup3 p p dup %rw x x %wl x x 
@dup4 p p p dup %rw x x x %wl x x x

@doc.Quotable
"Most values in AO are quotable, except in contexts where an AO program models a distributed behavior. Distributed values are not quotable; all values entering a quote must have the same location. 
 
 A quotation is simply a block that reproduces a value. This typically has special support from the implementation (i.e. capturing the value rather than converting it to code), but will be serialized to code when necessary for display or networking.
 
 If a block with affine or relevant properties is quoted, the quote will inherit these properties. 
~
@doc.quote "(Quotable x) ⇒ x -- [--x]"
@doc.unquote "[--x] -- x"
@quote %r'l [%l] compose
@unquote %rvvrvrrz %$ %wlclcwlcl

@test.quote  7 dup quote unquote assertEQ drop

@doc.Hands
"In AO, the hand is modeled as a second stack. It can be used as a temporary storage for deep operations on the current stack, and also serves as a semantic clipboard for ad-hoc data shuffling.
 
     (currentStack * (hand * ... ))
 
 Developers can:
 
 * take item from stack into hand
 * put top item from hand onto stack
 * juggle (rotate) a few items
 * discard a value from the hand
 * copy an item from the stack into hand
 * paste an item in the hand onto the stack
 
 In addition, hands are stable when developers use navigational metaphors, i.e. to operate in different workspaces or environments. Also, hands are hidden by some operations, such as `apply`.
 
 AO encourages a "clean hands" policy: most words should have a neutral effect on the hand, and not affect or observe the values already held by it. The exception is words like `take` and `put` where the purpose is to manipulate the hand. Some common words, such as `apply`, will hide the hand - making
~

@take %rzlw
@put  %wrzl
@discard put drop
@copy dup take
@paste put copy

@take2 take take
@take3 take take take
@take4 take take take take
@put2  put  put
@put3  put  put  put
@put4  put  put  put  put
@juggle2 %w roll2 %w
@juggle3 %w roll3 %w
@juggle4 %w roll4 %w

@taked swap take
@putd put swap

@doc.take "move value at top of stack to top of hand"
@doc.put "move value at top of hand to top of stack"
@doc.discard "drop and destroy value in hand"
@doc.copy "copy object from top of stack into hand (copy/paste metaphor)"
@doc.paste "paste object from hand onto top of stack (copy/paste metaphor)"
@doc.taked "take second item from stack"
@doc.putd "put below first item on stack"

@reifyHand %w reifyStack %w
@restoreHand %w restoreStack %w
@doc.reifyHand "hand becomes single object in fresh hand"
@doc.restoreHand "single object in hand becomes hand"
@doc.swapHands "swap reified hand on stack with current hand"
@swapHands %rwzwl

@id.takePut take put
@id.putTake put take
@id.juggle3 juggle3 juggle3 juggle3
@id.takeJugglePutSwap take2 juggle2 put2 swap
@id.takeSwapPutSwapd take swap put swapd
@id.copyDiscard copy discard
@id.pasteDiscardTake paste discard take
@id.reifyRestoreHand reifyHand restoreHand
@id.take3put3 take3 put3

@doc.MakingWithBlocks
"A block in AO consists of code wrapped in square brackets, of form: `[put swap take]` or `[2 add]`. The meaning of a block is a first-class function that may be applied later. Blocks are essential in AO for:
 
 * representing loop behaviors by copying and applying blocks
 * modeling conditional behavior, apply block on just one branch
 * direct models of higher order programs and behavioral abstraction
 * transporting access and authority to resources and side-effects
 
 Best practices for use of blocks have not fully been established. Awelon project favors compositional abstractions to such an extent that use of ad-hoc parametric abstraction is discouraged. (See @doc.FirstPrincipleIsComposition.) My expectation is that blocks will be de-emphasized for behavioral abstraction in favor of indirect mechanisms - e.g. structured DSLs, symbolic expressions, free monads, staged programming. In this sense, AO discourages conventional 'functional programming' in favor of a more 'language oriented programming'.
 
 Nonetheless, blocks remain essential for loops, effects, and conditions. Also, blocks make an effective compilation target, an alternative to interpretation, and they can help an embedded DSL model corner cases.
 
 Blocks can be composed.  Composition working together with quotation can also model such features as partial, concurrent, and conditional application.
 
     compose :: [x→y] [y→z] -- [x→z]      (sequential)
     .curry  :: x [(x*y)→z] -- [y→z]      (partial)
     .bfirst :: [x→y] -- [(x*e)→(y*e)]    (concurrent)
     .bleft  :: [x→y] -- [(x+e)→(y+e)]    (conditional)
 
 Some readers might be familiar with the notions of 'first' and 'left' from John Hughes' arrow model, which was an important foundation for AO and RDP. The primitive forms of '.curry' and '.bfirst', etc.. aren't very useable in the standard environment, but derived forms will also be available. 
 
 In addition, blocks may be constructed by quotation of a value:
 
     quote   :: (Quotable x) ⇒ x -- [-- x]
     unquote :: [-- x] -- x
 
 After construction, blocks can be applied in various ways. Developers will mostly use 'apply', which applies a block to the current environment except for the hand. Items in the current hand are hidden. But there are other operations that include (potentially) useful patterns for data hiding and application.
 
     .apply :: x [x→y] -- y ; apply block to just top object on stack
     apply  :: x [x--y] -- y; apply block to just top object on stack
       this variation provides a fresh stack and empty hand
       (powerblock, named stacks, etc. are hidden)
     dip    :: h [] -- ; apply block to all except top element on stack
     hdip   :: [] -- ; apply block hiding current hand 
     inline :: [] -- ; apply block as if inline (hand is visible)
     keep   :: x [x -- y] -- y x; copies element on stack
 
 The set of application words will undoubtedly evolve with experience.
 
 Todo: add common bi/tri variants from Factor's vocabulary
~

@doc.compose "[x→y] [y→z] -- [x→z]; compose functions"
@doc.composel "[y→z] [x→y] -- [x→z]; compose on left"

@compose p %rrol
@composel swap compose
@.apply p %rr$l
@apply %rwrzvrwvvrrvrrz %$ %wlcllccwlcl
@dip %rwrzvrwr$wlcl
@hdip reifyHand putd dip take restoreHand
@inline %rvr$c
@keep dupd dip

@dip2 take p put dip x
@dip3 take p p put dip x x
@dip4 take p p p put dip x x x
@keep2 take dup2 put dip2
@keep3 take dup3 put dip3
@keep4 take dup4 put dip4

@id.apply.id [id] apply
@id.compose [id] compose
@id.swap.compose [id] swap compose
@id.inline.id [id] inline

@doc..first "(a*b) [a→a'] -- (a'*b)"
@doc..second "(a*b) [b→b'] -- (a*b')"
@doc..both "(a*b) [a→a'] [b→b'] -- (a'*b')"
@.first take x put .apply p
@.second take pw put .first pw
@.both take .first put .second

@eqv.cca [.both] [swap take2 pw put2 .both pw]

@doc..bind "x [(x*y)→z] -- [y→z]; bind argument into pair"
@doc.bind "x [((x*s)*e)→z] -- [(s*e)→z]; bind argument onto stack"
@doc..curry "[(x*y)→z] -- [x→[y→z]]; curry pair argument"
@doc.curry "[((x*s)*e)→z] -- [x→[(s*e)→z]]; curry stack argument"
@doc..bfirst "[x→x'] -- [(x*y)→(x'*y)]"
@doc..bleft "[x→x'] -- [(x+y)→(x'+y)]"
@doc..bsecond "[y→y'] -- [(x*y)→(x*y')]"
@doc..bright "[y→y'] -- [(x+y)→(x+y')]" 
@doc..bapply "[x→x'] -- [((x*s)*e)→((x'*s)*e)]"
@.bind pw %rr'wol
@bind swap %r'l [%l] compose composel

@bind2 bind bind
@bind3 bind bind bind
@bind4 bind bind bind bind

@.curry [.bind] bind
@curry  [bind]  bind

@curry2 [bind curry] bind
@curry3 [bind curry2] bind
@curry4 [bind curry3] bind

@.bfirst %r'l [%$] compose
@.bleft  %r'l [%vr?c] compose
@.bsecond .bfirst [.swap] compose [.swap] composel
@.bright .bleft [.mirror] compose [.mirror] composel
@.bapply [.apply] bind

@doc.PrimitiveMath
"The intention is for AO to operate easily with units and matrices. The prefix '.' is used for primitive math operations on naked, scalar numbers. These operators include `.add`, `.multiply`, `.negate`, `.invert`, `.divMod`, `.subtract`, and `.divide`. The same operations without the prefix will eventually refer to versions that contain dispatch logic for common value types, requiring very aggressive optimization.
 
 More generally, AO will be leaning towards symbolic math libraries, i.e. such that we build expressions in a math DSL rather than directly compute results. This enables much richer analysis and optimization to be performed within the language, at expense of making it difficult to directly optimize the language (except by partial evaluation).
~

@.mul p %rr*l
@.add p %rr+l
@.neg %r-l
@.inv %r/l
@.divMod p %rrQll wx
@.quot .divMod nip
@.rem  .divMod drop
@.sub .neg .add
@.div .inv .mul

@inc 1 .add
@incd swap inc swap
@dec 1 .sub
@decd swap dec swap

@doc..mul "N(b) N(a) -- N(a*b)"
@doc..add "N(b) N(a) -- N(a+b)"
@doc..neg "N(a) -- N(-a)"
@doc..inv "N(a) -- N(1/a); a must be non-zero"
@doc..divMod "N(a) N(b) -- N(r) N(q) where a=q*b+r and r in (b,0] or [0,b)"
@doc..quot "just the quotient from .divMod"
@doc..rem "just the remainder from .divMod"
@doc..sub "N(a) N(b) -- N(a-b)"
@doc..div "N(a) N(b) -- N(a/b)"

@id.mul1 1 .mul
@id.div1 1 .div
@id.add0 0 .add
@id.sub0 0 .sub

@doc.ConditionalBehavior
"Awelon expresses conditional behavior using sum types. 
 
 A sum type, `(a + b)`, indicates a value that is either left in `a` or right in `b`. A boolean, having two values, could be modeled as `(1 + 1)` where 1 is the unit type (having one value). However, AO does not heavily use booleans. For example, the output of comparing two values will initially contain the compared values, such that no information is lost. 
 
 In AO, a sum type is the result of an *observation*. For primitive observations, one may ask whether a value (other than unit) is a pair, sum, number, or block. Numbers and complex products or sums of numbers may also be compared, e.g. to test whether one number is greater than another. Unit may only be compared against unit. (The limitations against observing unit help developers model static structure.)
 
 By convention, when observing a binary condition `(a + b)`, the right answer `b` indicates truth or success. The left answer `a` indicates falsehood or failure. Standard words are developed using this convention. AO's variation of the 'not' word simply mirrors left and right, i.e. `not :: (a + b) -- (b + a)`.
 
 Conditional behavior is expressed by applying a block on just one condition. The block must be droppable (because it might not apply). Compared to most languages, ABC is unusually precise regarding distribution of data across a condition. However, coarse-grained if/then/else or Haskell-like 'either' idioms may be expressed.
~

@isPair   %rPl
@isSum    %rSl
@isNumber %rNl
@isBlock  %rBl
@not      %rVRWLCl

@doc..mirror "(a+b)→(b+a)"
@.mirror %VRWLC

@id.isPairMerge  isPair merge
@id.isSumMerge   isSum merge
@id.isNumMerge   isNumber merge
@id.isBlockMerge isBlock merge
@id.notnot       not not

@doc.inR "b -- (0 + b); wrap 'b' in success, mark true, in the right"
@doc.inL "a -- (a + 0); wrap 'a' in failure, mark false, on the left"
@inR %rVVRWLCl
@inL %rVl

@doc.gt "a b -- ((a*b) + (b*a)); a > b?"
@doc.lt "a b -- ((b*a) + (a*b)); a < b?"
@doc.gte "a b -- ((a*b) + (b*a)); a >= b?"
@doc.lte "a b -- ((b*a) + (a*b)); a =< b?"
@gt  p %rr>l
@lt  swap gt
@gte lt not
@lte gt not

@doc.compare "a b -- (((LT(a*b) + EQ(b*a)) + GT(b*a))"
@doc.eq  "a b -- ((LT(a*b) + GT(b*a)) + EQ(b*a))"
@doc.neq "a b -- (EQ(b*b) + (LT(a*b) + GT(b*a)))"
@compare gt [%vv wx lt not %cc] .left
@eq neq not
@neq compare %rRWl

@doc.distrib "(a + b) c -- ((c*a) + (c*b))"
@doc.partialFactor "((a*b)+(c*d)) -- (b + d) (a + c)"
@doc.merge   "(a + a') -- a; a and a' must be future compatible"
@doc.fullFactor "((a+b)+(a'+d)) -- (b+c) a"
@distrib p %rrDl
@partialFactor %rFll x
@merge %rMl
@fullFactor partialFactor merge

@doc.condSwap "conditional swap; swap top two arguments if third in right"
@doc.ifk "keep one of two values based on condition; keep conditional"
@doc.if "keep one of two values based on condition; drop conditional"
@doc.if! "apply if to select a block, then apply the block inline"
@condSwap p distrib [%rwl] .left fullFactor wx
@ifk condSwap drop
@if ifk dropd
@if! if inline

@doc..left  "(a + b) [a→a'] -- (a' + b); apply block on left condition"
@doc..right "(a + b) [b→b'] -- (a + b'); apply block on right condition"
@doc..either "(a + b) [a→a'] [b→b'] -- (a' + b')"
@.left p %rr?l
@.right take not put .left not
@.either take .left put .right

@eqv.cca+ [.either] [swap take2 not put2 .either not]

@doc..distribdE
"Distribute the environment across the condition expressed in the second item on the stack, holding only the item on the top of the stack. This doesn't require a standard environment:
 
    (k*((a+b)*s))*e → (((a*s)*e)+((b*s)*e))*(k*1)
 
 Note: this operation is not entirely parametric in context of spatial-temporal types. It must be possible to observe the (+) condition across all values in s,e. 
~
@.distribdE
 %rvrw
 %rrwzl
 %D
 [.swap %l] %r? .mirror
 [.swap %l] %r? .mirror
   
@doc..factorEd "reverses @.distribdE"
@.factordE 
 [%r] %r? .mirror
 [%r] %r? .mirror
 %FwMwlwlcll x

@doc..distribE "((a+b)*s)*e → ((a*s)*e)+((b*s)*e); p @.distribdE"
@.distribE
 %rvrw
 %D
 [.swap %l] %r? .mirror
 [.swap %l] %r? .mirror
 %c

@doc..factorE "reverses @.distribE"
@.factorE
 %v
 [%r] %r? .mirror
 [%r] %r? .mirror
 %FwMwlcl

@doc.leftE "(a+b) [a -- a'] -- (a'+b); left with full env"
@doc.rightE "(a+b) [b -- b'] -- (a+b'); right with full env"
@doc.eitherE "(a+b) [a -- a'] [b -- b'] -- (a'+b'); with full env"

@leftE .distribdE %w?c .factorE
@rightE take not put leftE not
@eitherE
 pw
 .distribdE 
 %wrz?
 .mirror
 %w?
 .mirror
 %c
 .factorE

@doc.leftdE "(a+b) d [a -- a'] -- (a'+b) h; leftE hiding element d"
@doc.rightdE "(a+b) d [b -- b'] -- (a+b') h; rightE hiding element d"
@doc.eitherdE "(a+b) d [a -- a'] [b -- b'] -- (a'+b') h; eitherE hiding d" 
@leftdE p .distribdE %wrz? .factordE
@rightdE take2 not put2 leftdE take not put
@eitherdE 
 pw p r
 .distribdE
 %wrz?
 .mirror
 %wrz?
 .mirror
 .factordE

@doc.assert 
"AO and ABC offer a primitive mechanism to assert that a condition is not false, i.e. that `(a + b)` is not in `a`. (The condition is not necessarily true, i.e. it may be that the assertion itself is dead code.) Since the condition after a successful assertion is not false, we eliminate the sum type and just continue with `b`.
 
     assert :: (a + b) -- b
 
 In addition, specialized asserts can be much easier to use. These operate as identity functions, but with a limited acceptance criteria.
 
     assertPair, assertBlock, assertSum, assertNumber, assertUnit -- basic type
     assertLT, assertLTE -- assert upper bounds for a comparable value
     assertGT, assertGTE -- assert lower bounds for a comparable value
 
 And common number assertions...
 
     assertNumber, assertInteger -- assertions on number types
     assertGTz, assertGTEz -- assert greater than or equal to zero
     assertEQz, assertNEQz -- assert equal or not equal to zero
     assertLTz, assertLTEz -- assert less than or equal to zero
     assertNatural -- integer greater than or equal to zero
     assertNatural+ -- integer greater than or equal to one
     assertChar -- integer between 0 and 1114111 inclusive
     assertOctet -- integer between 0 and 255 inclusive
     assertProb -- rational number between 0 inclusive and 1 inclusive
     assertUniform -- rational number between 0 inclusive and 1 exclusive
 
 To clarify, `assert` is primarily intended for *static* analysis. It provides a means to express some preconditions, postconditions, and refinement types. These conditions should ideally be computable via partial evaluation, such that developers can receive compile time errors or warnings or errors based on whether an asserted condition is disproven or unproven.
 
 In an effectful program, some assertions may have dynamic nature. In that case, modulo use of capabilities designed to isolate failure, a dynamic assertion failure causes the whole program to be halted as quickly and cleanly as feasible.
~
@assert   %rKl

@assertLT   lt assert wx
@assertLTE  lte assert wx
@assertGT   gt assert x
@assertGTE  gte assert x
@assertEQ   eq assert x
@assertNEQ  neq assert [%vrwlc] .left merge x

@assertLTz  assertNumber 0 assertLT drop
@assertLTEz assertNumber 0 assertLTE drop
@assertGTz  assertNumber 0 assertGT drop
@assertGTEz assertNumber 0 assertGTE drop
@assertEQz  0 assertEQ drop
@assertNEQz assertNumber 0 assertNEQ drop

@assertPair   isPair assert
@assertNumber isNumber assert
@assertBlock  isBlock assert
@assertSum    isSum assert
@assertUnit   elim1 intro1

@assertInteger  dup 1 .rem assertEQz drop
@assertNatural  assertGTEz assertInteger
@assertNatural+ assertGTz  assertInteger
@assertChar     assertNatural 0x10ffff assertLTE drop
@assertOctet    assertNatural 256 assertLT drop
@assertProb     assertGTEz 1 assertLTE drop
@assertUniform  assertGTEz 1 assertLT drop

@id.assertInR inR assert
@id.assertPair assertPair
@id.assertNumber assertNumber
@id.assertBlock assertBlock
@id.assertSum assertSum
@id.assertUnit assertUnit
@id.assertLT assertLT
@id.assertLTE assertLTE
@id.assertGT assertGT
@id.assertGTE assertGTE
@id.assertEQ assertEQ
@id.assertNEQ assertNEQ
@id.assertLTz assertLTz
@id.assertGTz assertGTz
@id.assertGTEz assertGTEz
@id.assertLTEz assertLTEz
@id.assertEQz assertEQz
@id.assertInteger assertInteger
@id.assertNatural assertNatural
@id.assertNatural+ assertNatural+
@id.assertChar assertChar
@id.assertProb assertProb
@id.assertUniform assertUniform

@doc.EnvironmentManipulation
"AO developers aren't limited to a single instance of the standard environment. Subprograms may be computed in their own complete environments, and objects may be shifted from one environment to another (using the hand, by default, for data shuffling). 
 
 Developers can:
 
 * create a fresh, empty environment on the stack (introE)
 * safely destroy an empty environment on the stack (elimE)
 * swap current environment with environment on stack (swapE)
 
 When swapping environments, the current hand and powerblock will follow the user. Moving objects between environments involves use of the hand. A initial stack name for an environment is simply the empty string (which is equivalent to number 3). 
~

@doc.introE "adds empty environment object to stack"
@doc.elimE "deletes empty environment object ('drop' also works, but less safe)"
@doc.swapE "switch current environment with env on stack; keep hand and power"
@introE "" %r %vrvrwvrr %vrwlc %l
@elimE  %r %vrwlc %llcwlclc %l drop
@swapE %zrzwlz %vrwlc %zrwzl

@id.introElimE introE elimE
@id.swapE swapE swapE


@doc.TODO
"Much to do about AO
  * functions on lists, association lists, records
  *   binary to base64, binary to text, text to binary
  * contraint models for staged dependency/policy/typeclass injection 
  * project euler?
  * optimizers and compilers for ABC, AMBC, and AO
  * simplified app type for quick integration with Haskell? (use plugins?)
  * 2D-3D scene-graphs based on enneatrees and zippers
  * secure pseduo-random number generators; probabilistic programs
  * math libs - linear algebra, symbolic maths
  * knowledge database or encyclopaedia?
  *   unicode
  *   world data? (countries, flags, populations, maps)
 
 AO's design philosophy is actually similar to Wolfram's - that code should have easy access to vast quantities of useful, maintainable data. AO provides this access in the form of words in a very large dictionary.
~

@doc.Loops
"Loops in AO are modeled as words that repeatedly copy and apply a block until some halting condition is observed. Example loop words:
 
 * each - apply block with each element in list
 * repeat - inline block a given number of times
 * enum - like repeat, but with an index
 * while (or until) - loop while (or until) condition is observed
 
 These words are ultimately derived from fixpoint combinators, which are notoriously difficult to grok. Fortunately, it is not difficult to learn and use a loop word, nor to build new loop words above existing ones. Any loop variables, such as the block being applied, are hidden from the loop body (cf. `.dip`).
 
 *Note:* Loops in AO are assumed and required to terminate. In general, this condition cannot be proven statically, so it is the responsibility of developers to reason about termination properties or favor idioms that simplify static analysis. AO programs will often be subject to static analysis for termination properties, with a warning being issued if termination could not be decided. 
 
 Long-running behaviors in AO are not expressed as loops. Instead, a long-running application is expressed using an incremental process model or a continuous reactive behavior, within an *implicit* top-level loop (depending on the application model). This design ensures an open-loop, subject to process control, abstraction, composition, and extension.
~

@doc.repeat "[] n --; inline block n times"
@doc.enum   "[i --] n m --; loop with integral index in range [n,m)."
@doc.enumI  "enum in range [n,m] (i.e. including m)"

@test.repeat 4 7 [incd] 3 repeat assertEQ
@repeat assertNatural swap [repeat.step] bind fixpoint inline
@doc.repeat.step "n [continue] [action] -- ; n counting down"
@repeat.step
 rot dup 1 lt
 [rot p swap dip x decd inline]
 [drop3]
 if!

@test.enum 15 0 [.add] 1 5 enumI assertEQ
@enumI inc enum
@enum assertEnumRange pw swap [enum.step] bind fixpoint inline
@assertEnumRange swap assertInteger swap assertInteger assertLTE
@doc.enum.step "(n*m) [continue] [action] -- "
@enum.step
 pick x gt
 [drop3]
 [enum.action]
 if!
@enum.action
 pick x dropd swap
 roll roll p swap
 dip
 wx x inc p swap
 inline

@doc.each "a`L [a --] --; apply block to each element in list, left to right"
@doc.map "a`L [a -- b] -- b`L; process each element in list, left to right"

@each [each.step] fixpoint inline
@each.step
 


@doc.while1 "b [b -- (a + b)] -- a"
@doc.until1 "a [a -- (a + b)] -- b"
@doc.while  "(a + b) [b -- (a + b)] -- a"
@doc.until  "(a + b) [a -- (a + b)] -- b"

@while [while1] rightE merge
@until [until1] leftE merge
@while1 [not] compose until1
@until1 [.distribE] compose %rvr .until1 %c

@doc.fixpoint
"This strict fixpoint combinator (Z combinator) binds a function to receive itself (in fixpoint form) as an argument on the stack. AO does not allow cyclic definitions, but a fixpoint can express cyclic behavior.
 
     [foo] fixpoint
         is equivalent to
     [[foo] fixpoint foo]
 
 Naturally, if a fixpoint function unconditionally applies itself, the program will diverge. Thus, any fixpoint function should have conditional behavior and a termination condition.
 
 Fixpoint is one of those patterns that people find difficult to comprehend until they've used it many times. I encourage developers to use, learn, and understand it. But in practice it may often be easier to express most behavior in terms of a few loops (map, each, enum, repeat, until, while, etc.) built above fixpoint.
~
@fixpoint [swap dup bind composel] bind dup apply

@doc.factorial.fp "mostly this is a test for fixpoint :)"
@factorial.fp assertNatural [factorialStep.fp] fixpoint apply
@factorialStep.fp
 take 2 lt
 [tail dup dec put apply .mul]
 [head discard]
 eitherE
 merge
@test.factorial.fp 720 6 factorial.fp assertEQ

@doc.Lists
"Lists in AO consist of a sequence of pairs ending in a number. For example, a list of four values might have structure:
 
     (a * (b * (c * (d * N(x))))
 
 In type signatures, this structure might be abbreviated as a`L, for a list of a. Lists are processed by asking of each element 'are you a pair?'. If so, the first item is an element in the list, and the second is the rest of the list. 
 
 The terminating number is not part of the list, but a convention of AO is to make use of small numbers to weakly indicate different types, e.g. to support rendering and optimization. A few common numbers:
 
     0: generic list terminator
     3: text (list of integers between 0 and 0x10ffff)
     8: binary (list of integers between 0 and 255)
 
 Relevantly, ending with different number does impact comparison functions, and developers may freely assert on list terminals to resist accidents. It is a bad idea to observe a terminal to decide type in any formal sense, but it can be useful in heuristic contexts (e.g. rendering in a debugger). A significant consequence of using terminals is that most operations that construct lists should accept a terminating element as an additional argument.
 
 Lists can be used for simple map and fold loops. 
  
 *Aside:* Lists are simplistic, in the sense that they are often overly simple. AO's standard dictionaries should include other data structures more suitable for efficient ad-hoc manipulations. These will include finger-trees, ropes built on finger-trees, and zippers. 
~


@doc.Zippers
"The zipper data structure was described by Gérard Huet in 1997. It enables navigation and modification of tree-structured data in a purely functional context. At any time, the original tree structure can be recovered with the modifications. For Awelon project, zippers are widely useful for modeling navigation through scene graphs or documents, and document-like structures. They may also be used for raycasting and rendering.
 
 To support user intuitions, zippers should be specialized for common data structures. However, AO does provide a few standard primitives for zippers on AO's product data type.
~

@doc.HigherOrderZippers
"Zippers are a first derivative on a data structure. However, higher derivatives are also very useful. For example, first derivative can focus on a single character in text, but second derivative models an expandable selection of text. In a scene graph, such could model a mobile bounding volume. 
 
 I don't grasp third derivatives yet, but my intuition is that it can help structurally abstract sweeps or convolutions, e.g. the process of casting a ray through a scene-graph.
~ 

@OLD-AO-ZIPPERS

"
 % 
 % In Awelon, zipper operations apply to top object on current stack. 
 %
 %    zwrap - prepare zipper; stack object is initial target
 %    zf - if target was (x*y), x is now target; undo with zuf
 %    zs - if target was (x*y), y is now target; undo with zus
 %    zu - undoes last zipper navigation (selects zuf or zus)
 %    zunwrap - fully exit and unwrap zipper, even if deep
 %    zunwrap_ - just unwrap zipper
 %
 % Knowing the representation of the zipper structure isn't essential,
 % but it might be interesting to some people. 
 %
 %    zwrap :: x <~> x*(1*1) :: zunwrap_ (on stack)
 %    zf    :: (x*y)*(l*r) <~> x*(1*(y*(l*r))) :: zuf
 %    zs    :: (x*y)*(l*r) <~> y*((x*l)*r)     :: zus
 %
 % The 'zu' and 'zunwrap' operations must perform introspection. 
 %
 % To manipulate the zipper target, developers will usually use an
 % operation such as:
 %   
 %    zswap - switch target of zipper (2nd) with object on stack (1st)
 %    zpop  - move target to top of stack (unit placeholder)
 %    zpush - undo zpop
 %
 zwrap = intro1 intro1 assocl rot2 pzip assocl  
 zunwrap_ = assocr pzip rot2 assocr elim1 elim1  
 zf = assocr x intro1 assocl roll2 assocl 
 zuf = assocr roll2 assocr elim1 p assocl
 zs = assocr x roll3 pw roll2 assocl
 zus = assocr roll2 x roll3 pw assocl
 zswap = p assocr roll2 assocl x
 zpop = intro1S zswap
 zpush = zswap elim1S
 % TODO: zu, zu*
 zu = % look at wrapper to decide step back
 zu* = % iterative zu
 zunwrap = zu* zunwrap_
~

@doc.rgb "usage: `1/3 5/7 4/5 rgb` in red-green-blue order, with range 0 to 1 inclusive. Also see @doc.rgb/24 for the typical 8-bit color."
@doc.rgb/24 "usage: `0x5c 0x35 0x66 rgb/24` in red-green-blue order"
@rgb 1 rgba
@rgba pw pw pw "rgba" p
@rgb/24 
    take2 fracOfOctet
    put   fracOfOctet
    put   fracOfOctet
    rgb
@fracOfOctet 1/255 .mul
@doc.fracOfOctet "divide by 255, such that numbers of range 0..255 result in a range 0 to 1 (inclusive)"

@doc.color 
"Following Elm's example, I'm using the [Tango](http://tango.freedesktop.org/Tango_Icon_Theme_Guidelines) pallette, with simpler names: red, orange, yellow, green, blue, purple, brown, gray, and charcoal - each with light and dark variations.
~

@color.lightRed      0xef 0x29 0x29 rgb/24
@color.red           0xcc 0x00 0x00 rgb/24
@color.darkRed       0xa4 0x00 0x00 rgb/24 
@color.lightOrange   0xfc 0xaf 0x3e rgb/24
@color.orange        0xf5 0x79 0x00 rgb/24
@color.darkOrange    0xce 0x5c 0x00 rgb/24
@color.lightYellow   0xfc 0xe9 0x4f rgb/24
@color.yellow        0xed 0xd4 0x00 rgb/24
@color.darkYellow    0xc4 0xa0 0x00 rgb/24
@color.lightGreen    0x8a 0xe2 0x34 rgb/24
@color.green         0x73 0xd2 0x16 rgb/24
@color.darkGreen     0x4e 0x9a 0x06 rgb/24
@color.lightBlue     0x72 0x9f 0xcf rgb/24
@color.blue          0x34 0x65 0xa4 rgb/24
@color.darkBlue      0x20 0x4a 0x87 rgb/24
@color.lightPurple   0xad 0x7f 0xa8 rgb/24
@color.purple        0x75 0x50 0x7b rgb/24
@color.darkPurple    0x5c 0x35 0x66 rgb/24
@color.lightBrown    0xe9 0xb9 0x6e rgb/24
@color.brown         0xc1 0x7d 0x11 rgb/24
@color.darkBrown     0x8f 0x59 0x02 rgb/24
@color.white         0xff 0xff 0xff rgb/24
@color.lightGrey     0xee 0xee 0xec rgb/24
@color.grey          0xd3 0xd7 0xcf rgb/24
@color.darkGrey      0xba 0xbd 0xb6 rgb/24
@color.lightCharcoal 0x88 0x8a 0x85 rgb/24
@color.charcoal      0x55 0x57 0x53 rgb/24
@color.darkCharcoal  0x23 0x34 0x36 rgb/24
@color.black         0x00 0x00 0x00 rgb/24

@color.gray      color.grey
@color.lightGray color.lightGrey
@color.darkGray  color.darkGrey

@doc.ValueSealing
"AO allows seal/unseal actions to be hard-coded using inline ABC. These are represented as:
 
     %{$foo}       seal value with sealer 'foo'
     %{/foo}       unseal value from sealer 'foo'
 
 The token 'foo' may be replaced by any arbitrary text. A sealed value cannot be observed or manipulated without first unsealing it with the same token. Of course, hard-coded tokens are not secure. (Secure value sealing involves construction of unique sealer/unsealer pairs.) To avoid even the illusion of security, and to simplify debugging, hard-coded sealers should favor simple, self-documenting tokens.
 
 Despite being insecure, hard-coded sealers are useful. They simplify reasoning and search for which code can access a value. They help document that some intermediate structures from an API are intended to be private or opaque. Introducing a new token for a test can help developers enforce parametricity. Value sealing can guard against accidental bindings, similar to 'newtype' in some other languages.
~

@doc.prefix.seal "seal the first item on the stack"
@doc.prefix.unseal "unseal the first item on the stack"

@doc.seal "guard a value against accidental observation"
@doc.unseal "unseal a value guarded by 'seal'"
@seal [%{$0}] .apply
@unseal [%{/0}] .apply

@doc.applyWithAdverbs
"AO includes experimental syntactic sugar for inflection with user-defined adverbs. AO takes a word like `foo\*kd` and expands it to `[foo] [\*kd] applyWithAdverbs`. The code `\*kd` itself is syntactic sugar for sequence of words `\* \k \d`, similar to expansion of inline ABC - except these special words are user-defined. Inflection is limited to a single character per adverb, but this isn't a severe limitation. Inflection achieves utility through flexible, ad-hoc combination specific to the site of use. 
 
 The word `applyWithAdverbs` also defined via dictionary, enabling adaptation to non-standard environment models. The typical definition is `apply inline`, which will apply the adverbs in a pure, context-free environment then inline the word.
 
 *NOTES:* Adverbs are potentially useful for minor data shuffling (dip, swap, first, left, deep applications), currying, quoting a word, collection-oriented programming (map, fold, etc.), quoting words without explicit blocks, and so on. It will take time to see whether this is a worthwhile feature to keep. As an experimental feature, adverbs may eventually be deemed not worth the small amount of complexity they add.
~
@applyWithAdverbs apply inline

@doc.adverb.@ "\@ will fixpoint a function; see @doc.fixpoint"
@doc.adverb.* "\* will map a function of type [x--y] across a list"
@doc.adverb.f "\f will fold a function of type [x--] across a list; the entire environment (minus the list argument) becomes the fold state"
@doc.adverb.k "\k will copy the first item on the stack before applying"
@doc.adverb.d "\d will hide first item on stack before applying"
@doc.adverb.H "\H will enforce clean hands; hide hand before applying"
@doc.adverb.P "\P will apply to a single argument in empty environment"
@doc.adverb.y "\y will set the function to curry its first argument"
@doc.adverb.? "\? will apply only for a true condition, uses 'rightE'"
@doc.adverb.' 
"\' will quote or reify the word, resulting in a block on the stack.
 
     foo\xyz' = [foo\xyz]
 
 This is only a minor syntactic convenience, but may result in a less noisy or more legible syntax. If used, quotation should usually be the last adverb.
~

@\@ fixpoint
@\* [map] bind
@\f [each] bind
@\P [apply] bind
@\d [dip] bind
@\H [hdip] bind
@\k [keep] bind
@\y curry
@\' quote 
@\? [leftE] bind

@id.swapd_adverb swapd swap\d

@doc.CompositionIsFirstPrinciple
"Every compositional model consists of a trinity: components, operators, and properties. Compositional operators are algebraically or categorically closed; they combine two components into a third component. Compositional properties are invariant or inductive over the operators. The set of components may be domain specific (such as diagrams, documents, sounds, and scene-graphs) or more general purpose (such as functions, arrows, matrices, grammars). 
 
 Composition is useful as a formal foundation for scalability and modularity. Compositional properties enable developers to reason about components without knowledge of the implementation details. Composition operators are also convenient due to their uniformity, i.e. we aren't forced to develop or learn a new language or interface for every object.
 
 Many models in common practice - including state machines, records, process loops, nominative types, conventional conditional expressions, even parametric abstraction - are not compositional. 
 
 Compositional alternatives are available. Grammars can operate as state machines (via parsing). Datalog or relational algebras generalize records. Processes can be compositional if we instead model them as partial and incremental (i.e. small-step processes; `µP.a→(P*b)`). Nominative types can be replaced with structural types. If/then/else and ad-hoc pattern-case conditional expressions can be replaced with a structural sum types. Ad-hoc parametric abstraction can often be replaced with staging and a reader monad.
 
 Awelon project strongly favors compositional models and designs. This should be reflected in AO's dictionaries and ontologies. I ask that all AO developers embrace composition as first design principle, pervasively, with priority above other features.
 
 Effective use of composition often requires domain-specific tradeoffs between the three aspects. For example, by limiting what we talk about (just diagrams) we can achieve more specialized properties (e.g. bounding areas, efficient occlusion) and more operators (add, scale, rotate, translate, etc.). It is possible to switch between compositional models primarily by layering them, such that the output of one compositional model becomes another compositional model. At a lower layer, a generic compositional model enables integration of domain-specific models.
 
 AO is designed to serve as that generic compositional layer. AO's words are software components. AO's compositional properties - especially causal commutativity, spatial idempotence, and capability security - are very useful in this role. AO is also designed to mitigate common weaknesses of deeply layered abstractions by aggressive use of partial evaluation, dependent type analysis, and program search.
~


