@doc.MakingWithBlocks
"A block in AO consists of code wrapped in square brackets, of form: `[put swap take]` or `[2 add]`. The meaning of a block is a first-class function that may be applied later. Blocks are essential in AO for:
 
 * representing loop behaviors by copying and applying blocks
 * modeling conditional behavior, apply block on just one branch
 * direct models of higher order programs and behavioral abstraction
 * transporting access and authority to resources and side-effects
 
 Best practices for use of blocks have not fully been established. Awelon project favors compositional abstractions to such an extent that use of ad-hoc parametric abstraction is discouraged. (See @doc.FirstPrincipleIsComposition.) My expectation is that blocks will be de-emphasized for behavioral abstraction in favor of indirect mechanisms - e.g. structured DSLs, symbolic expressions, free monads, staged programming. In this sense, AO would discourage conventional 'functional programming' in favor of a more 'language oriented programming'.
 
 Nonetheless, blocks remain essential for loops, effects, and conditions. Also, blocks make an effective compilation target, an alternative to interpretation, and they can help an embedded DSL model corner cases.
 
 Blocks can be composed.  Composition working together with quotation can also model such features as partial, concurrent, and conditional application.
 
     compose :: [x→y] [y→z] -- [x→z]      (sequential)
     bind    :: x [x--y] -- [--y]         (partial)
     .bind   :: x [(x*y)→z] -- [y→z]      (partial)
     .bfirst :: [x→y] -- [(x*e)→(y*e)]    (concurrent)
     .bleft  :: [x→y] -- [(x+e)→(y+e)]    (conditional)
 
 Some readers might be familiar with the notions of 'first' and 'left' from John Hughes' arrow model, which was an important foundation for AO and RDP. The primitive forms of '.curry' and '.bfirst', etc.. aren't very useable in the standard environment, but derived forms will also be available. 
 
 In addition, blocks may be constructed by quotation of a value:
 
     quote   :: (Quotable x) ⇒ x -- [-- x]
     unquote :: [-- x] -- x
 
 After construction, blocks can be applied in various ways. Developers will mostly use 'apply', which applies a block to the current environment except for the hand. Items in the current hand are hidden. But there are other operations that include (potentially) useful patterns for data hiding and application.
 
     .apply :: x [x→y] -- y ; apply block to just top object on stack
     apply  :: x [x--y] -- y; apply block to just top object on stack
       this variation provides a fresh stack and empty hand
       (the powerblock, named stacks, etc. are hidden)
     applyNtoM :: takes N arguments on stack, generates M results
       provides an empty hand, like apply, for N,M=1..4
     applyS :: apply to full stack (hiding rest of environment)
     dip    :: h [] -- ; apply block to all except top element on stack
     dip2   :: h1 h2 [] -- ; apply block to all except top two elements
     hdip   :: [] -- ; apply block hiding current hand 
     inline :: [] -- ; apply block as if inline (hand is visible)
     keep   :: x [x -- y] -- y x; copies element on stack
 
 The set of application words will undoubtedly evolve with experience.
 
 Todo: add common bi/tri variants from Factor's vocabulary
~

@doc.compose "[x→y] [y→z] -- [x→z]; compose functions"
@doc.composel "[y→z] [x→y] -- [x→z]; compose on left"
@doc.wrapfn "[x→y] [w→x] [y→z] -- [w→z]; wrap a function"

@compose p %rrol
@composel swap compose
@prepose composel
@wrapfn swapd compose compose
@.apply p %rr$l
@apply %rwrzvrwvvrrvrrz$wlcllccwlcl
@applyS %rwvvrrwvrrz$wlcwllcc
@dip %rwrzvrwr$wlcl
@hdip reifyHand putd dip take restoreHand
@inline %rvr$c
@keep dupd dip

@dip2 dpw dip  wx
@dip3 dpw dip2 wx
@dip4 dpw dip3 wx
@dip5 dpw dip4 wx
@dip6 dpw dip5 wx
@dip7 dpw dip6 wx
@keep2 take dup2 put dip2
@keep3 take dup3 put dip3
@keep4 take dup4 put dip4

@apply1to1 apply
@apply1to2 [pw] compose apply1to1 wx 
@apply1to3 [pw] compose apply1to2 wx
@apply1to4 [pw] compose apply1to3 wx
@apply2to1 compressArgs apply1to1
@apply2to2 compressArgs apply1to2
@apply2to3 compressArgs apply1to3
@apply2to4 compressArgs apply1to4
@apply3to1 compressArgs apply2to1
@apply3to2 compressArgs apply2to2
@apply3to3 compressArgs apply2to3
@apply3to4 compressArgs apply2to4
@apply4to1 compressArgs apply3to1
@apply4to2 compressArgs apply3to2
@apply4to3 compressArgs apply3to3
@apply4to4 compressArgs apply3to4
@compressArgs dpw [wx] composel

@apply0to1 %rvvvrrvrrz$wlcllccwlcl
@apply0to2 [pw] compose apply0to1 wx
@apply0to3 [pw] compose apply0to2 wx
@apply0to4 [pw] compose apply0to3 wx

@test.apply4to2 
  2 3 4 5 [.add unrot .add] apply4to2 
  5 assertEQ1 swap 
  9 assertEQ1 

@id.apply.id [id] apply
@id.compose [id] compose
@id.swap.compose [id] swap compose
@id.inline.id [id] inline

@doc.preApply "a→((a*1)*(1*1)); wrap argument in `apply` environment"
@doc.postApply "((a*1)*(1*1))→a; unwrap result from `apply` environment"
@doc.apwrap "[a -- b] -- [a→b]; apply 1:1 stack function in `apply` environment"
@preApply %vvvr
@postApply %lccc
@applyWrap [preApply] [postApply] wrapfn

@doc..first "(a*b) [a→a'] -- (a'*b)"
@doc..second "(a*b) [b→b'] -- (a*b')"
@doc..both "(a*b) [a→a'] [b→b'] -- (a'*b')"
@.first take x put .apply p
@.second take pw put .first pw
@.both take .first put .second

@eqv.cca [.both] [swap take2 pw put2 .both pw]

@doc..bind "x [(x*y)→z] -- [y→z]; bind argument into pair"
@doc.bind "x [x -- z] -- [-- z]; bind argument onto stack"
@doc..curry "[(x*y)→z] -- [x→[y→z]]; curry pair argument"
@doc.curry "[x--z] -- [x--[--z]]; curry stack argument"
@doc..bfirst "[x→x'] -- [(x*y)→(x'*y)]"
@doc..bleft "[x→x'] -- [(x+y)→(x'+y)]"
@doc..bsecond "[y→y'] -- [(x*y)→(x*y')]"
@doc..bright "[y→y'] -- [(x+y)→(x+y')]" 
@doc..bapply "[x→x'] -- [((x*s)*e)→((x'*s)*e)]"
@.bind pw %rr'wol
@bind [%l] composel swap %r'l composel

@bind2 bind bind
@bind3 bind bind bind
@bind4 bind bind bind bind

@doc.bind2nd "x [x y -- z] -- [y -- z]"
@doc.bind3rd "w [w x y -- z] -- [x y -- z]"
@doc.bind4th "v [v w x y -- z] -- [w x y -- z]"
@bind2nd [swap] composel bind
@bind3rd [unrot] composel bind
@bind4th [unroll] composel bind

@.curry [.bind] bind
@curry  [bind]  bind
@curry2 [bind curry] bind
@curry3 [bind curry2] bind
@curry4 [bind curry3] bind

@.bfirst %r' [%$] %rol
@.bsecond %r' [%vrw] %rwo [%$wlc] %rol
@.bleft %r' [%v] %rwo [%?c] %rol
@.bright %r' [%vVRW] %rwo [%?WLCc] %rol
@.bapply [.apply] bind

@test..bfirst 
 intro1 intro1 7 p p 
 [6 %r*] .bfirst .apply 
 x x 42 assertEQ
 drop2 elim1 elim1

@test..bsecond
 intro1 intro1 7 p pw 
 [6 %r*] .bsecond .apply 
 wx x 42 assertEQ
 drop2 elim1 elim1

@test..bleft.inL
 intro1 7 p inL
 [6 %r*] .bleft .apply
 not assert x 42 assertEQ
 drop2 elim1

@test..bleft.inR
 intro1 7 p inR
 [6 %r*] .bleft .apply
 assert x 7 assertEQ
 drop2 elim1

@test..bright.inR
 intro1 7 p inR
 [6 %r*] .bright .apply
 assert x 42 assertEQ
 drop2 elim1

@test..bright.inL
 intro1 7 p inL
 [6 %r*] .bright .apply
 not assert x 7 assertEQ
 drop2 elim1

@doc.bi 
"apply two blocks to one argument.
 
     [p] [q] bi 
        is equivalent to
     [p] keep q
 
~
@bi [keep] dip inline
@bi.blockFree rot dup dp swap rot dip wx inline

@test.bi
 6 [5 .add] [7 .mul] bi
 42 assertEQ1 swap
 11 assertEQ1 swap

@doc.bi2 
"apply two blocks each to same two arguments.
 
     [p] [q] bi2 
        is equivalent to
     [p] keep2 q
 
~
@doc.bi3 "apply two blocks each to same three arguments"
@bi2 [keep2] dip inline
@bi3 [keep3] dip inline
@test.bi2
 6 7 [.add] [.mul] bi2
 42 assertEQ1 swap
 13 assertEQ1 swap

@doc.tri "[p] [q] [r] tri = [p] keep [q] keep r; apply 3 blocks to same 1 arg"
@doc.tri2 "apply 3 blocks to the same 2 args"
@doc.tri3 "apply 3 blocks each to the same 3 args"
@tri [keep] dip2 bi
@tri2 [keep2] dip2 bi2
@tri3 [keep3] dip2 bi3
@test.tri2
 6 7 [.add] [.mul] [.square swap .square .add] tri2
 85 assertEQ1 unrot
 42 assertEQ1 unrot
 13 assertEQ1 unrot

@doc.bi* "apply 2 blocks each to respective input"
@doc.bi2* "apply 2 blocks each to 2 respective inputs"
@doc.bi3* "apply 2 blocks each to 3 respective inputs"
@doc.tri* "apply 3 blocks each to respective input"
@doc.tri2* "apply 3 blocks each to 2 respective inputs"
@doc.tri3* "apply 3 blocks each to 3 respective inputs"
@bi* [dip] dip inline
@bi2* [dip2] dip inline
@bi3* [dip3] dip inline
@tri* [dip2] dip2 bi*
@tri2* [dip4] dip2 bi2*
@tri3* [dip6] dip2 bi3*

@test.tri*
 6 7 8 [9 .add] [10 .mul] [11 .sub] tri*
 -3 assertEQ1 unrot
 70 assertEQ1 unrot
 15 assertEQ1 unrot

@test.tri2*
 6 7 8 9 10 11 [.mul] [.add] [.div] tri2*
 10/11 assertEQ1 unrot
 17 assertEQ1 unrot
 42 assertEQ1 unrot

@doc.bi& "apply a single block to two different inputs"
@doc.bi2& "apply a single block to two pairs of inputs"
@doc.bi3& "apply a single block to two triples of inputs"
@doc.tri& "apply a single block to three different inputs"
@doc.tri2& "apply a single block to three pairs of inputs"
@doc.tri3& "apply a single block to three triples of inputs"
@bi& dup bi*
@bi2& dup bi2*
@bi3& dup bi3*
@tri& dup2 tri*
@tri2& dup2 tri2*
@tri3& dup2 tri3* 

@doc.Quotable
"Most values in AO are quotable. 
 
 There are some unusual exceptions. For example, distributed values (e.g. a pair of which one value is computed at the GPU and another on the CPU) are not quotable. All values entering a quote must be observable at a common location, which is then inherited by the quotation.
 
 A quotation is simply a block that reproduces a value. This typically will have special support from the implementation, but will be serialized to code when necessary for display or networking.
 
 If a block with affine or relevant properties is quoted, the quote will inherit these properties. 
~
@doc.quote "(Quotable x) ⇒ x -- [--x]"
@doc.unquote "[--x] -- x"
@quote %r' [%l] %rol
@unquote apply0to1

@test.quote  7 dup quote unquote assertEQ1
@id.quoteUnquote quote unquote
@id.unquoteQuote unquote quote
@id.textDrop "text" drop

@doc.relevant "mark block on stack as relevant (not Droppable)"
@doc.affine "mark block on stack as affine (not Copyable)"
@doc.linear "mark block on stack as linear (neither Copyable nor Droppable)"
@relevant %rkl
@affine   %rfl
@linear   relevant affine

@eqv.commutative.affine&relevant [affine relevant] [relevant affine]
@eqv.idempotent.linear [linear linear] [linear]
@eqv.idempotent.affine [affine affine] [affine]
@eqv.idempotent.relevant [relevant relevant] [relevant]

@eqv.appTwice.compApp [compose apply] [unrot apply swap apply]
@eqv.inlineTwice.compInline [compose inline] [swap dip inline]
