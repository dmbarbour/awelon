std
@doc.import.ao "default root import for `ao` executable. See @doc.ao.utility ."

@doc.ao.utility
"The `ao` command line executable provides a number of non-interactive utilities (cf. `ao help`). Among these options is to execute an AO command string (e.g. `ao exec "6 7 * 42 assertEQ"`) or to incrementally execute AO or ABC code received via standard input. For the interactive form, use `aoi`.
 
 The program starts in the AO standard environment. The effects model is under development, but the current design aims to progress with Awelon project: the toplevel provides a few instantaneous actions, but mostly is used to install or update reactive demand programming behaviors in a manner similar to live programming (albeit, not entirely 'live'; the actual install is an imperative action). 
 
 Some effects available through the powerblock:
 
     obtain random numbers (cryptographic entropy)
     read and write files
     read environment variables 
     unsafely destroy any value (even relevant values)
     any annotation is also available as a command
 
 For specifics, see words with suffix `.io`.
 
 Under consideration:
 
     introspection of blocks
     confine evaluation to trap errors
     working with state resources (snapshots, resets, etc.)
     logical clocks and temporal values
     obtaining some useful 'child' powers
 
 Additionally, the `ao` utility supports various few annotations:
 
     debug output (printing to stderr)
     compilation of blocks (immediate, traced)     
 
 The default mode for `ao` is interpretation of ABC. However, compilation of blocks will eventually allow effective performance for real applications. Sadly, the compilation model currently leaks memory (the runtime keeps the object code in memory). But it should be sufficient for a lot of relatively static applications, and should work well with staged programming. 
~

@doc.debugPrintRaw "annotation to print top value from stack to stderr"
@doc.debugPrintText "annotation to print top text on stack to stderr (as text)"
@debugPrintRaw [{&debug print raw}] .apply
@debugPrintText [{&debug print text}] .apply

@debugPrintRaw.io "&debug print raw" p command.io
@debugPrintText.io "&debug print text" p command.io

@doc.command.io "invoke linear powerblock with (command*arg) message on stack"
@command.io %zwl .apply x %rwz

@doc.getOSEnv.io "text -- text; (io) read an OS environment variable"
@getOSEnv.io "getOSEnv" p command.io

@doc.randomBytes.io "count -- (list of octets); secure random source"

@randomBytes.io "randomBytes" p command.io
@rand8.io 1 randomBytes.io assert wx drop

@doc.readFile.io "filename -- (1(err) + text); (io)"
@doc.writeFile.io "text filename -- (1(err) + 1(ok)); (io)"

@readFile.io "readFile" p command.io
@writeFile.io p "writeFile" p command.io

@doc.destroy.io "(io) destroy will drop any input, including relevant blocks (unsafe)"
@destroy.io "destroy" p command.io elim1

@doc.tryCap.io " -- [([a→b]*a)→((emsg*a)+b)]; (io) obtain capability to confine error"
@tryCap.io intro1 "newTryCap" p command.io

@doc.tryWrap.io "[a→b]--[a→((emsg*a)+b)]; (io) modify a function to trap error"
@tryWrap.io tryCap.io .bind

@doc.tryApp.io 
"a [a→b] -- ((msg*a)+b); (io) attempt to apply, but isolate failure
 
 Failures primarily include failed assertions and type errors. On failure, an error message (meant for humans) is included with the original argument. There is no guarantee that side-effects are atomic, though they should be if feasible.
 
 The ability to isolate failure is considered a protected capability - in part for security reasons, but in larger part to simplify reasoning about static safety and partial failure of subprograms. By controlling this capability, a parent program can control which subprograms are allowed to partially fail and keep running. Developers are discouraged from using `try` except in special cases, such as when running runtime-generated untrusted code.
 
 Developers can access the 'try' capability separately from applying it, by use of 'tryCap.io'.
~
@tryApp.io p tryCap.io .apply





@doc.compile
"Awelon Bytecode (ABC) was designed with the assumption that it will be compiled to achieve acceptable performance. Awelon idioms place a heavy emphasis on staged programming, e.g. where developers might construct programs that construct programs, composing hundreds of blocks. In that context, ahead-of-time compilation often fares poorly. Various forms of dynamic or just-in-time compilation can offer excellent performance at the cost of some extra latency. 
 
 AO can provide access to compiled performance either implicity (through the VM) or explicitly (via annotations). The 'compile' word, presented here, applies an annotation to the block on the stack in order to compile it immediately. 
 
 CAUTION: In the `ao` and `aoi` utilities, compiled code is not garbage collected. This means developers must currently be conservative about using dynamic compilation based on runtime inputs.
~
@compile [{&compile}] .apply
@compile.io "&compile" p command.io

@doc.compile-trace
"This is a variation of @compile to interpret the block a few times until we have some confidence that the block is part of a loop - at which point we compile it in parallel and hot swap to the compiled form. This avoids some of the latency and premature optimization issues with dynamic compilation, but also will be a little less efficient in cases where we end up looping a lot or just a few extra times beyond the threshold.
~
@compile-trace [{&compile trace}] .apply
@compile-trace.io "&compile trace" p command.io

