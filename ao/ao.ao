std
@doc.import.ao "default root import for `ao` executable. See @doc.ao.utility ."

@doc.ao.utility
"The `ao` command line executable provides a number of non-interactive utilities (cf. `ao help`). Among these options is to execute an AO command string (e.g. `ao exec "6 7 * 42 assertEQ"`) or to incrementally execute AO or ABC code received via standard input. For the interactive form, use `aoi`.
 
 The program starts in the AO standard environment. The effects model is under development, but at this point its design is leaning towards the Awelon project design: the toplevel can be used for some instantanous actions, but all long-running behaviors are modeled by 'installing' and maintaining RDP behaviors (as a sort of live programming exercise). The toplevel won't be fully reactive, in this sense; the actual commit for an updated RDP behavior will be explicit. 
 
 But, ideally we can encourage a reactive view.
~

@doc.debugPrintRaw "annotation to print top value from stack to stderr"
@doc.debugPrintText "annotation to print top text on stack to stderr (as text)"
@debugPrintRaw [{&debug print raw}] .apply
@debugPrintText [{&debug print text}] .apply

@doc.iomsg.exec "invoke linear powerblock with message on stack"
@iomsg.exec %zwl .apply x %rwz

@doc.getEnv.exec "text -- text; (io) obtain environment variable"
@getEnv.exec "getOSEnv" p iomsg.exec

@doc.randomBytes.exec "count -- (list of octets); secure random source"
@randomBytes.exec "randomBytes" p iomsg.exec
@rand8.exec 1 randomBytes.exec assert wx drop

@doc.readFile.exec "(io) filename -- (1(err) + text)"
@doc.writeFile.exec "(io) text filename -- (1(err) + 1(ok))"
@readFile.exec "readFile" p iomsg.exec
@writeFile.exec p "writeFile" p iomsg.exec

@doc.destroy.exec "(io) destroy will drop any input, including relevant blocks (unsafe)"
@destroy.exec "destroy" p iomsg.exec elim1


