std
@doc.import.ao "default root import for `ao` executable. See @doc.ao.utility ."

@doc.ao.utility
"The `ao` command line executable provides a number of non-interactive utilities (cf. `ao help`). Among these options is to execute an AO command string (e.g. `ao exec "6 7 * 42 assertEQ"`) or to incrementally execute AO or ABC code received via standard input. For the interactive form, use `aoi`.
 
 The program starts in the AO standard environment. The effects model is under development, but the current design aims to progress with Awelon project: the toplevel provides a few instantaneous actions, but mostly is used to install or update reactive demand programming behaviors in a manner similar to live programming (albeit, not entirely 'live'; the actual install is an imperative action). 
 
 Some effects available through the powerblock:
 
     obtain random numbers (cryptographic entropy)
     read and write files
     read environment variables 
     unsafely destroy any value (even relevant values)
     any annotation is also available as a command
 
 For specifics, see words with suffix `.io`.
 
 Under consideration:
 
     introspection of blocks
     confine evaluation to trap errors
     working with state resources (snapshots, resets, etc.)
     logical clocks and temporal values
     obtaining some useful 'child' powers
 
 Additionally, the `ao` utility supports various few annotations:
 
     debug output (printing to stderr)
     compilation of blocks (immediate, traced)     
 
 The default mode for `ao` is interpretation of ABC. However, compilation of blocks will eventually allow effective performance for real applications. Sadly, the compilation model currently leaks memory (the runtime keeps the object code in memory). But it should be sufficient for a lot of relatively static applications, and should work well with staged programming. 
~

@doc.debugPrintRaw "annotation to print top value from stack to stderr"
@doc.debugPrintText "annotation to print top text on stack to stderr (as text)"
@debugPrintRaw [{&debug print raw}] .apply
@debugPrintText [{&debug print text}] .apply

@debugPrintRaw.io "&debug print raw" p command.io
@debugPrintText.io "&debug print text" p command.io

@doc.command.io "invoke linear powerblock with (command*arg) message on stack"
@command.io %zwl .apply x %rwz

@doc.getOSEnv.io "text -- text; (io) read an OS environment variable"
@getOSEnv.io "getOSEnv" p command.io

@doc.randomBytes.io "count -- (list of octets); (io) secure random source"

@randomBytes.io "randomBytes" p command.io
@rand8.io 1 randomBytes.io assert wx drop


@doc.Filesystem
"As command line utilities, `ao` and `aoi` offer some operations for working with the local filesystem through the power block. This is rather ad-hoc and minimal. In the long term, AO isn't primarily intended for manipulating the filesystem (instead favoring persistent, reactive state resources). 
 
 Most filesystem operations are asynchronous, meaning the powerblock is returned immediately even if the result takes a while to compute. However, reads and writes to the same filename are serialized.
~
@doc.readFile.io "filename -- (1(err) + text); (io,asynch)"
@doc.writeFile.io "text filename -- (1(err) + 1(ok)); (io,asynch)"
@doc.readBinaryFile.io "filename -- (1(err) + octets); (io,asynch)"
@doc.writeBinaryFile.io "octets filename -- (1(err) + 1(ok)); (io,asynch)"
@doc.listDirectory.io "dirname -- list-of-names; (io,asynch)"
@readFile.io "readFile" p command.io
@writeFile.io p "writeFile" p command.io
@readBinaryFile.io "readBinaryFile" p command.io
@writeBinaryFile.io p "writeBinaryFile" p command.io
@listDirectory.io "listDirectory" p command.io


@doc.destroy.io "(io) destroy will drop any input, including relevant blocks (unsafe)"
@destroy.io "destroy" p command.io elim1

@doc.tryCap.io " -- [([a→b]*a)→(a+b)]; (io) obtain capability to confine error"
@tryCap.io intro1 "newTryCap" p command.io

@doc.tryWrap.io "[a→b]--[a→(a+b)]; (io) modify a function to trap error"
@tryWrap.io tryCap.io .bind

@doc.tryAp.io 
"a [a→b] -- (a+b); (io) attempt to apply, but isolate failure
 
 Failures primarily include failed assertions and type errors. On failure, an error message (meant for humans) is included with the original argument. There is no guarantee that side-effects are atomic, though they should be if feasible.
 
 The ability to isolate failure is considered a protected capability - in part for security reasons, but in larger part to simplify reasoning about static safety and partial failure of subprograms. By controlling this capability, a parent program can control which subprograms are allowed to partially fail and keep running. Developers are discouraged from using `try` except in special cases, such as when running runtime-generated untrusted code.
 
 Developers can access the 'try' capability separately from applying it, by use of 'tryCap.io'.
~
@tryAp.io p tryCap.io .apply

@doc.simplify 
"block -- block; trivial simplifications on bytecode associated with block
 
 Note: This doesn't directly affect performance. The main reason to explicitly simplify a block is to make it easier to read in a REPL or similar. There is no guarantee that the block will be reinterpreted using its new code, e.g. it might have already been compiled or composed of precompiled blocks.
~
@simplify [{&simplify}] .apply
@simplify.io "&simplify" p command.io

@doc.asynch
"Awelon's design includes a 'causal commutativity' property, which is enforced by all Awelon effects models. Causal commutativity allows an arbitrary amount of parallelism, constrained only by dependencies between values. An AO or ABC implementation is free to infer or assume useful places for parallelism (e.g. loading or saving files, or compiling a block), but developers may also suggest parallelism through annotations. 
 
 `{&asynch}` is such an annotation: it marks that a block should compute asynchronously when subsequently applied. Semantically, `asynch` is an identity function for blocks. But it may potentially impact performance:
 
     {&asynch} :: block→block    (single input)
     asynch    :: block -- block (on stack)
 
 Note that `asynch` cannot model long-running behavior. Besides annotations being non-semantic and discretionary, Awelon requires and assumes termination for every subprogram. An unbounded loop is considered a bug. It would not be atypical for an Awelon runtime to wait for asynchronous operations to complete at certain stages - e.g. between REPL commands, or between paragraphs in a command stream. (Long-running behavior is instead modeled with RDP. Details elsewhere.)
~ 
@asynch [{&asynch}] .apply
@asynch.io "&asynch" p command.io
 
@doc.compile
"Awelon Bytecode (ABC) was designed with the assumption that it will be compiled to achieve acceptable performance. Awelon idioms place a heavy emphasis on staged programming, e.g. where developers might construct programs that construct programs, composing hundreds of blocks. While ahead-of-time compilation for AO is pretty good in many use cases, it fares poorly for staged programming. Dynamic or just-in-time compilation can offer excellent performance at the cost of some extra latency when compiling the code. 
 
 AO can provide access to compiled performance either implicity (through the VM) or explicitly (via annotations). The 'compile' word, presented here, uses an annotation to indicate a block should be compiled.
 
 CAUTION: In the current implementation of `ao` and `aoi` utilities, compiled code is never garbage collected. This means developers must currently be conservative about using dynamic compilation based on runtime inputs. Also, the compilation and loading overhead is enormous. Eventually, AO should have a runtime with fast compiles and garbage collection. But we're not there yet... and it might never happen for the Haskell implementation.
~
@compile [{&compile}] .apply
@compile.io "&compile" p command.io

