@doc.PrimitiveMath
"The intention is for AO to operate easily with units and matrices. The prefix '.' for math is used for primitive math operations on naked, scalar numbers. These operators include `.add`, `.mul`, `.neg`, `.inv`, `.divMod`, `.sub`, and `.div`. 
  
 More generally, AO will be leaning towards symbolic math libraries, i.e. such that we build expressions in a math DSL rather than directly compute results. This enables much richer analysis and optimization to be performed within the language, at expense of making it difficult to directly optimize the language (except by partial evaluation).
 
 The basic number type in is the exact rational number. However, ABC does not offer observation for the exact numerator or denominator of a rational number. Hence, the representation can vary some: programs could use inexact math in some cases, or an approach to exact math using lazy asymptotic bounds. Developers are free to annotate code requesting use of floating point numbers. Of course, annotations are discretionary, but I imagine many compilers will support it. ABC should never *silently* coerce to inexact math.
~

@.mul p %rr*l
@.add p %rr+l
@.neg %r-l
@.inv %r/l
@.divMod p %rrQll wx
@.quot .divMod nip
@.rem  .divMod drop
@.sub .neg .add
@.div .inv .mul
@.square dup .mul

@+ .add
@* .mul
@/ .div
@doc.÷ "This is unicode division, U+F7. Just because."
@÷ .div
@~ .neg
@doc.− "unicode minus, U+2212"
@− .sub
@- .sub

@inc 1 .add
@incd swap inc swap
@dec 1 .sub
@decd swap dec swap

@doc..mul "N(b) N(a) -- N(a*b)"
@doc..add "N(b) N(a) -- N(a+b)"
@doc..neg "N(a) -- N(-a)"
@doc..inv "N(a) -- N(1/a); a must be non-zero"
@doc..divMod "N(a) N(b) -- N(r) N(q) where a=q*b+r and r in (b,0] or [0,b)"
@doc..quot "just the quotient from .divMod"
@doc..rem "just the remainder from .divMod"
@doc..sub "N(a) N(b) -- N(a-b)"
@doc..div "N(a) N(b) -- N(a/b)"

@id.mul1 1 .mul
@id.div1 1 .div
@id.add0 0 .add
@id.sub0 0 .sub

@doc.fibonacci "N -- fib(N); the 'hello world' of functional programming ;)"
@fibonacci 1 0 [dup swapd .add] roll repeat dropd
@test.fibonacci 11 fibonacci 89 assertEQ1

@doc.useFloatingPoint32 "N--N; annotation; favor floating point with at least 32 bits"
@doc.useFloatingPoint64 "N--N; annotation; favor floating point with at least 64 bits"
@useFloatingPoint   assertNumber [{&useFloatingPoint32}] inline
@useFloatingPoint64 assertNumber [{&useFloatingPoint64}] inline


@doc.deprecated.assert
"(A lot of assertions need to be repaired after the monomorphic change to the `>` operator in April 2014).
  
     assertLT, assertLTE -- assert upper bounds for a comparable value
     assertGT, assertGTE -- assert lower bounds for a comparable value
 
 And common number assertions...
 
     assertInteger, assertNatural, assertNatural+  -- assertions on number types
     assertGTz, assertGTEz -- assert greater than or equal to zero
     assertEQz, assertNEQz -- assert equal or not equal to zero
     assertLTz, assertLTEz -- assert less than or equal to zero
     assertNatural -- integer greater than or equal to zero
     assertChar -- integer between 0 and 1114111 inclusive
     assertOctet -- integer between 0 and 255 inclusive
     assertProb -- rational number between 0 inclusive and 1 inclusive
     assertUniform -- rational number between 0 inclusive and 1 exclusive
 
 In an effectful program, some assertions may have dynamic nature. In that case, modulo use of capabilities designed to isolate failure, a dynamic assertion failure causes the whole program to be halted as quickly and cleanly as feasible.
~


@doc..gt  "a b -- ((a*b) + (b*a)); a > b?; for numbers a,b"
@doc..lt  "a b -- ((b*a) + (a*b)); a < b?; for numbers a,b"
@doc..gte "a b -- ((a*b) + (b*a)); a ≥ b?; for numbers a,b"
@doc..lte "a b -- ((b*a) + (a*b)); a ≤ b?; for numbers a,b"
@.gt  p %rr>l
@.lt  p %rrw>l
@.gte .lt not
@.lte .gt not

@gt  .gt
@lt  .lt
@gte .gte
@lte .lte

@doc..gt1 "a x -- (a + a); a > x?; for numbers a,x"
@doc..lt1 "a x -- (a + a); a < x?; for numbers a,x"
@doc..gte1 "a x -- (a + a); a ≥ x?; for numbers a,x"
@doc..lte1 "a x -- (a + a); a ≤ x?; for numbers a,x"
@.gt1 .lte1 not
@.lt1 .gte1 not
@.lte1 p %rr>  [.fst] %r? .mirror [.snd] %r?l
@.gte1 p %rrw> [.snd] %r? .mirror [.fst] %r?l

@gt1 .gt1
@lt1 .lt1
@lte1 .lte1
@gte1 .gte1

@doc..gtb "a x -- Bool; a > x?; for numbers a,x"
@doc..ltb "a x -- Bool; a < x?; for numbers a,x"
@doc..gteb "a x -- Bool; a ≥ x?; for numbers a,x"
@doc..lteb "a x -- Bool; a ≤ x?; for numbers a,x"
@.gtb .gt toBoolean
@.ltb .lt toBoolean
@.gteb .gte toBoolean
@.lteb .lte toBoolean

@gtb  .gtb
@ltb  .ltb
@gteb .gteb
@lteb .lteb

@doc.eq  "a b -- ((LT(a*b) + GT(b*a)) + EQ(b*a)); for numbers a,x"
@doc.neq "a b -- (EQ(b*a) + (LT(a*b) + GT(b*a))); for numbers a,x"
@eq neq not
@neq gt [%vr>c] .left %rRl

@doc.eq1 "a x -- ((a(<x) + a(>x)) + a(=x)); for numbers a,x"
@doc.neq1 "a x -- (a(=x) + (a(<x) + a(>x))); a ≠ x?; for numbers a,x"
@eq1 neq1 not
@neq1 neq %r [.snd] %r? %VRWR [.fst] %r? %W [.snd] %r? %WLWLC %l

@doc.eq1m "a x -- (a(≠x) + a(=x)); for numbers a,x"
@doc.neq1m "a x -- (a(=x) + a(≠x)); for numbers a,x"
@eq1m eq1 [%vMc] .left
@neq1m eq1m not

@doc.eqb "a b -- Bool; a = b?; for numbers a,x"
@doc.neqb "a b -- Bool; a ≠ b?; for numbers a,x"
@eqb eq toBoolean
@neqb neq toBoolean


@assertLT   lt assert wx
@assertLTE  lte assert wx
@assertGT   gt assert x
@assertGTE  gte assert x
@assertEQ.n   eq assert x
@assertEQ1.n  assertEQ drop
@assertNEQ  neq assert [%vrwlc] .left merge x

@doc.assertEQ1d.n "x y x -- x y; assert x's are equal, useful for testing"
@assertEQ1d.n   swapd assertEQ1 swap
@assertEQ1dd.n  rotd  assertEQ1 unrot
@assertEQ1ddd.n rolld assertEQ1 unroll

@assertLTz  0 assertLT drop
@assertLTEz 0 assertLTE drop
@assertGTz  0 assertGT drop
@assertGTEz 0 assertGTE drop
@assertEQz  0 assertEQ drop
@assertNEQz 0 assertNEQ drop

@doc..assertUnit "1→1; assert singular value is unit"
@.assertUnit %vvrwlcc

@assertUnit   elim1 intro1
@assertProd   w w
@assertSum    mirror mirror
@assertNumber 0 .add

@assertInteger  dup 1 .rem assertEQz drop
@assertNatural  assertGTEz assertInteger
@assertNatural+ assertGTz  assertInteger
@assertChar     assertNatural 0x10ffff assertLTE drop
@assertOctet    assertNatural 256 assertLT drop
@assertProb     assertGTEz 1 assertLTE drop
@assertUniform  assertGTEz 1 assertLT drop

@id.assertInR inR assert
@id..assertUnit .assertUnit
@id.assertLT assertLT
@id.assertLTE assertLTE
@id.assertGT assertGT
@id.assertGTE assertGTE
@id.assertEQ assertEQ
@id.assertNEQ assertNEQ
@id.assertLTz assertLTz
@id.assertGTz assertGTz
@id.assertGTEz assertGTEz
@id.assertLTEz assertLTEz
@id.assertEQz assertEQz
@id.assertInteger assertInteger
@id.assertNatural assertNatural
@id.assertNatural+ assertNatural+
@id.assertChar assertChar
@id.assertProb assertProb
@id.assertUniform assertUniform
