@doc.StandardEnvironment
"AO has many similarities with stack-based programming languages, such as Forth, Factor, and Joy. However, the environment for AO is a value structured of pairs, numbers, and blocks of code, similar in nature to Lisp cons cells. Typically, the tacit argument to any word has the form:
 
         (stack * environment)
 
 The stack here is used in a manner very similar to the Forth stack. Most relevantly, literals (text, numbers, blocks) all are pushed onto the stack.
 
         42 :: (s * e) →  ((Num(42)*s)*e)
 
 By pushing literals onto the stack, AO ensures the environment has a stable location. The environment then provides a useful place for secondary stacks, inventories, tools, and other values the developer might wish to keep on hand and accessible. The shape of the environment is NOT built into the AO language; rather, it is determined by shared conventions and de-facto standards in the AO dictionary.
 
 At the moment, the most frequently used environment shape just adds one auxillary stack, which I call the "hand". This takes the following form:
 
         (stack * (hand * unit))
 
 Developers can then `take` items from the stack to the hand, or `put` items from the hand to the stack, or sometimes use a copy & paste metaphor. The hand provides both a useful location to stash intermediate values, and a clipboard. Forth frequently uses the return stack in a similar manner. The unit value on the right can be replaced by further environment extensions.
 
 The following environment was developed early on, by thought experiment:
 
         (stack * (hand * (power * ((name * namespace) * unit))))
 
 Where:
 
   stack: the current stack, where most operations apply
   hand: the hand, auxillary stack, useful as temporary store & clipboard
   power: a powerblock, to observe or influence real world
   name: label of current stack, used when switching stacks
   namespace: stack of (label*value) pairs for workspaces and registers
 
 However, this hasn't seen more than shallow use in the dictionary and would be easy to replace. One concern with the above environment is that namespace manipulation is relatively difficult to optimize compared to anonymous data shuffling. I'm considering a variation of the above that provides an extra linear space of anonymous stacks, with `stepLeft` and `stepRight` movements:
 
         ____v__________    hand: 6 3 8
          1  3  7  5  4     
          2  4  8  2  6     
             5  9     1
             6
 
        > put stepRight take 0
 
              
         _______v_______    hand: 7 3 8
          1  6  0  5  4     
          2  3  8  2  6     
             4  9     1
             5
             6
 
 This is trivial to model with an additional pair of stacks, one containing stacks to the left and one containing stacks to the right. In addition to motion, we'd have the ability to create a new stack to the left or right, or erase one. The resulting environment, extending the main environment at this time, would have structure:
 
        (stack * (hand * ((stacksLeft*stacksRight) * unit))
 
 This would provide all the space a user needs for normal computations, i.e. without feeling squeezed into a single stack. As demonstrated above, it can also be easy to render in a REPL or on a screen... perhaps even has a bit of a video game feel. Extensions like the namespace would remain possible.
 
 At this time, AO hasn't truly settled on a standard environment. Rather than tying ourselves to anything in particular, we users should continue to experiment, explore, and find a convenient and comfortable design that covers most use cases. I suspect we'll want different environments for different programming media, e.g. text and REPL vs. VR or AR.
~

@reifyStack intro1 %rwl
@restoreStack %rwl elim1
@doc.reifyStack "(s*e)→((s*Unit)*e) : stack becomes object on fresh stack"
@doc.restoreStack "((s*Unit)*e)→(s*e) : single object on stack becomes stack"

@doc.wrap.stackHand.env "a → ((a*1)*(1*1)); wrap input in basic stack+hand environment."
@doc.unwrap.stackHand.env "((a*1)*(1*1)) → a; unwrap value on stack from clean stack+hand environment."
@doc.apply1to1.stackHand.env "a [a -- b] -- b; apply block to arg in clean stack+hand environment."
@doc.applyStoS.stackHand.env "..s [..s -- ..s'] -- ..s'; apply block to stack in clean stack+hand environment."
@wrap.stackHand.env      %vvvr
@unwrap.stackHand.env    %lccc
@apply1to1.stackHand.env %rwrzvrwvvrrvrrz$wlcllccwlcl
@applyStoS.stackHand.env %rwvvrrwvrrz$wlcwllcc
@apply0to1.stackHand.env %rvvvrrvrrz$wlcllccwlcl
@apply0to0.stackHand.env %rvvvrrvrrz$wlcllccc
@apply1to0.stackHand.env %rwrzvrwvvrrvrrz$wlcllccc

@doc.std.env 
"The 'std' standard environment is just a layer of indirection to whichever environment model developers wish to experiment with. Definitions for std.env should generally be a single word from another environment model.
 
 TODO: separate operations into something much more fine grained.
  single input wrap/unwrap
  wrap/unwrap single item on stack.
  wrap/unwrap full stack.
  intro/clear empty environment.
  push/pop from stack to/from environment.
 
 I can also provide a set of default functions.
~
@wrap.std.env           wrap.stackHand.env
@unwrap.std.env       unwrap.stackHand.env
@apply1to1.std.env apply1to1.stackHand.env
@applyStoS.std.env applyStoS.stackHand.env
@apply0to1.std.env apply0to1.stackHand.env
@apply0to0.std.env apply0to0.stackHand.env
@apply1to0.std.env apply1to0.stackHand.env

