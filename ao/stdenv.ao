@doc.StandardEnvironment
"AO is not a stack-based programming language, at least not in the traditional sense of having a data stack as a primitive feature. Words operate upon a tacit value, constructed mainly of pairs, numbers, and blocks. This tacit value, however, will typically represent a stack plus an extended, stable environment:
 
     (currentStack * extendedStableEnvironment)
 
 Here, `(a * b)` represents an ordered pair of `a` with `b`. The current stack is simply modeled using pairs. Literals in AO are functions that push their value onto the current stack:
 
     42 :: (s*e) → ((42*s)*e)
 
 This maps trivially to ABC code `#42l`. It is useful to understand that this structure really is a plain old value. The stack metaphor is built into literals, but the shape of the extended stable environment is much more accessible. Programmers are free to develop ad-hoc conventions for the shape of the extended environment. Further, different environments can easily be used for different subprograms (especially at locations that choke the number of inputs and outputs). 
 
 The so-called 'standard' environment is simply a set of proposed conventions, embedded in the common words. There are, thus far, two standard environments: an apply environment, and a toplevel multi-stack environment. These share part of their structure:
 
     apply env       :: (s * (h * ex))
     multi-stack env :: (s * (h * (pb * ((sn * rns) * ex))))
 
 Where:
   s: the current stack, where most operations apply
   h: the hand, auxillary stack, useful as temporary store & clipboard
   pb: a powerblock, to observe or influence real world
   sn: name of current stack, used when switching stacks
   rns: record of (name*stack) pairs for workspaces and registers
   ex: an extensions slot, default value 'unit'
 
 The apply environment is typically created by the apply word and its many cousins (e.g. apply3to2). It is primarily used for purely functional subprograms, e.g. to control how many inputs a given block can access. The hand is an auxillary stack, useful to keep values out of the way. In general, words should exercise a clean hands policy: assume they start with an empty hand, and end with an empty hand (obviously excepting take, put, copy, paste, juggle, and other hand-manipulation words). The apply word will enforce clean hands.
 
 The toplevel, multi-stack environment is the typical starting environment for a potentially effectful AO program. It extends the apply environment with a 'powerblock' (a block that contains capabilities to observe or influence the real world), plus a collection of named stacks. Named stacks can serve as registers or workspaces. It can be useful to switch between multiple stacks when modeling concurrent tasks (see @doc.ConcurrencyInAO). The initial stack name is the empty string "". 
 
 Stack manipulations are often described using 'stack effect' strings, as used in Factor or Forth. For example, "x y z -- y x z" suggests that the top item on the current stack (z) remains in place, and the elements below it are swapped. Such annotations are for documentation purposes, e.g. in a separate word like `doc.swapd`. (AO does not have any built-in support for type description, beyond assertions and merges. Eventually, there may be a `type.` prefix for certain kinds of symbolic validation.)
 
 NOTE: The current standard environments share a weakness: they are not readily composable. There is no sensible, general way to combine two stacks. They must instead be kept separate, e.g. constructing a fresh environment for each subprogram, injecting only a few inputs and extracting only a few results. In general, composition will instead occur in other layers. At some point, it may be worth exploring alternative conventions that achieve more composable environments, e.g. based on mashable documents, scene-graphs, and zippers, perhaps wielding an inventory of recomposable tools and lenses.
~

@reifyStack intro1 %rwl
@restoreStack %rwl elim1
@doc.reifyStack "(s*e)→((s*Unit)*e) : stack becomes object on fresh stack"
@doc.restoreStack "((s*Unit)*e)→(s*e) : single object on stack becomes stack"

@doc.swapStackName "newSN -- oldSN; replace name for current stack"
@doc.setStackName "SN -- ; set name for the current stack"
@doc.getStackName "-- SN ; get name for current stack"
@swapStackName %lzrzrzwrwzwlwzlzlzr
@setStackName swapStackName drop
@getStackName intro1 swapStackName copy swapStackName elim1 put
@id.swapStackName swapStackName swapStackName
@id.getSetStackName getStackName setStackName

@doc.swapPowerBlock "power -- power; replace powerblock in standard env"
@swapPowerBlock %zrwzwlz
@id.swapPowerBlock swapPowerBlock swapPowerBlock

@doc.EnvironmentManipulation
"AO developers aren't limited to a single instance of the standard environment. Subprograms may be computed in their own complete environments, and objects may be shifted from one environment to another (using the hand, by default, for data shuffling). 
 
 Developers can:
 
 * create a fresh, empty environment on the stack (introE)
 * safely destroy an empty environment on the stack (elimE)
 * swap current environment with environment on stack (swapE)
 
 When swapping environments, the current hand and powerblock will follow the user. Moving objects between environments involves use of the hand. A initial stack name for an environment is simply the empty string (which is equivalent to number 3). 
~

@doc.introE "adds empty environment object to stack"
@doc.elimE "deletes empty environment object ('drop' also works, but less safe)"
@doc.swapE "switch current environment with env on stack; keep hand and power"
@introE "" %r %vrvrwvrr %vrwlc %l
@elimE  %r %vrwlc %llcwlclc %l drop
@swapE %zrzwlz %vrwlc %zrwzl

@id.introElimE introE elimE
@id.swapE swapE swapE


