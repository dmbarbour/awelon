% limiting to avmboot so I can use this in bootstrap
import avmboot

% Awelon's standard environment is a list of stacks and a pair of 
% hands:
%
%          STACKS   * HANDS
%       (sL*(sC*sR))*(lH*rH)  
%            |            |- primary hand  
%            |-current stack
% 
% The list of stacks is represented as a list-zipper, meaning that
% `sR` and `sL` are actually modeled as stacks of stacks. But the
% navigation `stepLeft` and `stepRight` provide the intuition of a
% list. 
%
% The left and right hands are also stacks. They allow the intuition
% of carrying things from one stack to another. The right hand is used
% for volatile operations and anonymous objects, primarily take and put.
% The left hand is used for special extensions, and doesn't get much
% attention in this module.  
%
% Only the following primitive behaviors are necessary to bootstrap 
% Awelon's standard environment and operations:
%
%   first      :: (Block(x~>y) * x) ~> y 
%   swap       :: (x * y) ~> (y * x)
%   assocl     :: (x * (y * z)) ~> ((x * y) * z)
%   intro1     :: x ~> (Unit * x)
%   elim1      :: (Unit * x) ~> x
%   rot3       :: (a * (b * (c * d))) ~> (c * (a * (b * d)))
%
% The last element, 'rot3', was introduced as a primitive to support
% a block-free encoding of the basic environment manipulations. This
% is important: we cannot reasonably add blocks to the current stack
% while arranging items on said stack, or navigating to a different
% one! 
% 
% A rather unusual point is that the primitive 'first' only works if
% the block is fully outside the environment. Applying a block involves 
% extracting the block and its argument outside the environment, using
% 'first', then restoring the results to the correct location. These
% convolutions are the price of language minimalism. Fortunately, they
% are optimized away at compile time (it's an easy optimization).
% 
% Indeed, everything in this module can be optimized away. The whole 
% concept of an 'environment' in Awelon is there for the programmer, 
% not for the runtime.

% Environment Agnostic Data Plumbing 
%
assocr = swap assocl swap assocl swap               % reverse of assocl
rot2 = intro1 rot3 intro1 rot3 elim1 elim1          % simple rotate of two elements
rot4 = assocl rot3 rot2 assocr rot3                 % simple rotate of four elements
rot5 = assocl rot4 rot2 assocr rot3                 % simple rotate of five elements
rot6 = assocl rot5 rot2 assocr rot3                 % simple rotate of six elements
zip2 = assocr rot3 rot2 assocl                      % firsts with firsts, seconds with seconds
second = assocl swap rot2 first swap                % operate on second element

% Environment Specific Data Plumbing
%
juggle2 = assocl rot3 rot2 assocr                   % rotate two elements in right hand
juggle3 = assocl juggle2 assocr juggle2             % rotate three elements in right hand
juggle4 = assocl juggle3 assocr juggle2             % rotate four elements in right hand
juggle5 = assocl juggle4 assocr juggle2             % rotate five elements in right hand
juggle6 = assocl juggle5 assocr juggle2             % rotate six elements in right hand
_insert = rot2 swap rot3 rot2 zip2 rot3 rot3 swap   % outside env to top of current stack
_extract = swap rot3 zip2 rot3 rot2 swap rot2       % top of current stack to outside env
take = _extract rot3 rot3                           % from current stack to right hand
put = rot3 _insert                                  % from right hand to current stack
swapHands = assocl swap rot2                        % switch right and left hands
swapStack = swap zip2 rot3 rot2 zip2 swap           % switch current stack right hand stack 

roll2 = swap rot3 swap rot3 rot2 swap rot3 rot3 swap % rotate two elements in current stack
roll3 = take roll2 put roll2                        % rotate three elements in current stack
roll4 = take roll3 put roll2                        % rotate four elements in current stack
roll5 = take roll4 put roll2                        % rotate five elements in current stack
roll6 = take roll5 put roll2                        % rotate six elements in current stack
stepLeft = assocr zip2 rot2 assocl                  % move to stack on left (must exist)
stepRight = assocr rot2 zip2 assocl                 % move to stack on right (must exist)
newStack = swap assocl intro1 rot3 rot3 assocr swap % create empty stack at user's right
remStack = swap assocl rot3 elim1 assocr swap       % remove empty stack at user's right
intro1S = intro1 _insert                            % add unit to top of stack
elim1S = _extract elim1                             % remove unit from top of stack


% Structural Operators: 
%
% 'expand2' will break a pair on the stack into two stack elems.
% 'shrink2' will combine two stack elements into a pair on the stack
%
% Higher numbered variations allow breaking apart 'deeper' structures.
% E.g. (a*(b*(c*d))) can be broken into four elements by use of expand4.
% OTOH (((a*b)*c)*d) can be broken using expand2 three times.
%
% Combined with take, put, a little rolling or juggling, developers 
% should be able to pick apart any structure they need to pick apart.
%
expand2 = swap rot3 swap rot2 assocr rot3 swap rot3 rot3 swap
expand3 = expand2 take expand2 put
expand4 = expand2 take expand3 put
expand5 = expand2 take expand4 put
expand6 = expand2 take expand5 put
shrink2 = swap rot3 swap rot3 rot3 assocl rot2 swap rot3 rot3 swap
shrink3 = take shrink2 put shrink2
shrink4 = take shrink3 put shrink2
shrink5 = take shrink4 put shrink2
shrink6 = take shrink5 put shrink2

% Environment Manipulations
%
%  wrapE - wrap a value in a fresh environment; wrapped value becomes
%    the only element in a fresh env's current stack. If `wrapE` is 
%    called without a specific target, it captures the current 
%    environment.
%  wrapS - capture current stack as a value, which is afterwards the
%    only value on the current stack. 
%  unwrapE/unwrapS - reverse these manipulations.
%
% The normal block applicators will wrap a new environment around the
% arguments before applying the block. This allows subprograms to use
% the multi-stack and hands concept, but prevents accidental coupling
% with the current environment. 
%
wrapE = intro1 swap intro1 swap intro1 intro1 intro1 assocl swap
unwrapE = swap assocr elim1 elim1 elim1 swap elim1 swap elim1
wrapS = assocr intro1 rot3 zip2 assocl rot2 assocl
unwrapS = swap rot3 assocr rot2 elim1 rot3 rot3 swap

% Block Applicators
%
%  These operators remove and apply a block from the top of the stack.
%
%   appX - apply block directly to first element of stack (no wrapE)
%   appE - apply to full current environment (as if block is inlined)
%   ap   - apply to top element of current stack in fresh env
%   app  - apply to top TWO elements of the current stack in fresh env
%
%  In addition, developers can specify a deep locator for ap and app,
%  such as `apsfs` (second-first-second). This specifies part of one
%  argument. In (a*b)*((c*(d*e))*f), 'apf' would identify (a*b), 'apfs' 
%  would locate 'b'. 'apsfs' locates (d*e). Locators are provided up
%  to four deep.
%
%  For 'app' the locator's target is the second element on the stack
%  (originally the third, before removing the block). The target will
%  also be arranged below the extra argument in the target stack.
%
%  Upon returning from 'ap' or 'app' the target and potential extra 
%  argument are restored to their original locations. They may have
%  been modified.
%   
% 
appX = _extract rot2 _extract rot3 first _insert
appE = _extract intro1 swap assocr first swap elim1 
app = take take _appH put  
ap  = take _apH 
_apH  = [wrapE] appX put appX [unwrapE] appX % block in hand
_appH = put shrink2 [wrapE expand2] appX put appX % arg,block in hand
        [shrink2 unwrapE] appX expand2 take  % return arg to hand

apf = take _xf _apH _rf
aps = take _xs _apH _rs

apff = take _xff _apH _rff
apfs = take _xfs _apH _rfs
apsf = take _xsf _apH _rsf
apss = take _xss _apH _rss

apfff = take _xfff _apH _rfff
apffs = take _xffs _apH _rffs
apfsf = take _xfsf _apH _rfsf
apfss = take _xfss _apH _rfss
apsff = take _xsff _apH _rsff
apsfs = take _xsfs _apH _rsfs
apssf = take _xssf _apH _rssf
apsss = take _xsss _apH _rsss

apffff = take _xffff _apH _rffff
apfffs = take _xfffs _apH _rfffs
apffsf = take _xffsf _apH _rffsf
apffss = take _xffss _apH _rffss
apfsff = take _xfsff _apH _rfsff
apfsfs = take _xfsfs _apH _rfsfs
apfssf = take _xfssf _apH _rfssf
apfsss = take _xfsss _apH _rfsss
apsfff = take _xsfff _apH _rsfff
apsffs = take _xsffs _apH _rsffs
apsfsf = take _xsfsf _apH _rsfsf
apsfss = take _xsfss _apH _rsfss
apssff = take _xssff _apH _rssff
apssfs = take _xssfs _apH _rssfs
apsssf = take _xsssf _apH _rsssf
apssss = take _xssss _apH _rssss

appf = take take _xf _appH _rf put
apps = take take _xs _appH _rs put

appff = take take _xff _appH _rff put
appfs = take take _xfs _appH _rfs put
appsf = take take _xsf _appH _rsf put
appss = take take _xss _appH _rss put

appfff = take take _xfff _appH _rfff put
appffs = take take _xffs _appH _rffs put
appfsf = take take _xfsf _appH _rfsf put
appfss = take take _xfss _appH _rfss put
appsff = take take _xsff _appH _rsff put
appsfs = take take _xsfs _appH _rsfs put
appssf = take take _xssf _appH _rssf put
appsss = take take _xsss _appH _rsss put

appffff = take take _xffff _appH _rffff put
appfffs = take take _xfffs _appH _rfffs put
appffsf = take take _xffsf _appH _rffsf put
appffss = take take _xffss _appH _rffss put
appfsff = take take _xfsff _appH _rfsff put
appfsfs = take take _xfsfs _appH _rfsfs put
appfssf = take take _xfssf _appH _rfssf put
appfsss = take take _xfsss _appH _rfsss put
appsfff = take take _xsfff _appH _rsfff put
appsffs = take take _xsffs _appH _rsffs put
appsfsf = take take _xsfsf _appH _rsfsf put
appsfss = take take _xsfss _appH _rsfss put
appssff = take take _xssff _appH _rssff put
appssfs = take take _xssfs _appH _rssfs put
appsssf = take take _xsssf _appH _rsssf put
appssss = take take _xssss _appH _rssss put

_xf = expand2       % expose first
_xs = expand2 roll2 % expose second

_xff = _xf _xf
_xfs = _xf _xs
_xsf = _xs _xf
_xss = _xs _xs

_xfff = _xff _xf
_xffs = _xff _xs
_xfsf = _xfs _xf
_xfss = _xfs _xs
_xsff = _xsf _xf
_xsfs = _xsf _xs
_xssf = _xss _xf
_xsss = _xss _xs

_xffff = _xfff _xf
_xfffs = _xfff _xs
_xffsf = _xffs _xf
_xffss = _xffs _xs
_xfsff = _xfsf _xf
_xfsfs = _xfsf _xs
_xfssf = _xfss _xf
_xfsss = _xfss _xs
_xsfff = _xsff _xf
_xsffs = _xsff _xs
_xsfsf = _xsfs _xf
_xsfss = _xsfs _xs
_xssff = _xssf _xf
_xssfs = _xssf _xs
_xsssf = _xsss _xf
_xssss = _xsss _xs

_rf = shrink2        % restore first
_rs = roll2 shrink2  % restore second

_rff = _rf _rf
_rfs = _rs _rf
_rsf = _rf _rs
_rss = _rs _rs

_rfff = _rf _rff
_rffs = _rs _rff
_rfsf = _rf _rfs
_rfss = _rs _rfs
_rsff = _rf _rsf
_rsfs = _rs _rsf
_rssf = _rf _rss
_rsss = _rs _rss

_rffff = _rf _rfff
_rfffs = _rs _rfff
_rffsf = _rf _rffs
_rffss = _rs _rffs
_rfsff = _rf _rfsf
_rfsfs = _rs _rfsf
_rfssf = _rf _rfss
_rfsss = _rs _rfss
_rsfff = _rf _rsff
_rsffs = _rs _rsff
_rsfsf = _rf _rsfs
_rsfss = _rs _rsfs
_rssff = _rf _rssf
_rssfs = _rs _rssf
_rsssf = _rf _rsss
_rssss = _rs _rsss


