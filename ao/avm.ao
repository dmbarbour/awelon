% Awelon Virtual Machine definition module 'avm'
%  v0.01
%  David Barbour, 2013 August

import avmboot,stdenv

% The task of this module is to provide a description of Awelon's
% primitive behaviors to the compiler or interpreter. This must
% include the bootstrap primitives. 
%
% At the moment, there are two issues I need to address:
% 
%   1) decide what primitives to describe
%   2) decide how to describe these primitives
%
% Regarding the latter point, I think one feature I want is a behavior
% to compute the typerep of the output given the typerep of the input.
% In addition, I want english descriptors. But for the moment I could
% limit it to just some descriptors and names!
% 
%
%   primitive behaviors
%     basic data plumbing (first, assocl, swap, rot3, intro1, elim1)
%     types are represented as blocks operating on typerep
%
%   partitions: perhaps support inheritance... or partitions like
%     typeclasses, partition types can inherit properties or prims
%     of another, just to avoid repetition.
%
%   support for ad-hoc type attributes:
%     e.g. shapes and colors (for debugging / display)
%
%   a few non-primitive behaviors (provided as blocks)
%     literal insert action
%     default environment-builder for the initial input
%
%   equational laws (not sure how to represent these yet)
%     I'd like to support code-proofs. E.g. `addCommutes` and
%     so on.
%   rewrite rules (ditto)
%
%   application models: just input types, really.
%
% This module executes in a bootstrap environment (only a few
% primitives) but can import other modules that are restricted
% to avmboot.




% Basic Data Plumbing Primitives
%
%   first    ((x~>x')*(x*y))~>(x'*y)
%   assocl   (x*(y*z))~>((x*y)*z)
%   swap     (x*y)~>(y*x)
%   intro1   x~>(1*x)
%   elim1    (1*x)~>x
%   rot3     (a*(b*(c*d)))~>(c*(a*(b*d)))
%  
%   left     ((x~>x')*(x+y))~>(x'+y)
%   assocl+  (x+(y+z))~>((x+y)+z)
%   mirror   (x+y)~>(y+x)
%   intro0   x~>((0*x)+x)
%   elim0    ((0*y)+x)~>x
%   rot3+    (a+(b+(c+d)))~>(c+(a+(b+d)))
%
% The left, mirror, etc. primitives are polymorphic for dynamic and 
% static sums (x|y). I could have overloaded first/swap/etc. to work
% with sums too, but I decided that the distinction between sum and
% product is significant enough that developers should need a parallel
% vocabulary. The distinction between static and dynamic sums, OTOH,
% is limited to a few distribution and merge operators. Basic data
% plumbing should all be the same.




% Debugging Primitives
%
%   error :: (Text*x)~>x
%   warn  :: (Text*x)~>x
%   trace :: (Text*x)~>x
%
% Error will create a type-error at `x`, will automatically track
% the expansion in which this error was introduced, and will taint
% everything that uses `x` (except pure data plumbing). An error
% is reduced to a warning if it occurs in a dead-code branch.
%
% Warn and trace do the same thing, but have different levels of
% severity. Trace is potentially useful for IDEs and debugging, i.e.
% to add color to a program or a rendered type representation.



% Manipulating Static Values - we do a lot of this in Awelon
%
% Statics can generally be captured, copied, or dropped. 
%   staticTextCapture   :: T~>(1~>T)
%   staticNumberCapture :: N~>(1~>N)
%   staticBlockCapture  :: B~>(1~>B) (inherits affine/relevant)
%
%   staticTextCopy      :: T~>(T*T)
%   staticNumberCopy    :: N~>(N*N)
%   staticBlockCopy     :: B~>(B*B)  (error for affine blocks)
%
%   staticTextDrop      :: T~>1
%   staticNumberDrop    :: N~>1
%   staticBlockDrop     :: B~>1      (error for relevant blocks)
%
% Numbers can be manipulated in several useful ways...
%
%   staticNumberAdd (N*N)~>N
%   staticNumberAdd (N*N)~>N
%   staticNumberMul (N*N)~>N
%   staticNumberInv; assert non-zero; N~>N
%   staticNumberNeg N~>N
%   staticNumberMin (N*N)~>N
%   staticNumberMax (N*N)~>N
%   staticNumberCmp  
%   

%   testIsStaticNumber x~>(x|x)
%   testIsStaticIntegral x~>(x|x)
%   testNumberLessThan (N*N)~>((N*N)|(N*N)) -- less-than

% Static Text Operators
%   staticTextAppend  (T*T)~>T
%   staticTextSplitAt (T*T)~>(T*T)
%   staticTextCopy T~>(T*T)
%   staticText
%   


% Temporal Primitives?
%
%   delay :: (Number * x) ~> x'
%   synch :: x ~> x'
%   usebefore :: (Number * block) ~> block
%   useafter  :: (Number * block) ~> block
%
% Note: I'm not sure I want synch and delay as primitives. Not every
% parititon should support them. However, 


% Declarative Linearity
%
%   Blocks in Awelon are transparently marked with substructural types:
%
%     affine - may not be copied; use at most once
%     relevant - may not be dropped; use at least once
%
%   Linearity can be declared by marking a block affine AND relevant.
%


% Linearity Primitives - enforcing negotiation protocols, contracts,
% exclusivity, uniqueness, and resource control. Linearity is a very
% expressive yet simple concept.
%
% Declarative Linearity
%   can only be applied to 'blocks' because only blocks have a well
%   defined notion of "usage" - e.g. by first, left, dynamic eval,
%   or collection-oriented evals. For convenience, linear blocks are
%   not treated distinctly by those operators, rather only by copy or
%   drop behaviors. Block composition with a linear block (for either
%   or both arguments) will result in a linear block.
%
%     linearize :: block ~> linearBlock (transparent to first, left, eval)
%     
%   linearize ::  (x~>y) ~> Linear(x~>y)
%      a linear block is transparently applied by first or left.
%      however, it cannot be dropped without application
%
%
% Note that while some applications of linearity can be "declared",
% others - in particular those involving uniqueness or exclusivity -
% require a linear object called the "unique source" (or unisauce)
% to be threaded through the application. Awelon cannot simply create
% a unique source due to RDP's idempotence properties.



% Collection-Oriented Awelon - matrices of signals
% 
% 




%
% Note: I might not distinguish static choice and offerings at the
% primitive layer. I wonder how effectively I could model them in
% the language.
% 

% Static Copy Operators
%   staticBlockCopy B~>(B*B)

% Static Number Operators

% Product Primitives



























