% Awelon Virtual Machine definition module 'avm'
%  v0.01
%  David Barbour, 2013 August

import avmboot,stdenv

% The task of this module is to provide a description of Awelon's
% primitive behaviors to the compiler or interpreter. This must
% include the bootstrap primitives. 
%
% At the moment, I'm not quite sure how I want to describe these
% primitives. As a named transformation on type descriptors? Or
% perhaps I should list every type twice: string, and a block to
% compute it.
%
%   primitive behaviors
%     basic data plumbing (first, assocl, swap, rot3, intro1, elim1)
%     types are represented as blocks operating on typerep
%
%   support for ad-hoc type attributes:
%     e.g. shapes and colors (for debugging / display)
%
%   a few non-primitive behaviors (provided as blocks)
%     literal insert action
%     default environment-builder for the initial input
%
%   equational laws (not sure how to represent these yet)
%   rewrite rules (ditto)
%
%   application models: just input types, really.
%
% This module executes in a bootstrap environment (only a few
% primitives) but can import other modules that are restricted
% to avmboot.

% Normal Data Plumbing Primitives
%   first    ((x~>x')*(x*y))~>(x'*y)
%   assocl   (x*(y*z))~>((x*y)*z)
%   swap     (x*y)~>(y*x)
%   intro1   x~>(1*x)
%   elim1    (1*x)~>x
%   rot3     (a*(b*(c*d)))~>(c*(a*(b*d)))
%  
%   left     ((x~>x')*(x+y))~>(x'+y)
%   assocls  (x+(y+z))~>((x+y)+z)
%   mirror   (x+y)~>(y+x)
%   intro0   x~>(0+x)
%   elim0    (0+x)~>x
%   rot3s    (a+(b+(c+d)))~>(c+(a+(b+d)))
%
%   nochoice x~>(x+x)
%   
%

% Question: Should I model static choice (x|y) and offers (x&y) as
% language primitives, or should I model them above regular choice
% and products and fractional types? Or maybe a mix, where some of
% the primitives will operate only on static choice?
%
% Thoughts: It might be better to use more primitives than needed,
% then later work my way backwards, if it means getting something
% implemented faster. OTOH, in some cases adding more primitives is
% more difficult. 



%
% Note: I might not distinguish static choice and offerings at the
% primitive layer. I wonder how effectively I could model them in
% the language.
% 

% Static Copy Operators
%   staticBlockCopy B~>(B*B)

% Static Number Operators
%   staticNumberAdd (N*N)~>N
%   staticNumberMul (N*N)~>N
%   staticNumberInv; assert non-zero; N~>N
%   staticNumberNeg N~>N
%   staticNumberCopy N~>(N*N)
%   testIsStaticNumber x~>(x|x)
%   testIsStaticIntegral x~>(x|x)
%   testNumberLessThan (N*N)~>((N*N)|(N*N)) -- less-than

% Static Text Operators
%   staticTextAppend  (T*T)~>T
%   staticTextSplitAt (T*T)~>(T*T)
%   staticTextCopy T~>(T*T)
%   staticText

% Product Primitives



























