% Awelon Virtual Machine definition module 'avm'
%  v0.01
%  David Barbour, 2013 August

import avmboot,stdenv

% The task of this module is to provide a description of Awelon's
% primitive behaviors to the compiler or interpreter. This must
% include the bootstrap primitives. 
%
% At the moment, there are two issues I need to address:
% 
%   1) decide what primitives to describe
%   2) decide how to describe these primitives
%
% Regarding the latter point, I think one feature I want is a behavior
% to compute the typerep of the output given the typerep of the input.
% In addition, I want english descriptors. But for the moment I could
% limit it to just some descriptors and names!
%
%   primitive behaviors
%     basic data plumbing (first, assocl, swap, rot3, intro1, elim1)
%     types are represented as blocks operating on typerep
%
%   partitions: perhaps support inheritance... or partitions like
%     typeclasses, partition types can inherit properties or prims
%     of another, just to avoid repetition.
%       (something like typeclasses might be suitable for basic types, too)
%
%   support for ad-hoc type attributes:
%     e.g. shapes and colors (for debugging / display)
%
%   a few non-primitive behaviors (provided as blocks)
%     literal insert action
%     default environment-builder for the initial input
%
%   equational laws (not sure how to represent these yet)
%     I'd like to support code-proofs. E.g. `addCommutes` and
%     so on.
%   rewrite rules (ditto)
%
%   application models: just input types, really.
%
% This module executes in a bootstrap environment (only a few
% primitives) but can import other modules that are restricted
% to avmboot.


% Basic Data Plumbing Primitives
%
%   first    ((x~>x')*(x*y))~>(x'*y)
%   assocl   (x*(y*z))~>((x*y)*z)
%   swap     (x*y)~>(y*x)
%   intro1   x~>(1*x)
%   elim1    (1*x)~>x
%   rot3     (a*(b*(c*d)))~>(c*(a*(b*d)))
%  
%   left     ((x~>x')*(x+y))~>(x'+y)
%   assocl+  (x+(y+z))~>((x+y)+z)
%   mirror   (x+y)~>(y+x)
%   intro0   x~>((0*x)+x)
%   elim0    ((0*y)+x)~>x
%   rot3+    (a+(b+(c+d)))~>(c+(a+(b+d)))
%
% The left, mirror, etc. primitives are polymorphic for dynamic and 
% static sums (x|y). I could have overloaded first/swap/etc. to work
% with sums too, but I decided that the distinction between sum and
% product is significant enough that developers should need a parallel
% vocabulary. The distinction between static and dynamic sums, OTOH,
% is limited to a few distribution and merge operators. Basic data
% plumbing should all be the same.


% Substructural Types 
%
%     affine (B ~> B') - may not be copied; use at most once
%     relevant (B ~> B') - may not be dropped; use at least once
%
% Linearity for a block is declared by marking a block both
% affine and relevant.
%


% Uniqueness Source
%
%   A uniqueness source is a static source of uniqueness (though it
%   may be a static argument to a dynamic behavior). It essentially
%   enforces the construction of unique URL-like directory paths 
%   within the source code. 
%
%   Unique values become the basis for:
%     sealer/unsealer pairs
%     exclusive binding to state
%     unique identifiers
%
%   The unique source can be dropped, but cannot directly be copied.
%   Instead of copies, the uniquness source can split a subdirectory
%   with a static text identifier. This text provides stability for
%   live programming, persistence, and changes in source code.
%
%     splitUniqueSource :: (Text * Up) ~> (Uc * Up')
%     dropUniqueSource :: Ux ~> Unit
%
%   After split, the parent cannot reuse that child name. The child 
%   has a fresh set of identifiers, though names problematic for a
%   URL or filesystem will still be rejected. 
%
%   (Todo: support a mechanism for unique sources to split on dynamic 
%   collection-oriented operations, once I know what I'm doing there.)



% Debugging Primitives
%
%   error :: (Text*x)~>x
%   warn  :: (Text*x)~>x
%   trace :: (Text*x)~>x
%
% Error will create a type-error at `x`, will automatically track
% the expansion in which this error was introduced, and will taint
% everything that uses `x` (except pure data plumbing). An error
% is reduced to a warning if it occurs in a dead-code branch.
%
% Warn and trace do the same thing, but have different levels of
% severity. Trace is potentially useful for IDEs and debugging, i.e.
% to add color to a program or a rendered type representation.





% Manipulating Static Values - we do a lot of this in Awelon
%
% Statics can generally be captured, copied, or dropped. 
%   staticTextCapture   :: T~>(1~>T)
%   staticNumberCapture :: N~>(1~>N)
%   staticBlockCapture  :: B~>(1~>B) (inherits affine/relevant properties)
%
%   staticTextCopy      :: T~>(T*T)
%   staticNumberCopy    :: N~>(N*N)
%   staticBlockCopy     :: B~>(B*B)  (error for affine blocks)
%
%   staticTextDrop      :: T~>1
%   staticNumberDrop    :: N~>1
%   staticBlockDrop     :: B~>1      (error for relevant blocks)
%
% Numbers can be manipulated in several useful ways...
%
%   staticNumberAdd (N*N)~>N
%   staticNumberAdd (N*N)~>N
%   staticNumberMul (N*N)~>N
%   staticNumberInv; assert non-zero; N~>N
%   staticNumberNeg N~>N
%   staticNumberMin (N*N)~>N
%   staticNumberMax (N*N)~>N
%   staticNumberCmp  
%   

%   testIsStaticNumber x~>(x|x)
%   testIsStaticIntegral x~>(x|x)
%   testNumberLessThan (N*N)~>((N*N)|(N*N)) -- less-than

% Static Text Operators
%   staticTextAppend  (T*T)~>T
%   staticTextSplitAt (T*T)~>(T*T)
%   staticTextCopy T~>(T*T)
%   staticText
%   


% Temporal Primitives?
%
%   delay :: (Number * x) ~> x'
%   synch :: x ~> x'
%   usebefore :: (Number * block) ~> block
%   useafter  :: (Number * block) ~> block
%
% Note: I'm not sure I want synch and delay as primitives. Not every
% parititon should support them. However, 





% Collection-Oriented Awelon - matrices of signals
% 
% 




%
% Note: I might not distinguish static choice and offerings at the
% primitive layer. I wonder how effectively I could model them in
% the language.
% 

% Static Copy Operators
%   staticBlockCopy B~>(B*B)

% Static Number Operators

% Product Primitives



























