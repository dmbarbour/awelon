
@doc.Ordinal
"An ordinal comparison takes two values and returns a simple ordering:
 
         (K*K)→Ord
         Ord is (EQ+(LT+GT))
             as (1+(1+1))
 
 Here, `EQ` represents that two values are equivalent or unordered. `LT` and `GT` indicate a less-than or greater-than ordering, assuming the normal irreflexive and transitive properties one should expect from these relationships. The `Ord` type is useful because, at least for composite types, it can avoid a lot of rework compared to making two less-than comparisons with the arguments flipped.
~

@doc.compareOnStackToRawCompare "[K K -- Bool] -- [(K*K)→Bool]"
@compareOnStackToRawCompare [wx] composel applyWrap



@doc.listLessThan.l 
"Given two lists of similar type and a less-than (transitive, irreflexive, totally ordered) comparison function, return whether the first list is less-than the second. If the first list is shorter than the second, but all elements up to that point are equivalent, it will also return 'true' for less-than.
 
        a`L a`L [(a*a)→Ord] -- Ord  
        for copyable & droppable types a,b
 
 This is mostly intended to be used for comparing text, and is rather specialized for this particular use case. It may be a more generalized approach would serve better, e.g. based on stream processing or a generalized multi-zip. But this will do for now.
~
@listLessThan.l [step.listLessThan.l] bind fixpoint inline
@step.listLessThan.l swap take2 [onB.listLessThan.l] [discard2 drop2 false.b] if
@onB.listLessThan.l take [put onAB.listLessThan.l] [discard3 drop true.b] if
@onAB.listLessThan.l 
  dx x swapd pw dup paste .applyd
  [notLT.listLessThan.l] [drop2 discard2 true.b] if_
@notLT.listLessThan.l
  w put .applyd [put inline] [drop2 discard false.b] if_
@onB-A.listLessThan.l drop2 discard2 true.b
@onA-B.listLessThan.l drop2 discard2 false.b
  
  
  
  
  
  




