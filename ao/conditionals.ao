boolean

@doc.ConditionalBehavior
"Awelon expresses conditional behavior using sum types. A sum type, `(a + b)`, indicates a value that is either left in `a` or right in `b`. A boolean, having exactly two values, can be modeled as `(1 + 1)` where 1 is the unit type (having exactly one value). Though, for various reasons, Awelon does not encourage use of booleans. Many useful data structures are also modeled with sums, e.g. a list is modeled with type `µL.((a*L)+1)`, or an optional value with `(a+1)`.
 
 Sum types can be computed by comparing numbers (via ABC operator `>`) or building more sophisticated observations above this primitive. Sums may also be returned from effectful observations or actions. By convention, the 'right' side of a sum is often punned with 'true', 'success', or 'complete' depending on the context. That is just a mnemonic, though; the formal semantics of sums is purely structural.
 
 Conditional behavior is expressed by applying a block to just the left or right side of a sum (via ABC operator `?`). The block may be affine (no copy), but must not be relevant (no drop). In addition, values may be explicitly distributed into a sum, or extracted from it. Conventional if/then/else behavior is modeled by distributing two programs then conditionally extracting one of them.
~

@not      %rVRWLCl
@notd     swap not swap
@id.notnot  not not

@doc..mirror "(a+b)*e→(b+a)*e"
@.mirror %VRWLC
@mirror not

@doc.inR "b -- (0 + b); wrap 'b' in success, mark true, in the right"
@doc.inL "a -- (a + 0); wrap 'a' in failure, mark false, on the left"
@inR %rVVRWLCl
@inL %rVl
@inRd swap inR swap
@inLd swap inL swap

@doc.distribInR "b -- (b + b); in right; as `inR` but preserves x's type info in left"
@doc.distribInL "a -- (a + a); in left; as `inL` but preserves x's type info in right"
@distribInL false.b swap distrib trimBoolean
@distribInR distribInL mirror
@distribInLd swap distribInL swap
@distribInRd swap distribInR swap

@doc.gt "a b -- ((a*b) + (b*a)); a > b?"
@doc.lt "a b -- ((b*a) + (a*b)); a < b?"
@doc.gte "a b -- ((a*b) + (b*a)); a ≥ b?"
@doc.lte "a b -- ((b*a) + (a*b)); a ≤ b?"
@gt  p %rr>l
@lt  p %rrw>l
@gte lt not
@lte gt not

@doc.gt1 "a x -- (a + a); a > x?"
@doc.lt1 "a x -- (a + a); a < x?"
@doc.gte1 "a x -- (a + a); a ≥ x?"
@doc.lte1 "a x -- (a + a); a ≤ x?"
@gt1 lte1 not
@lt1 gte1 not
@lte1 p %rr>  [.fst] %r? .mirror [.snd] %r?l
@gte1 p %rrw> [.snd] %r? .mirror [.fst] %r?l

@doc.gtb "a x -- Bool; a > x?"
@doc.ltb "a x -- Bool; a < x?"
@doc.gteb "a x -- Bool; a ≥ x?"
@doc.lteb "a x -- Bool; a ≤ x?"
@gtb gt toBoolean
@ltb lt toBoolean
@gteb gte toBoolean
@lteb lte toBoolean

@doc.eq  "a b -- ((LT(a*b) + GT(b*a)) + EQ(b*a))"
@doc.neq "a b -- (EQ(b*a) + (LT(a*b) + GT(b*a)))"
@eq neq not
@neq gt [%vr>c] .left %rRl

@doc.eq1 "a x -- ((a(<x) + a(>x)) + a(=x))"
@doc.neq1 "a x -- (a(=x) + (a(<x) + a(>x))); a ≠ x?"
@eq1 neq1 not
@neq1 neq %r [.snd] %r? %VRWR [.fst] %r? %W [.snd] %r? %WLWLC %l

@doc.eq1m "a x -- (a(≠x) + a(=x))"
@doc.neq1m "a x -- (a(=x) + a(≠x))"
@eq1m eq1 [%vMc] .left
@neq1m eq1m not

@doc.eqb "a b -- Bool; a = b?"
@doc.neqb "a b -- Bool; a ≠ b?"
@eqb eq toBoolean
@neqb neq toBoolean


@doc.distrib "(a + b) c -- ((c*a) + (c*b))"
@doc.partialFactor "((a*b)+(c*d)) -- (b + d) (a + c)"
@doc.merge   "(a + a') -- a; a and a' must be future compatible"
@doc.fullFactor "((a+b)+(a'+d)) -- (b+c) a"
@distrib p %rrDl
@partialFactor %rFll x
@merge %rMl
@merged swap merge swap
@fullFactor partialFactor merge

@doc.condSwap "conditional swap; swap top two arguments if third in right"
@condSwap p distrib [%rwl] .left fullFactor wx

@doc.if 
"The 'if' function enables developers to conveniently model conditional behavior. It operates by selecting a block then invoking it. A few variations of 'if' are provided based on whether you need access to the conditional, and whether you wish to keep it.
 
     if  :: ..a (L+R) [..a L -- ..b] [..a R -- ..b] -- ..b
     if_ :: ..a (L+R) [..a -- ..b]   [..a -- ..b]   -- ..b
     ifk :: ..a (L+R) [..a L -- ..b] [..a R -- ..b] -- ..b (L+R)
     ifd :: ..a (L+R) [..a -- ..b]   [..b -- ..b]   -- ..b (L+R)
                      on left/false  on right/true  
 
 Only `if` and `if_` can be used where tail-call optimization is needed.
 
 The main weakness of 'if' behaviors is that they're difficult to extend or compose. They're effectively 'closed' syntactically. Developers are under pressure to push a lot of logic into those blocks. ABC is based on sum types (L+R) to better support composition of conditional behavior, but to leverage sum types requires alternative idioms (such as incremental processes or RDP). 
~
@doc.if_ "..a (L+R) [..a -- ..b]   [..a -- ..b]   -- ..b      ; see @doc.if"
@doc.ifk "..a (L+R) [..a L -- ..b] [..a R -- ..b] -- ..b (L+R); see @doc.if"
@doc.ifd "..a (L+R) [..a -- ..b]   [..a -- ..b]   -- ..b (L+R); see @doc.if"

@if  p distrib [%rwl] .left merge x wx drop inline
@if_ p distrib [%rwl] .left fullFactor wx drop dropd inline
@ifk p dupd distrib [%rwl] .left merge x wx drop swapd dip
@ifd p distrib [%rwl] .left fullFactor wx drop dip

@doc.when  "..a (L+R) [..a R -- ..a] -- ..a"
@doc.when_ "..a (L+R) [..a -- ..a] -- ..a"
@doc.whenk "..a (L+R) [..a R -- ..a] -- ..a (L+R)"
@doc.whend "..a (L+R) [..a -- ..a] -- ..a"

@when  [drop] swap if
@whenk [drop] swap ifk
@when_ [] swap if_
@whend [] swap ifd

@doc.unless  "..a (L+R) [..a L -- ..a] -- ..a"
@doc.unless_ "..a (L+R) [..a -- ..a] -- ..a"
@doc.unlessk "..a (L+R) [..a L -- ..a] -- ..a (L+R)"
@doc.unlessd "..a (L+R) [..a -- ..a] -- ..a (L+R)"

@unless  [drop] if
@unlessk [drop] ifk
@unless_ [] if_
@unlessd [] ifd

@doc..left  "(a + b) [a→a'] -- (a' + b); apply block on left condition"
@doc..right "(a + b) [b→b'] -- (a + b'); apply block on right condition"
@doc..either "(a + b) [a→a'] [b→b'] -- (a' + b')"
@.left p %rr?l
@.right notd .left not
@.either unrot .left swap .right

@eqv.cca+ [.either] [swap take2 not put2 .either not]

@doc.wrapObserver.b "[a--Bool] -- [a--(a+a)]; Copyable a"
@wrapObserver.b [keep] bind [distrib [%c] .left [%c] .right] compose

@doc.wrapKeyObserver.b "[k--Bool] -- [(k*v)--((k*v)+(k*v))]; Copyable k"
@wrapKeyObserver.b 
    quote [dupfst swap] composel 
    [dip distrib [%c] .left [%c] .right] compose

@doc.assert 
"AO and ABC offer a primitive mechanism to assert that a condition is not false, i.e. that `(a + b)` is not in `a`. (The condition is not necessarily true, i.e. it may be that the assertion itself is dead code.) Since the condition after a successful assertion is not false, we eliminate the sum type and just continue with `b`.
 
     assert :: (a + b) -- b
 
 In addition, specialized asserts can be much easier to use. These operate as identity functions, but with a limited acceptance criteria.
 
     assertLT, assertLTE -- assert upper bounds for a comparable value
     assertGT, assertGTE -- assert lower bounds for a comparable value
 
 And common number assertions...
 
     assertInteger, assertNatural, assertNatural+  -- assertions on number types
     assertGTz, assertGTEz -- assert greater than or equal to zero
     assertEQz, assertNEQz -- assert equal or not equal to zero
     assertLTz, assertLTEz -- assert less than or equal to zero
     assertNatural -- integer greater than or equal to zero
     assertChar -- integer between 0 and 1114111 inclusive
     assertOctet -- integer between 0 and 255 inclusive
     assertProb -- rational number between 0 inclusive and 1 inclusive
     assertUniform -- rational number between 0 inclusive and 1 exclusive
 
 To clarify, `assert` is primarily intended for *static* analysis. It provides a means to express some preconditions, postconditions, and refinement types. These conditions should ideally be computable via partial evaluation, such that developers can receive compile time errors or warnings or errors based on whether an asserted condition is disproven or unproven.
 
 In an effectful program, some assertions may have dynamic nature. In that case, modulo use of capabilities designed to isolate failure, a dynamic assertion failure causes the whole program to be halted as quickly and cleanly as feasible.
~
@assert   %rKl

@assertLT   lt assert wx
@assertLTE  lte assert wx
@assertGT   gt assert x
@assertGTE  gte assert x
@assertEQ   eq assert x
@assertEQ1  assertEQ drop
@assertNEQ  neq assert [%vrwlc] .left merge x

@doc.assertEQ1d "x y x -- x y; assert x's are equal, useful for testing"
@assertEQ1d   swapd assertEQ1 swap
@assertEQ1dd  rotd  assertEQ1 unrot
@assertEQ1ddd rolld assertEQ1 unroll

@assertLTz  0 assertLT drop
@assertLTEz 0 assertLTE drop
@assertGTz  0 assertGT drop
@assertGTEz 0 assertGTE drop
@assertEQz  0 assertEQ drop
@assertNEQz 0 assertNEQ drop

@doc..assertUnit "1→1; assert singular value is unit"
@.assertUnit %vvrwlcc

@assertUnit   elim1 intro1
@assertProd   w w
@assertSum    mirror mirror
@assertNumber 0 .add

@assertInteger  dup 1 .rem assertEQz drop
@assertNatural  assertGTEz assertInteger
@assertNatural+ assertGTz  assertInteger
@assertChar     assertNatural 0x10ffff assertLTE drop
@assertOctet    assertNatural 256 assertLT drop
@assertProb     assertGTEz 1 assertLTE drop
@assertUniform  assertGTEz 1 assertLT drop

@id.assertInR inR assert
@id..assertUnit .assertUnit
@id.assertLT assertLT
@id.assertLTE assertLTE
@id.assertGT assertGT
@id.assertGTE assertGTE
@id.assertEQ assertEQ
@id.assertNEQ assertNEQ
@id.assertLTz assertLTz
@id.assertGTz assertGTz
@id.assertGTEz assertGTEz
@id.assertLTEz assertLTEz
@id.assertEQz assertEQz
@id.assertInteger assertInteger
@id.assertNatural assertNatural
@id.assertNatural+ assertNatural+
@id.assertChar assertChar
@id.assertProb assertProb
@id.assertUniform assertUniform

