loops blocks streams lists

@doc.Processes
"A process model describes an interactive behavior. A simple process model:
 
     µP.[a → (P * b)]               shorthand: [a ↣ b] (using U+21A3)
 
 In each interactive step, this process receives an input of type `a` and outputs a `b` along with the updated process. More generally, this process might be dependently typed. Further, the expected input and output types may evolve over interactive steps, e.g. type state, protocols, handshakes. 
 
 This process model composes in useful ways:
 
     (a ↣ b) *(b ↣ c)  → (a ↣ c)                Sequential
     (a ↣ a')*(b ↣ b') → ((a*b) ↣ (a'*b'))      Concurrent
     (a ↣ a')*(b ↣ b') → ((a+b) ↣ (a'+b'))      Conditional
 
 Processes can also model most object oriented programming patterns, modulo those that rely heavily on aliasing. We can also model environments, e.g. organizations of named processes that can communicate via messages, which may have their own compositions. Processes are a relatively generic approach to programming.
 
 Sadly, this process model is inefficient. A more sophisticated process model could expose structure, optimize dataflows, compose lifted functions, minimize fixpoints. Of course, KISS principle applies; there is value in simplicity. The simple process model proposed here will be developed under suffix `.p`, and may easily coexist with more sophisticated models (e.g. as a common target for integration).
~
@doc.suffix.p doc.Processes

@doc.lift.p "[a → b] -- [a ↣ b]; function to process"
@lift.p .bsecond .fixfirst

@doc.map.p  "[a -- b] -- [a ↣ b]; function (apply env) to process"
@map.p applyWrap lift.p

@doc.step.p "a [a↣b] -- b [a↣b]; run process one step"
@step.p .apply x

@doc.compose.p "[a ↣ b] [b ↣ c] -- [a ↣ c]; compose two processes"
@compose.p [step.compose.p] .fixfirst .bind .bind
@step.compose.p %vrwrwr$rwzw$zrz'ozw'olc
@composel.p swap compose.p

@test.compose.p
 0
 [inc] map.p
 [mul2] map.p
 compose.p
 step.p step.p step.p step.p
 30 assertEQ1d.n
 step.p step.p step.p step.p
 510 assertEQ1d.n

@doc.state.p
"Generate a stateful process using a stack function.
 
     st [st a -- st b] -- [a ↣ b]
 
 This uses the 'apply' environment. 
 
 (Aside: Another interesting possibility is to keep state more implicitly using a whole environment (via introE). Develop this when it comes up.)
~
@state.p %r [preApply wx] %ro [pw postApply] %rwo %l .state.p

@doc..state.p 
"A stateful process can be modeled as a pure function that, in addition to its normal input and output, receives a state value and outputs an updated state value. This must be coupled with an initial state.
 
     st [(st*a) → (st*b)] -- [a ↣ b]
 
 Most stateful behaviors can be expressed this way.
~
@.state.p [step.state.p] .bind .fixfirst .bind
@step.state.p %wvrwr$rz'olc

@doc.first.p   "[a ↣ a'] -- [(a*b) ↣ (a'*b)]; process first argument"
@first.p [step.first.p] .fixfirst .bind 
@step.first.p %wz$rz'o
@test.first.p
 0 0 p inc.p first.p
 step.p step.p step.p step.p
 swap x 4 assertEQ1.n 0 assertEQ1d.n

@doc.second.p   "[b ↣ b'] -- [(a*b) ↣ (a*b')]; process second argument"
@second.p [step.second.p] .fixfirst .bind 
@step.second.p %vrwrwrwzw$rwzwlwz'olc
@test.second.p
 0 0 p inc.p second.p
 step.p step.p step.p step.p
 swap x 0 assertEQ1.n 4 assertEQ1d.n

@doc.left.p     "[a ↣ a'] -- [(a+b) ↣ (a'+b)]; process left argument"
@left.p [step.left.p] .fixfirst .bind
@step.left.p %vrwrD [%vr$c] %r?FMz'olc
@test.left.p#inL
 0 inL
 inc.p left.p
 step.p step.p step.p step.p
 swap assertInL 4 assertEQ1.n
@test.left.p#inR
 0 inR
 inc.p left.p
 step.p step.p step.p step.p
 swap assertInR 0 assertEQ1.n

@doc.right.p    "[b ↣ b'] -- [(a+b) ↣ (a+b')]; process right argument"
@right.p [step.right.p] .fixfirst .bind
@step.right.p %vrwrDVRW [%vr$c] %r?WLCFMz'olc
@test.right.p#inL
 0 inL
 inc.p right.p
 step.p step.p step.p step.p
 swap assertInL 0 assertEQ1.n
@test.right.p#inR
 0 inR
 inc.p right.p
 step.p step.p step.p step.p
 swap assertInR 4 assertEQ1.n

@doc.delay.p "a -- [a ↣ a]; delays input one step; initial output provided"
@delay.p [step.delay.p] .fixfirst .bind
@step.delay.p %vrwrwz'olc

@doc.counter.p "-- [a ↣ (N*a)]; add index to output (starting from 1)"
@doc.counterFrom.p "N -- [a ↣ (N*a)]; add index with initial value"
@counter.p 1 counterFrom.p
@counterFrom.p [%rw dup incd %wl pw] state.p

@doc.count.p "-- [a ↣ N]; (droppable a); as counter, but drop input"
@doc.countFrom.p "N -- [a ↣ N]; (droppable a); as counterFrom, but drop input"
@count.p 1 countFrom.p
@countFrom.p [drop dup incd] state.p

@test.count.p
  0 11 countFrom.p 
  [step.p] 7 repeat
  17 assertEQ1d.n

@inc.p [inc\1] lift.p
@test.inc.p 
  11 inc.p 
  [step.p] 16 repeat
  swap 27 assertEQ
