@doc.Processes
"A process model describes an interactive behavior. A simple process model:
 
     µP.[a → (P * b)]               shorthand: [a ↣ b] (using U+21A3)
 
 In each interactive step, this process receives an input of type `a` and outputs a `b` along with the updated process. More generally, this process might be dependently typed. Further, the expected input and output types may evolve over interactive steps, e.g. type state, protocols, handshakes. 
 
 This process model composes in many useful ways:
 
     (a ↣ b)*(b ↣ c) → (a ↣ c)                  Sequential
     (a ↣ a')*(b ↣ b') → ((a*b) ↣ (a'*b'))      Concurrent
     (a ↣ a')*(b ↣ b') → ((a+b) ↣ (a'+b'))      Conditional
 
 Processes can also model most object oriented programming patterns.
 
 Sadly, this process model is inefficient. A more sophisticated process model could expose structure, optimize dataflows, compose lifted functions, eschew fixpoints. Of course, KISS principle applies; there is value in simplicity. The simple process model proposed here will be developed under suffix `.p`, and may easily coexist with more sophisticated models (e.g. as a common target for integration).
~
@doc.suffix.p doc.Processes

@doc.lift.p "[a → b] -- [a ↣ b]; function to process"
@lift.p .bsecond .fixfirst

@doc.step.p "a [a↣b] -- b [a↣b]; run process one step"
@step.p .apply x

@doc.compose.p "[a ↣ b] [b ↣ c] -- [a ↣ c]; compose two processes"
@compose.p [step.compose.p] .fixfirst .bind .bind
@step.compose.p %vrwrwr$rwzw$zrz'wozw'wolc
@composel.p swap compose.p

@test.compose.p
 0
 1 addC.p 
 2 mulC.p
 compose.p
 step.p step.p step.p step.p
 30 assertEQ1d.n
 step.p step.p step.p step.p
 510 assertEQ1d.n

@doc.first.p  "[a ↣ a'] -- [(a*b) ↣ (a'*b)]; process first argument"
@doc.second.p "[b ↣ b'] -- [(a*b) ↣ (a*b')]; process second argument"
@doc.par.p    "[a ↣ a'] [b ↣ b'] -- [(a*b) ↣ (a'*b')]; run two processes in parallel"
@doc.left.p   "[a ↣ a'] -- [(a+b) ↣ (a'+b)]; process left argument"
@doc.right.p  "[b ↣ b'] -- [(a+b) ↣ (a+b')]; process right argument"

@doc.scanList.p   "a`L [a ↣ b] -- b`L; process list all at once"
@doc.scanStream.p "a`SS [a ↣ b] -- b`SS; process stream incrementally"

@doc.delay.p "a -- [a ↣ a]; delays input one step; initial output provided"
@delay.p [step.delay.p] .fixfirst .bind
@step.delay.p %vrwrwz'wolc

@doc.mul.p "-- [(N(a)*N(b)) ↣ N(a*b)]"
@doc.add.p "-- [(N(a)*N(b)) ↣ N(a+b)]"
@mul.p [%vr*c] lift.p
@add.p [%vr+c] lift.p

@doc.mulC.p "N(a) -- [N(b) ↣ N(a*b)]"
@mulC.p [%vr*c] .bind lift.p

@doc.addC.p "N(a) -- [N(b) ↣ N(a+b)]"
@addC.p [%vr+c] .bind lift.p

@inc.p 1 addC.p
@test.inc.p 
  11 inc.p 
  [step.p] 16 repeat
  swap 27 assertEQ
