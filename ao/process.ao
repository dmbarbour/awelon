@doc.Processes
"In conventional imperative languages, a process is modeled as a procedure that enters an indefinite loop, which typically cycles between effectfully waiting for input and effectfully emitting outputs. This is an AWFUL process model! It is extremely difficult to externally compose, control, reuse, or extend these 'encapsulated loop' processes.
 
 In AO, we instead favor incremental processes. 
 
 Precisely, we model one step of a process. This step consumes one input and produces one output, and may encapsulate state that influences how the process responds to future inputs. The minimal type for a process is (abstractly):
 
     type Process a b = µP. [a→(P*b)]
         shorthand notation: [a↣b] (↣ is U+21A3)
 
 Here `µP` indicates a recursive or fixpoint type. In each step, a process accepts an input `a`, generates output `b`, and determines the behavior for the next step, `P`. This design offers simple process control: a process may be suspended between steps, and feedback loops always take at least one step.
 
 AO's actual process type is described in @doc.ProcessRep, and enables processes to operate and encapsulate state within a more conventional environment.
 
 Incremental processes can composed in sequence, in parallel, and in conditional or switching network styles (using sum types). Dynamic processes are readily modeled. Each step consumes exactly one input and produces exactly one output; however, the input or output may be a collection type. It is feasible to model 'environments' containing named processes that can dispatch or route collections of messages.
 
 Usefully, flexible composition greatly alleviates conventional requirements for shared state and side-effects. 
 
 An AO service or application could feasibly be modeled as a process. In this case, the top-level loop would be implicit, provided by the compiler or runtime. Such a process could even be persistent by serializing the underlying ABC, and thus model long-running workflows. Unfortunately, processes still have a significant weakness as a foundation for services or applications: they encapsulate state! The behavior `P` of a process will diverge from the original source code. This hinders live programming, continuous deployment, mirroring and replication, debugging. Awelon project favors RDP for service or app behavior.
 
 Even so, processes are useful for processing streams and lists, and may serve a useful role for bootstrapping or integrating awelon with more conventional systems.
~

@doc.ProcessRep
"The abstract model for a process is µP.[a→(P*b)]. This abstract model can be implemented directly, but it requires abundant use of fixpoints and quotations, which can be difficult to optimize. Further, it doesn't integrate nicely with conventional AO words.
 
 An alternative implementation model can alleviate these issues.
 
     type Process a b = ∃e,s. ([((a*s)*e)→((b*s)*e)] * (s*e))
 
 This treats each process as encapsulating its own, complete environment, albeit with the step argument added to the stack each step, and the result removed from the stack. Dynamic processes can be modeled as processes that compute and execute processes internally, easily enough.
 
 This implementation model is sealed to hinder accidental dependency on the implementation. In the future, the implementation model may change to support symbolic optimizations and so on.
~
@doc.suffix.p doc.Processes

@sealer.p [%{:p}]
@unsealer.p [%{.p}]
@seal.p sealer.p .apply
@unseal.p unsealer.p .apply

@doc.step.p "a [a↣b] -- b [a'↣b']; run process one step"
@step.p
 unseal.p wx rot p l
 dupd swap .apply
 r x unrot pw seal.p

@test.step.p 
 2 [4 .add] lift.p 
 [step.p] 10 repeat
 drop 42 assertEQ1

@doc.id.p "-- [a↣a]"
@id.p [] lift.p

@doc.delay.p "a -- [a↣a]; delay input by one step, with initial outputs"
@delay.p [swap] liftS.p


@doc.sum.p "-- [n↣n]; output is sum of inputs"
@doc.sum_init.p "n -- [n↣n]; sum with initial value"
@sum.p 0 sum_init.p
@sum_init.p [.add dup] liftS.p

@test.sum.p
  0 sum.p
  [incd dupd step.p dropd] 5 repeat
  dropd 0 swap step.p drop
  15 assertEQ1

@doc.lift.p "[a -- b] -- [a↣b]"
@doc.liftS.p "s [s a -- s b] -- [a↣b]"
@doc.liftE.p "(s*e) [((a*s)*e)→((b*s)*e)] -- [a↣b]"

@lift.p intro1 intro1 intro1 pw pw swap liftE.p
@liftS.p swap intro1 pw intro1 intro1 pw pw swap liftE.p
@liftE.p p seal.p

@doc.compose.p "a↣b b↣c -- a↣c; sequential composition"
@compose.p 
 unseal2.p zip2 
 ops.compose.p swap states.compose.p 
 p seal.p
@states.compose.p [%vv x] .apply
@ops.compose.p
 x
 [.apply] bind 
 [p] composel [x swapd p] compose 
 swap
 [.apply] bind [x swapd] compose
 compose
 
@doc.states.compose.p " -- (sab*(sbc*1))"
@states.compose.p intro1 pw r
 

@doc.ops.compose.p
"Two process function
@ops.compose.p


@unseal2.p swap unseal.p swap unseal.p

@doc.composel.p "b↣c a↣b -- a↣c"
@composel.p swap compose


@doc.suffix.abstract.p "naive implementation of abstract process model"
@doc.lift.abstract.p "[a→b] -- µP.[a→(P*b)]"
@lift.abstract.p .bsecond .fixfirst
@doc.step.abstract.p "a [a↣b] -- b [a'↣b']; run process one step"
@step.abstract.p .apply x
@inc.abstract.p [%v 1 %r+c] lift.abstract.p
@test.inc.abstract.p 
  11 inc.abstract.p 
  [step.abstract.p] 16 repeat
  swap 27 assertEQ
