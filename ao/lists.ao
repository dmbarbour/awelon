@doc.Lists
"Lists in AO consist of a finite sequence of pairs terminated by a number. For example, a list of four values might have structure:
 
     (a * (b * (c * (d * N(x))))
 
 In type signatures, this structure might be abbreviated as foo`L, and the number ending the list as foo`Nel. Lists are typically processed by asking of each element 'are you a pair?' (a form of dynamic introspection). If so, the first item is an element in the list, and the second is the rest of the list. The terminating number is not an element of the list, but a useful convention of AO is to make use of different numbers to weakly indicate different types, e.g. to support debugging. A few common numbers:
 
     0: generic list terminator
     3: text (list of integers between 0 and 0x10ffff)
     8: binary (list of integers between 0 and 255)
 
 Relevantly, ending with different number does impact comparison functions, and developers may freely assert on list terminals to resist accidents. It is a bad idea to observe a terminal to decide type in any formal sense, but it can be useful in heuristic contexts (e.g. rendering in a debugger).
 
 Lists tend to be reversed every time we process them, and so must be un-reversed when we're done. The list functions tend to include the middle steps with an extra `reverse` in the name. Using the intermediate steps can sometimes be more efficient if one was going to reverse the list again anyway. (Though, this efficiency benefit may eventually vanish if optimizers or ABCD begin to recognize list operations.)
 
 *Aside:* Lists are simplistic, in the sense that they are often overly simple. AO's standard dictionaries should include other data structures more suitable for efficient ad-hoc manipulations. These will include finger-trees, ropes built on finger-trees, and zippers. 
~

@doc.eachT.l "a`L [a --] -- a`Nel; apply block to each element in list, return term"
@doc.reverseT&append.l "d`L s`L -- (reverse s ++ d)`L s`Nel"
@doc.map&reverseT.l "a`L [a -- b] -- b`L(reversed) a`Nel"
@doc.map&reverseT&append.l "b0`L a`L [a--b] -- (b reversed ++ b0)`L a`Nel"
@doc.reverseT.l "a`L -- (reverse a, terminate in 0)`L a`Nel"

@eachT.l [step.eachT.l] bind fixpoint inline
@doc.step.eachT.l "a`L [[a --] step.eachT.l] [a --] -- terminal"
@step.eachT.l
 rot isPair
 [nip2 assertNumber]
 [wx roll p rot dip x inline]
 ifk merged inline

@reverseT&append.l [p] eachT.l
@reverse&append.l reverseT&append.l drop
@reverseT.l 0 swap reverseT&append.l
@map&reverseT.l 0 unrot map&reverseT&append.l
@map&reverseT&append.l hidingDest.map.l eachT.l
@hidingDest.map.l [dip] bind [swap] composel [pw] compose

@doc.each.l "a`L [a --] --; apply block to each element in list"
@doc.map.l "a`L [a -- b] -- b`L; apply block modifying each element in list"

@each.l      eachT.l drop
@map.l       map&reverseT.l swap reverseT&append.l drop

@doc.eachTP.l "x y`L [x y -- x] -- x y`Nel; in 'apply' environment"
@doc.eachP.l "x y`L [x y -- x] -- x; in 'apply' environment"
@doc.mapP.l "x`L [x -- y] -- y`L; in 'apply' environment"
@eachTP.l [eachT.l] apply3to2
@eachP.l eachTP.l drop
@mapP.l [apply] bind [map.l] apply2to1 

@doc.eqv.mapTwice.compMap
"Rewriting from a composition of map operations to a map of compositions is a difficult challenge for an optimizer. And proving this is difficult for a prover. In general, if developers need this sort of optimization, they should be using a staged programming model that symbolically constructs the map operations, i.e. initially constructing a free, logical list/stream.
~
@eqv.mapTwice.compMap 
 [compose mapP.l] 
 [unrot mapP.l swap mapP.l]

@length.l 0 swap [drop inc] eachP.l

@test.each.l 0 "World" [.add] eachP.l 520 assertEQ
@test.length.l "hello" length.l 5 assertEQ
@test.map.l "hello" [4 .add] mapP.l "lipps" assertEQ

@doc.Lists.todo
"* search lists (with short-circuit)
 * sorted merge of two lists
 * stable-sort a list (with a given sort function)
 * association lists
 * list to/from stream
~

@doc.partition.l "(a+b)`L -- a`L b`L"
@partition.l 
 0 0 pw swap 
 [push.partition.l] eachTP.l
 dx dup rot 
 reverse&append.l
 unrot swap
 reverse&append.l
@push.partition.l
 [dx p p]
 [dwx p pw]
 ifk merged inline

@doc.partitionBy.l "a`L [a--(b+c)] -- a`L b`L"
@partitionBy.l mapP.l partition.l

@test.partition.l 
 "hello, World!" [106 gt1] 
 partitionBy.l
 "lloorl" assertEQ drop2 

@doc.filter.l "a`L [a--(b+c)] -- c`L; Droppable b"
@filter.l partitionBy.l dropd

@doc.remove.l "a`L a -- a`L; removes comparable value"
@remove.l [neq1m] bind filter.l

@test.remove.l "hello world" 108 remove.l "heo word" assertEQ 

@doc.nub.l "remove duplicate values from list"
@doc.sort.l "sort a list of values"

@nub.l [step.nub.l] fixpoint apply
@step.nub.l
 swap isPair
 [dropd]
 [x copy remove.l swap inline put p]
 ifk merged inline
@test.nub.l "hello, world!" nub.l "helo, wrd!" assertEQ1


 

@doc.AssocLists
"An 'association list' is a list of (key*value) pairs, where all the keys are comparable. Association lists offer a simple model for data structures. In most cases, association lists are sorted on the key in order to avoid encoding irrelevant information about update order.
~

@doc.ListQueue 
"Model a simple, queue object with a pair of lists.
~
@doc.suffix.lq doc.ListQueue
@sealer.lq [%{:lq}]
@unsealer.lq [%{.lq}]
@seal.lq sealer.lq .apply
@unseal.lq unsealer.lq .apply
@empty.lq 0 0 pw [] pw seal.lq
@copy.lq 

