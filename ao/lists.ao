@doc.Lists
"Lists in AO are modeled using a recursive type: 
 
     λa.µL.((a*L)+1)       shorthand: a`L
 
 Of course, AO and ABC don't have direct support for type annotations. (Indirect support is feasible, in a similar sense as `doc.` words supporting documentation.) A list structure is, instead, implicitly encoded in the operations over lists. Lists in ABC are always finite, and are often strictly evaluated. Processing lists generally requires fixpoint functions (see @doc.Loops), though a large vocabulary of list processing words can cover most use cases so users don't need to deal with fixpoints directly.
 
 Lists are simplistic data structures. Their extreme simplicity leads to awkwardness and complexity for many use-cases: 
 
 * access to middle or end of a large list is expensive
 * very large lists can be expensive to hold in memory
 * iterative operations on a list tend to reverse the list
 * direct list processing is not incremental or compositional
 
 Developers are encouraged to use alternative data structures - sequences, streams, functions, etc. - rather than struggle with lists in cases where they're awkward. Text in AO or ABC is essentially shorthand for a list of small numbers (0-1114111, the unicode characters and codepoints). In many cases - e.g. if a text represents a program in a DSL - it is useful to process the text immediately into an alternative structure, such that it can be computed by compile-time partial evaluation. The primary advantage of lists is they have a strong normal form, suitable for structural comparisons.
~

@doc.empty.l "empty list (has same structure as 'false')"
@empty.l intro1 inR

@doc.cons.l "a`L a -- a`L; add element to list"
@doc.consd.l "a`L b a -- a`L b; add element to list"
@cons.l p inL
@consd.l swapd cons.l swap

@assertEmpty.l mirror assert inL
@assertNonEmpty.l assert inR

@doc.each.l "a`L [a --] --; apply block to each element in list"
@doc.eachUntil.l "a`L [a --] [-- Bool] -- a(rem)`L; each with short circuit (on true)"
@doc.eachWhile.l "a`L [a --] [-- Bool] -- a(rem)`L; each with short circuit (on false)" 
@doc.map.l "a`L [a -- b] -- b`L; apply block modifying each element in list"
@doc.mapP.l "a`L [a -- b] -- b`L; map elements in limited `apply` environment"
@doc.fold.l "x a`L [x a -- x] -- x; process each element in constrained environment"
@doc.scan.l "s a`L [s a -- s b] -- s b`L; simultaneous map & fold in limited env"
@doc.length.l "a`L -- a`L integer; return length of list"
@doc.append.l "a1`L a2`L -- (a1 before a2)`L; append two lists"
@doc.reverse.l "a`L -- a`L; reverse order of elements in list"
@doc.reverseAppend.l "a1`L a2`L -- (reverse a2 ++ a1)`L; auxillary"

@each.l [step.each.l] bind fixpoint inline
@step.each.l rot [action.each.l] [elim1 drop2] if
@action.each.l wx roll pw rot dip wx inline
@fold.l [each.l] apply3to1

@map.l mapReverse.l reverse.l
@mapReverse.l empty.l unrot mapReverseAppend.l
@mapReverseAppend.l wrapCons.mapReverseAppend.l each.l
@wrapCons.mapReverseAppend.l [dip] bind [swap] [swap cons.l] wrapfn
@mapP.l [apply] bind [map.l] apply2to1
@scan.l [map.l] apply3to2

@append.l swap reverse.l reverseAppend.l
@appendl.l swap append.l
@reverse.l empty.l swap reverseAppend.l
@reverseAppend.l [cons.l] fold.l

@length.l 0 empty.l rot [cons.l incd] [each.l] apply4to2 reverse.l swap
@id.length.l length.l drop

@test.each.l 0 "World" [.add] fold.l 520 assertEQ1
@test.reverse.l 
 "hello, World!" reverse.l 
 "!dlroW ,olleh" assertEQ1
@test.append.l
 "hello, "  "World!" append.l
 "hello, World!" assertEQ1
@test.reverseAppend.l
 " World!" ",olleh" reverseAppend.l
 "hello, World!" assertEQ1
@test.map.l 
 "hello" [4 .add] mapP.l 
 "lipps" assertEQ1
@test.scan.l
 0 "hello" [dup rot .add swap 4 .add] scan.l
 "lipps" assertEQ1 swap
 532 assertEQ1 swap
@test.length.l
 "hello" length.l 
 "hello" assertEQ1d
 5 assertEQ1
@id.reverse.l reverse.l reverse.l
@eqv.dropReverse.l [drop] [reverse.l drop]
@id.append.l.empty empty.l append.l
@id.appendl.l.empty empty.l appendl.l

@eachWhile.l [not.b] compose eachUntil.l
@eachUntil.l [step.eachUntil.l] bind2 fixpoint inline
@step.eachUntil.l roll [nip3 inL] [cond.eachUntil.l] if
@cond.eachUntil.l swap dip3 roll [action.eachUntil.l] [nip2 inR] if_
@action.eachUntil.l wx roll pw rot dip wx inline

@test.eachUntil.l.haltOnCond
 0 "hello, world!"
 [.add] [dup 600 gtb] eachUntil.l
 "world!" assertEQ1 swap
 608 assertEQ1
@test.eachUntil.l.haltOnLength
 0 "hello, world!"
 [.add] [dup 1200 gtb] eachUntil.l
 empty.l assertEQ1 swap
 1193 assertEQ1 swap

@doc.eqv.mapTwice.compMap
"Rewriting from a composition of map operations to a map of compositions is a difficult challenge for an optimizer. And proving this is difficult for a prover. In general, if developers need this sort of optimization, they should be using a staged programming model that symbolically constructs the map operations, i.e. initially constructing a free, logical list/stream.
~
@eqv.mapTwice.compMap 
 [compose mapP.l] 
 [unrot mapP.l swap mapP.l]

@doc.take.l "a`L N -- a`L; take first N elements of list (or the full list, if N >= length), drop rest of list"
@doc.copy.l "a`L N -- a(orig)`L a(first N)`L; copy first N elements of list"
@doc.drop.l "a`L N -- a`L; drop first N elements of list (or result in empty list, if N >= length)"
@doc.split.l "a`L N -- a(minus first N)`L a(first N)`L; combines result of drop and take; linear."
@doc.splitReverse.l "a`L N -- a(minus first N)`L a(first N reversed)`L"
@doc.splitReverseN.l "a`L N -- a(minus first N)`L a(first N reversed)`L N(remaining; 0 if fully used)"
@doc.splitReverseAppendl.l "a0`L a`L N -- (first N from a ++ a0)`L a(minus first N)`L"

@take.l split.l dropd
@drop.l split.l drop
@copy.l splitReverse.l copy reverseAppend.l put reverse.l
@test.take.l "hello world!" 5 take.l "hello" assertEQ1
@test.drop.l "hello world!" 6 drop.l "world!" assertEQ1
@test.copy.l "hello world!" 5 copy.l "hello" assertEQ1 
 swap "hello world!" assertEQ1 swap

@split.l splitReverse.l reverse.l
@splitReverse.l splitReverseN.l drop
@splitReverseN.l assertNatural [inner.splitReverseN.l] apply2to3
@inner.splitReverseN.l
 swap empty.l swap 
 [cons.l decd] [counter.splitReverseN.l] eachUntil.l 
 swap rot
@counter.splitReverseN.l swap dup 1 lt swapd

@doc.unzip.l "(a*b)`L -- a`L b`L"
@unzip.l unzipReverse.l swap reverse.l swap reverse.l
@unzipReverse.l empty.l empty.l rot unzipReverseAppend.l
@unzipReverseAppend.l [inner.unzipReverseAppend.l] apply3to2
@inner.unzipReverseAppend.l [bicons.unzipReverseAppend.l] each.l
@bicons.unzipReverseAppend.l wx swapd cons.l unrot cons.l swap

@test.unzip.l
  empty.l 
  99 102 pw cons.l
  98 101 pw cons.l
  97 100 pw cons.l
  unzip.l
  "def" assertEQ1 swap
  "abc" assertEQ1 swap


@doc.zip.l "a`L b`L -- (a*b)`L; will truncate if one list is smaller than the other"
@doc.zipRem.l "a`L b`L -- (a*b)`L a(rem)`L b(rem)`L; zip with remainder (in case lists not equal)"
@zip.l zipRevRem.l drop drop reverse.l
@zipRem.l zipRevRem.l rot reverse.l unrot
@zipRevRem.l empty.l unrot zipRevRemApp.l
@zipRevRemApp.l [inner.zipRRA.l] apply3to3
@inner.zipRRA.l [openB.zipRRA.l] fixpoint inline
@openB.zipRRA.l unroll [inL roll drop] [openA.zipRRA.l] if
@openA.zipRRA.l swap [inL swap inR roll drop] [jcons.zipRRA.l] if
@jcons.zipRRA.l zip2 swapd cons.l swap wx roll inline

@test.zip.l.truncateLeft  
  "abcdef" "ghi" zip.l 
  unzip.l 
  "ghi" assertEQ1 swap 
  "abc" assertEQ1 swap
@test.zip.l.truncateRight 
  "abcdef" "ghijklmno" zip.l 
  unzip.l 
  "ghijkl" assertEQ1 swap 
  "abcdef" assertEQ1 swap
@test.zip.l.eqSize 
  "abcdef" "ghijkl" zip.l
  unzip.l
  "ghijkl" assertEQ1 swap
  "abcdef" assertEQ1 swap
@id.unzip.zip.l unzip.l zip.l
@id.zipRem.unzip.l zipRem.l rot unzip.l swapd appendl.l unrot appendl.l swap

@doc.spanP "a`L [a--(a+b)] -- a`L b`L; split longest sequence of `b` results (on right)"
@doc.breakP.l "a`L [a--(b+a)] -- a`L b`L; split longest sequence of `b` results (on left)"
@doc.span.l "a`L [pred(a--Bool)] -- a(rem)`L a`L; split largest prefix for which predicate holds"
@doc.break.l "a`L [pred(a--Bool)] -- a(rem)`L a`L; split largest prefix for which predicate does not hold"
@break.l [not.b] compose span.l
@spanP.l spanRevP.l reverse.l
@breakP.l [mirror] compose spanP.l
@span.l wrapObserver.b spanP.l

@doc.spanRevP "a`L [a--(a+b)] -- a`L b(rev)`L"
@doc.spanRevAppP "b0`L a`L [a--(a+b)] -- (b(rev)++b0)`L a`L"
@spanRevP.l empty.l unrot spanRevAppP.l swap
@spanRevAppP.l applyWrap [open.spanRAP.l] bind fixpoint apply2to2
@open.spanRAP.l swap take2 [inL discard2] [part.spanRAP.l] if
@part.spanRAP.l x put .apply [cons.l discard] [consd.l put inline] if

@test.span.l.cut
 "hello, world!" [32 neqb] span.l
 " world!" assertEQ1d
 "hello,"  assertEQ1
@test.span.l.full
 "hello, world!" [drop true.b] span.l
 empty.l assertEQ1d
 "hello, world!" assertEQ1
@test.span.l.empty
 "hello, world!" [drop false.b] span.l
 "hello, world!" assertEQ1d
 empty.l assertEQ1

@doc.Lists.todo
"* compare length up to a given number (length up to N, returning (N+n(<N))?
 * find, elem, text processing - might be better to pursue a proper
    model of grammars, i.e. such that lists can be split, tokenized, etc.
    But support for 'words' and 'unwords' etc. might be useful.
 * association lists (.al?)
 * list to/from stream
~
@doc.partition.l "(a+b)`L -- a`L b`L; lossy (loses info about interleave)"
@doc.partitionAppendReverse.l "a0`L b0`L (as+bs)`L -- (as(reverse)+a0)`L (bs(reverse)+b0)`L" 
@partitionAppendReverse.l unrot pw swap [pushrv.partition.l] fold.l wx
@pushrv.partition.l [dx cons.l p] [dwx cons.l pw] if
@partitionReverse.l empty.l empty.l rot partitionAppendReverse.l
@partition.l partitionReverse.l reverse.l swap reverse.l swap

@doc.partitionBy.l   "a`L [a--Bool] -- a`L a`L; Copyable a"
@doc.partitionWith.l "a`L [a--(b+c)] -- b`L c`L"
@doc.partitionElem.l "a`L a(m) -- a(≤m)`L a(>m)`L; Comparable a"
@doc.partitionByKey.l "(k*v)`L [k--Bool] -- (k*v)`L (k*v)`L; Copyable k"
@partitionWith.l mapReverse.l partitionReverse.l
@partitionElem.l [lte1] bind partitionWith.l swap
@partitionBy.l wrapObserver.b partitionWith.l
@partitionByKey.l wrapKeyObserver.b partitionWith.l

@test.partition.l 
 "hello, World!" [106 gt1] 
 partitionWith.l
 "lloorl" assertEQ1

@doc.filterBy.l "a`L [a--Bool] -- a`L; Copyable&Droppable a"
@doc.filterWith.l "a`L [a--(b+c)] -- c`L; Droppable b"
@filterWith.l partitionWith.l dropd
@filterBy.l partitionBy.l dropd

@doc.remove.l "a`L a -- a`L; removes values equal by simple comparison"
@remove.l [neq1m] bind filterWith.l
@test.remove.l "hello world" 108 remove.l "heo word" assertEQ 

@doc.nub.l "remove duplicate values from list"
@nub.l [step.nub.l] fixpoint apply
@step.nub.l swap [nip inL] [action.nub.l] if
@action.nub.l x copy remove.l swap inline put cons.l
@test.nub.l "hello, world!" nub.l "helo, wrd!" assertEQ1
@eqv.nub.l.idempotent [nub.l] [nub.l nub.l]

@doc.nubBy.l "a`L [eq(a a -- Bool)] -- a`L; value a, provide eq function"
@nubBy.l [step.nubBy.l] bind fixpoint apply
@step.nubBy.l rot [nip2 inL] [action.nubBy.l] if
@action.nubBy.l x copy rot bind partitionBy.l drop swap inline put cons.l
@test.nubBy.l "hello, world!" [eqb] nubBy.l "helo, wrd!" assertEQ1

@doc.sort.l "sort a list of values"
@sort.l [step.sort.l] fixpoint apply
@step.sort.l swap [nip inL] [nonEmpty.sort.l] if
@nonEmpty.sort.l x copy partitionElem.l rot bi& put cons.l append.l
@test.sort.l "hello, World!" sort.l " !,Wdehllloor" assertEQ1
@eqv.sort.idempotent.l [sort.l] [sort.l sort.l]
@eqv.sort.nub.commutes.l [sort.l nub.l] [nub.l sort.l]

@doc.sortBy.l "a`L [lt(a a -- Bool)]; sort list of values given a less-than function (a a -- Bool)"
@sortBy.l [step.sortBy.l] bind fixpoint apply
@step.sortBy.l rot [nip2 inL] [nonEmpty.sortBy.l] if
@nonEmpty.sortBy.l x copy rot bind partitionBy.l swap rot bi& put cons.l append.l
@test.sortBy.l 
    "hello, World!" [ltb] sortBy.l " !,Wdehllloor" assertEQ
    dup reverse.l swap [gtb] sortBy.l assertEQ1

@doc.sortByKey.l "(k*v)`L [lt(k k -- Bool)]; sort a list by keys"
@sortByKey.l [step.sortByKey.l] bind fixpoint apply
@step.sortByKey.l swap take2 [inL discard2] [nonEmpty.sortByKey.l] if
@nonEmpty.sortByKey.l 
 x dupfst swapd put bind partitionByKey.l
 swap put bi& rot cons.l append.l

@test.sortByKey.l
   "acebdf" "gikhjl"  zip.l
   [ltb] sortByKey.l unzip.l
   "abcdef" assertEQ1d
   "ghijkl" assertEQ1

@doc.ListQueue 
"Model a simple, queue object with a pair of lists.
~
@doc.suffix.lq doc.ListQueue
@sealer.lq [{:lq}]
@unsealer.lq [{.lq}]
@seal.lq sealer.lq .apply
@unseal.lq unsealer.lq .apply
@empty.lq 0 0 pw [] pw seal.lq

