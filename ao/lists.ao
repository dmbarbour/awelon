@doc.Lists
"Lists in AO consist of a finite sequence of pairs terminated by a number. For example, a list of four values might have structure:
 
     (a * (b * (c * (d * N(x))))
 
 In type documentation, this structure might be abbreviated as foo`L, and the number ending the list as foo`Nel. Lists are typically processed by asking of each element 'are you a pair?' (a form of dynamic introspection). If so, the first item is an element in the list, and the second is the rest of the list. The terminating number is not an element of the list, but a useful convention of AO is to make use of different numbers to weakly indicate different types, e.g. to support debugging. A few common numbers:
 
     0: generic list terminator
     3: text (list of integers between 0 and 0x10ffff)
     8: binary (list of integers between 0 and 255)
 
 Relevantly, ending with a different number will impact comparison functions. Also, developers might assert on list terminals to resist accidents. It is a bad idea to conditionally observe a terminal to decide behavior at runtime, but it can be useful in more heuristic contexts (e.g. rendering in a debugger).
 
 Lists are simplistic data structures. Their extreme simplicity is sometimes convenient, but can lead to much awkwardness the moment developers pursue performance:
 
 * access to middle or end of a large list is expensive
 * large lists can be expensive to hold in memory at once
 * iterative operations on a list tend to reverse the list
 * direct list processing is not incremental or compositional
 
 A consequence is that developers cannot easily compose list words to achieve the same performance as developing a new list word. There may be extra reversals, or full-list processing where a short-circuit is feasible. Consequently, developers are encouraged to seek alternatives to lists that avoid these problems. For example, lists are readily translated into streams or sequences. Streams can offer procedural generation and incremental computation. Sequences offer efficient access to the middle and end. There may additionally be some use for some variation of fields that can compute structure on demand.
~

@doc.eachT.l "a`L [a --] -- a`Nel; apply block to each element in list, return term"
@doc.reverseT&append.l "d`L s`L -- (reverse s ++ d)`L s`Nel"

@id.reverseT&append.l 0 swap reverseT&append.l swap reverseT&append.l drop
@test.id.reverseT&append.l 
 "hello, World!" dup 
 [id.reverseT&append.l] apply 
 assertEQ1

@doc.map&reverseT.l "a`L [a -- b] -- b`L(reversed) a`Nel"
@doc.map&reverseT&append.l "b0`L a`L [a--b] -- (b reversed ++ b0)`L a`Nel"
@doc.reverseT.l "a`L -- (reverse a, terminate in 0)`L a`Nel"

@eachT.l [step.eachT.l] bind fixpoint inline
@doc.step.eachT.l "a`L [[a --] step.eachT.l] [a --] -- terminal"
@step.eachT.l
 rot isPair
 [nip2 assertNumber]
 [wx roll p rot dip x inline]
 if

@reverseT&append.l [cons.l] eachTP.l
@reverse&append.l reverseT&append.l drop
@reverseT.l 0 swap reverseT&append.l
@map&reverseT.l 0 unrot map&reverseT&append.l
@map&reverseT&append.l hidingDest.map.l eachT.l
@hidingDest.map.l [dip] bind [swap] [pw] wrapfn

@doc.each.l "a`L [a --] --; apply block to each element in list"
@doc.map.l "a`L [a -- b] -- b`L; apply block modifying each element in list"
@doc.append.l "a1`L a2`L -- (a1 before a2)`L; append two lists"

@each.l      eachT.l drop
@map.l       map&reverseT.l swap reverseT&append.l drop
@append.l swap reverse.l reverse&append.l

@test.append.l 
 "hello, " "World!" append.l
 "hello, World!" assertEQ1

@doc.reverse.l "reverse a list (nel 0)"
@doc.reverseText.l "reverse text (as a list; nel 3)"
@doc.reverseBinary.l "reverse binary list (nel 8)"
@reverse.l reverseT.l drop
@reverseText.l 3 swap reverseT&append.l 3 assertEQ1 drop
@reverseBinary.l 8 swap reverseT&append.l 8 assertEQ1 drop

@test.reverseText.l 
 "hello, World!" reverseText.l
 "!dlroW ,olleh" assertEQ1

@doc.eachTP.l "x y`L [x y -- x] -- x y`Nel; in 'apply' environment"
@doc.eachP.l "x y`L [x y -- x] -- x; in 'apply' environment"
@doc.mapP.l "x`L [x -- y] -- y`L; in 'apply' environment"
@eachTP.l [eachT.l] apply3to2
@eachP.l eachTP.l drop
@mapP.l [apply] bind [map.l] apply2to1 

@doc.eqv.mapTwice.compMap
"Rewriting from a composition of map operations to a map of compositions is a difficult challenge for an optimizer. And proving this is difficult for a prover. In general, if developers need this sort of optimization, they should be using a staged programming model that symbolically constructs the map operations, i.e. initially constructing a free, logical list/stream.
~
@eqv.mapTwice.compMap 
 [compose mapP.l] 
 [unrot mapP.l swap mapP.l]

@length.l 0 swap [drop inc] eachP.l

@test.each.l 0 "World" [.add] eachP.l 520 assertEQ
@test.length.l "hello" length.l 5 assertEQ
@test.map.l "hello" [4 .add] mapP.l "lipps" assertEQ




@doc.scan.l "s a`L [s a -- s b] -- s b`L"
@doc.unzip.l "(a*b)`L -- a`L b`L"
@doc.unzip&reverseT&append.l 
"a0`L b0`L (a*b)`L -- ((reverse a)++a0)`L ((reverse b)++b0)`L a`Nel b`Nel
~

@doc.Lists.todo
"* partition with boolean observer
 * filter with boolean observer
 * nub with boolean observer
 * split, take, drop
 * find, elem
 * match head of list? (need concept for 'match'; maybe part of grammar instead)
 * zip(2..N), unzip(2..N)
 * association lists (.al?)
 * t
 * search lists (with short-circuit)
 * list to/from stream
 * sorted merge of two lists
 * stable-sort a list (with a given sort function)
 * association lists
 * list to/from stream
~

@doc.partition&append&reverseT.l "a0`L b0`L (as+bs)`L -- (as(reverse)+a0)`L (bs(reverse)+b0)`L (as+bs)`Nel" 
@doc.partition.l "(a+b)`L -- a`L b`L"
@partition&append&reverseT.l
 unrot pw swap
 [pushrv.partition.l]
 eachTP.l dwx
@pushrv.partition.l [dx cons.l p] [dwx cons.l pw] if
@partition&reverseT.l 0 0 rot partition&append&reverseT.l
@partition.l
 partition&reverseT.l dup
 rot reverse&append.l
 unrot swap reverse&append.l

@doc.partitionBy.l "a`L [a--(b+c)] -- a`L b`L"
@doc.partitionElem.l "a`L a(m) -- a(≤m)`L a(>m)`L"
@doc.partitionHead.l "(hd*a`L) -- a(≤hd)`L a(>hd)`L"
@partitionBy.l map&reverseT.l dup rot partition&append&reverseT.l drop
@partitionElem.l [lte1] bind partitionBy.l swap
@partitionHead.l x dup dp partitionElem.l

@test.partition.l 
 "hello, World!" [106 gt1] 
 partitionBy.l
 "lloorl" assertEQ1 drop2

@test.partitionHead.l
 "hello, World!" partitionHead.l
 drop "he, Wd!" assertEQ1

@doc.filter.l "a`L [a--(b+c)] -- c`L; Droppable b"
@filter.l partitionBy.l dropd

@doc.remove.l "a`L a -- a`L; removes comparable value"
@remove.l [neq1m] bind filter.l

@test.remove.l "hello world" 108 remove.l "heo word" assertEQ 

@doc.nub.l "remove duplicate values from list"
@nub.l [step.nub.l] fixpoint apply
@step.nub.l
 swap isPair
 [dropd]
 [x copy remove.l swap inline put p]
 if
@test.nub.l "hello, world!" nub.l "helo, wrd!" assertEQ1

@doc.sort.l "sort a list of values"
@sort.l [step.sort.l] fixpoint apply
@step.sort.l swap isPair [dropd] [nonEmpty.sort.l] if
@nonEmpty.sort.l x copy partitionElem.l rot bi& put cons.l append.l
@test.sort.l "hello, World!" sort.l " !,Wdehllloor" assertEQ1

@doc.cons.l "a`L a -- a`L; add element to list"
@cons.l p

@doc.AssocLists
"An 'association list' is a list of (key*value) pairs, where all the keys are comparable. Association lists offer a simple model for data structures. In most cases, association lists are sorted on the key in order to avoid encoding irrelevant information about update order.
~

@doc.ListQueue 
"Model a simple, queue object with a pair of lists.
~
@doc.suffix.lq doc.ListQueue
@sealer.lq [%{:lq}]
@unsealer.lq [%{.lq}]
@seal.lq sealer.lq .apply
@unseal.lq unsealer.lq .apply
@empty.lq 0 0 pw [] pw seal.lq

