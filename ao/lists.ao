@doc.Lists
"Lists in AO are modeled using a recursive type: 
 
     λa.µL.(1+(a*L))       shorthand: a`L
 
 Of course, AO and ABC don't have direct support for type annotations (not yet, anyway). The list structure is, instead, implicitly encoded in the operations over lists. Lists in ABC are always finite, and are often strictly evaluated. Processing lists generally requires fixpoint functions (see @doc.Loops).
 
 Lists are simplistic data structures. Their extreme simplicity leads to akwardness and complexity for many use-cases: 
 
 * access to middle or end of a large list is expensive
 * very large lists can be expensive to hold in memory
 * iterative operations on a list tend to reverse the list
 * direct list processing is not incremental or compositional
 
 Developers are encouraged to use alternative data structures - sequences, streams, functions, etc. - rather than struggle with lists in cases where they're awkward. The primary advantage of lists is they have a strong normal form, suitable for structural comparisons.
~

@doc.empty.l "empty list (has same structure as 'false')"
@empty.l intro1 inL

@doc.cons.l "a`L a -- a`L; add element to list"
@cons.l p inR

@doc.each.l "a`L [a --] --; apply block to each element in list"
@doc.eachUntil.l "a`L [a --] [-- Bool] -- a(rem)`L; each with short circuit (on true)"
@doc.eachWhile.l "a`L [a --] [-- Bool] -- a(rem)`L; each with short circuit (on false)" 
@doc.map.l "a`L [a -- b] -- b`L; apply block modifying each element in list"
@doc.mapP.l "a`L [a -- b] -- b`L; map elements in limited `apply` environment"
@doc.fold.l "x a`L [x a -- x] -- x; process each element in constrained environment"
@doc.length.l "a`L -- a`L integer; return length of list"
@doc.append.l "a1`L a2`L -- (a1 before a2)`L; append two lists"
@doc.reverse.l "a`L -- a`L; reverse order of elements in list"
@doc.reverseAppend.l "a1`L a2`L -- (reverse a2 ++ a1)`L; auxillary"

@each.l [step.each.l] bind fixpoint inline
@step.each.l rot [elim1 drop2] [action.each.l] if
@action.each.l wx roll pw rot dip wx inline
@fold.l [each.l] apply3to1

@map.l mapReverse.l reverse.l
@mapReverse.l empty.l unrot mapReverseAppend.l
@mapReverseAppend.l wrapCons.mapReverseAppend.l each.l
@wrapCons.mapReverseAppend.l [dip] bind [swap] [swap cons.l] wrapfn
@mapP.l [apply] bind [map.l] apply2to1

@append.l swap reverse.l reverseAppend.l
@appendl.l swap append.l
@reverse.l empty.l swap reverseAppend.l
@reverseAppend.l [cons.l] fold.l

@length.l 0 empty.l rot [cons.l incd] [each.l] apply4to2 reverse.l swap
@id.length.l length.l drop

@test.each.l 0 "World" [.add] fold.l 520 assertEQ1
@test.reverse.l 
 "hello, World!" reverse.l 
 "!dlroW ,olleh" assertEQ1
@test.append.l
 "hello, "  "World!" append.l
 "hello, World!" assertEQ1
@test.reverseAppend.l
 " World!" ",olleh" reverseAppend.l
 "hello, World!" assertEQ1
@test.map.l 
 "hello" [4 .add] mapP.l 
 "lipps" assertEQ1
@test.length.l
 "hello" length.l 
 5 assertEQ1 swap
 "hello" assertEQ1 swap
@id.reverse.l reverse.l reverse.l
@eqv.dropReverse.l [drop] [reverse.l drop]
@id.append.l.empty empty.l append.l
@id.appendl.l.empty empty.l appendl.l

@eachWhile.l [not.b] compose eachUntil.l
@eachUntil.l [step.eachUntil.l] bind2 fixpoint inline
@step.eachUntil.l roll [nip3 inL] [cond.eachUntil.l] if
@cond.eachUntil.l swap dip3 roll [action.eachUntil.l] [nip2 inR] if_
@action.eachUntil.l wx roll pw rot dip wx inline

@test.eachUntil.l.haltOnCond
 0 "hello, world!"
 [.add] [dup 600 gtb] eachUntil.l
 "world!" assertEQ1 swap
 608 assertEQ1
@test.eachUntil.l.haltOnLength
 0 "hello, world!"
 [.add] [dup 1200 gtb] eachUntil.l
 empty.l assertEQ1 swap
 1193 assertEQ1 swap
 


@doc.eqv.mapTwice.compMap
"Rewriting from a composition of map operations to a map of compositions is a difficult challenge for an optimizer. And proving this is difficult for a prover. In general, if developers need this sort of optimization, they should be using a staged programming model that symbolically constructs the map operations, i.e. initially constructing a free, logical list/stream.
~
@eqv.mapTwice.compMap 
 [compose mapP.l] 
 [unrot mapP.l swap mapP.l]

@doc.take.l "a`L N -- a`L; take first N elements of list (or the full list, if N >= length), drop rest of list"
@doc.copy.l "a`L N -- a(orig)`L a(first N)`L; copy first N elements of list"
@doc.drop.l "a`L N -- a`L; drop first N elements of list (or result in empty list, if N >= length)"
@doc.split.l "a`L N -- a(minus first N)`L a(first N)`L; combines result of drop and take; linear."
@doc.splitReverse.l "a`L N -- a(minus first N)`L a(first N reversed)`L"
@doc.splitReverseN.l "a`L N -- a(minus first N)`L a(first N reversed)`L N(remaining; 0 if fully used)"
@doc.splitReverseAppendl.l "a0`L a`L N -- (first N from a ++ a0)`L a(minus first N)`L"

@take.l split.l dropd
@drop.l split.l drop
@copy.l splitReverse.l copy reverseAppend.l put reverse.l
@split.l splitReverse.l reverse.l
@splitReverse.l splitReverseN.l drop
@splitReverseN.l assertNatural [inner.splitReverseN.l] apply2to3
@inner.splitReverseN.l
 swap 0 swap 
 [cons.l decd] [counter.splitReverseN.l] eachUntil.l 
 swap rot
@counter.splitReverseN.l swap dup 1 lt swapd

@doc.unzip.l "(a*b)`L -- a`L b`L"
@doc.scan.l "s a`L [s a -- s b] -- s b`L"

@doc.Lists.todo
"
 * filter with boolean observer
 * nub with boolean comparison
 * compare length to a given number (length up to N, returning (N*n(<N))?
 * 
 * split, take, drop? (
 * find, elem
 * match head of list? (need concept for 'match'; maybe part of grammar instead)
 * zip(2..N), unzip(2..N)
 * association lists (.al?)
 * t
 * search lists (with short-circuit)
 * list to/from stream
 * stable-sort a list (with a given sort function)
 * association lists
 * list to/from stream
~
@doc.partition.l "(a+b)`L -- a`L b`L"
@doc.partitionAppendReverse.l "a0`L b0`L (as+bs)`L -- (as(reverse)+a0)`L (bs(reverse)+b0)`L" 
@partitionAppendReverse.l unrot pw swap [pushrv.partition.l] fold.l wx
@pushrv.partition.l [dx cons.l p] [dwx cons.l pw] if
@partitionReverse.l empty.l empty.l rot partitionAppendReverse.l
@partition.l partitionReverse.l reverse.l swap reverse.l swap

@doc.partitionBy.l   "a`L [a--Bool] -- a`L a`L; Copyable a"
@doc.partitionWith.l "a`L [a--(b+c)] -- b`L c`L"
@doc.partitionElem.l "a`L a(m) -- a(≤m)`L a(>m)`L; Comparable a"
@partitionWith.l mapReverse.l partitionReverse.l
@partitionElem.l [lte1] bind partitionWith.l swap
@partitionBy.l wrapObserver.b partitionWith.l

@test.partition.l 
 "hello, World!" [106 gt1] 
 partitionWith.l
 "lloorl" assertEQ1

@doc.filterBy.l "a`L [a--Bool] -- a`L; Copyable&Droppable a"
@doc.filterWith.l "a`L [a--(b+c)] -- c`L; Droppable b"
@filterWith.l partitionWith.l dropd
@filterBy.l partitionBy.l dropd

@doc.remove.l "a`L a -- a`L; removes values equal by simple comparison"
@remove.l [neq1m] bind filterWith.l
@test.remove.l "hello world" 108 remove.l "heo word" assertEQ 

@doc.nub.l "remove duplicate values from list"
@nub.l [step.nub.l] fixpoint apply
@step.nub.l swap [nip inL] [action.nub.l] if
@action.nub.l x copy remove.l swap inline put cons.l
@test.nub.l "hello, world!" nub.l "helo, wrd!" assertEQ1
@eqv.nub.l.idempotent [nub.l] [nub.l nub.l]

@doc.sort.l "sort a list of values"
@sort.l [step.sort.l] fixpoint apply
@step.sort.l swap [nip inL] [nonEmpty.sort.l] if
@nonEmpty.sort.l x copy partitionElem.l rot bi& put cons.l append.l
@test.sort.l "hello, World!" sort.l " !,Wdehllloor" assertEQ1
@eqv.sort.idempotent.l [sort.l] [sort.l sort.l]
@eqv.sort.nub.commutes.l [sort.l nub.l] [nub.l sort.l]

@doc.AssocLists
"An 'association list' is a list of (key*value) pairs, where all the keys are comparable. Association lists offer a simple model for data structures. In most cases, association lists are sorted on the key in order to avoid encoding irrelevant information about update order.
~

@doc.ListQueue 
"Model a simple, queue object with a pair of lists.
~
@doc.suffix.lq doc.ListQueue
@sealer.lq [%{:lq}]
@unsealer.lq [%{.lq}]
@seal.lq sealer.lq .apply
@unseal.lq unsealer.lq .apply
@empty.lq 0 0 pw [] pw seal.lq

