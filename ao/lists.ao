@doc.Lists
"Lists in AO consist of a finite sequence of pairs terminated by a number. For example, a list of four values might have structure:
 
     (a * (b * (c * (d * N(x))))
 
 In type signatures, this structure might be abbreviated as foo`L, and the number ending the list as foo`Nel. Lists are typically processed by asking of each element 'are you a pair?' (a form of dynamic introspection). If so, the first item is an element in the list, and the second is the rest of the list. The terminating number is not an element of the list, but a useful convention of AO is to make use of different numbers to weakly indicate different types, e.g. to support debugging. A few common numbers:
 
     0: generic list terminator
     3: text (list of integers between 0 and 0x10ffff)
     8: binary (list of integers between 0 and 255)
 
 Relevantly, ending with different number does impact comparison functions, and developers may freely assert on list terminals to resist accidents. It is a bad idea to observe a terminal to decide type in any formal sense, but it can be useful in heuristic contexts (e.g. rendering in a debugger).
 
 Lists tend to be reversed every time we process them, and so must be un-reversed when we're done. The list functions tend to include the middle steps with an extra `reverse` in the name. Using the intermediate steps can sometimes be more efficient if one was going to reverse the list again anyway. (Though, this efficiency benefit may eventually vanish if optimizers or ABCD begin to recognize list operations.)
 
 *Aside:* Lists are simplistic, in the sense that they are often overly simple. AO's standard dictionaries should include other data structures more suitable for efficient ad-hoc manipulations. These will include finger-trees, ropes built on finger-trees, and zippers. 
~

@doc.eachT.l "a`L [a --] -- a`Nel; apply block to each element in list, return term"
@doc.reverseT&append.l "d`L s`L -- (reverse s ++ d)`L s`Nel"
@doc.map&reverseT.l "a`L [a -- b] -- b`L(reversed) a`Nel"
@doc.map&reverseT&append.l "b0`L a`L [a--b] -- (b reversed ++ b0)`L a`Nel"
@doc.reverseT.l "a`L -- (reverse a, terminate in 0)`L a`Nel"

@eachT.l [step.eachT.l] bind fixpoint inline
@doc.step.eachT.l "a`L [[a --] step.eachT.l] [a --] -- terminal"
@step.eachT.l
 rot isPair
 [nip2 assertNumber]
 [wx roll p rot dip x inline]
 ifkm!

@reverseT&append.l [cons.l] eachTP.l
@reverse&append.l reverseT&append.l drop
@reverseT.l 0 swap reverseT&append.l
@map&reverseT.l 0 unrot map&reverseT&append.l
@map&reverseT&append.l hidingDest.map.l eachT.l
@hidingDest.map.l [dip] bind [swap] composel [pw] compose

@doc.each.l "a`L [a --] --; apply block to each element in list"
@doc.map.l "a`L [a -- b] -- b`L; apply block modifying each element in list"
@doc.append.l "a1`L a2`L -- (a1 before a2)`L; append two lists"

@each.l      eachT.l drop
@map.l       map&reverseT.l swap reverseT&append.l drop
@append.l swap reverse.l reverse&append.l

@test.append.l 
 "hello, " "World!" append.l
 "hello, World!" assertEQ1

@doc.reverse.l "reverse a list (nel 0)"
@doc.reverseText.l "reverse text (as a list; nel 3)"
@doc.reverseBinary.l "reverse binary list (nel 8)"
@reverse.l reverseT.l drop
@reverseText.l 3 swap reverseT&append.l 3 assertEQ1 drop
@reverseBinary.l 8 swap reverseT&append.l 8 assertEQ1 drop

@doc.eachTP.l "x y`L [x y -- x] -- x y`Nel; in 'apply' environment"
@doc.eachP.l "x y`L [x y -- x] -- x; in 'apply' environment"
@doc.mapP.l "x`L [x -- y] -- y`L; in 'apply' environment"
@eachTP.l [eachT.l] apply3to2
@eachP.l eachTP.l drop
@mapP.l [apply] bind [map.l] apply2to1 

@doc.eqv.mapTwice.compMap
"Rewriting from a composition of map operations to a map of compositions is a difficult challenge for an optimizer. And proving this is difficult for a prover. In general, if developers need this sort of optimization, they should be using a staged programming model that symbolically constructs the map operations, i.e. initially constructing a free, logical list/stream.
~
@eqv.mapTwice.compMap 
 [compose mapP.l] 
 [unrot mapP.l swap mapP.l]

@length.l 0 swap [drop inc] eachP.l

@test.each.l 0 "World" [.add] eachP.l 520 assertEQ
@test.length.l "hello" length.l 5 assertEQ
@test.map.l "hello" [4 .add] mapP.l "lipps" assertEQ

@doc.Lists.todo
"* search lists (with short-circuit)
 * sorted merge of two lists
 * stable-sort a list (with a given sort function)
 * association lists
 * list to/from stream
~

@doc.partition&append&reverseT.l "a0`L b0`L (as+bs)`L -- (as(reverse)+a0)`L (bs(reverse)+b0)`L (as+bs)`Nel" 
@doc.partition.l "(a+b)`L -- a`L b`L"
@partition&append&reverseT.l
 unrot pw swap
 [pushrv.partition.l]
 eachTP.l dwx
@pushrv.partition.l [dx cons.l p] [dwx cons.l pw] ifkm!
@partition&reverseT.l 0 0 rot partition&append&reverseT.l
@partition.l
 partition&reverseT.l dup
 rot reverse&append.l
 unrot swap reverse&append.l

@doc.partitionBy.l "a`L [a--(b+c)] -- a`L b`L"
@doc.partitionElem.l "a`L a(m) -- a(≤m)`L a(>m)`L"
@doc.partitionHead.l "(hd*a`L) -- a(≤hd)`L a(>hd)`L"
@partitionBy.l map&reverseT.l dup rot partition&append&reverseT.l drop
@partitionElem.l [lte1] bind partitionBy.l swap
@partitionHead.l x dup dp partitionElem.l

@test.partition.l 
 "hello, World!" [106 gt1] 
 partitionBy.l
 "lloorl" assertEQ1 drop2

@test.partitionHead.l
 "hello, World!" partitionHead.l
 drop "he, Wd!" assertEQ1

@doc.filter.l "a`L [a--(b+c)] -- c`L; Droppable b"
@filter.l partitionBy.l dropd

@doc.remove.l "a`L a -- a`L; removes comparable value"
@remove.l [neq1m] bind filter.l

@test.remove.l "hello world" 108 remove.l "heo word" assertEQ 

@doc.nub.l "remove duplicate values from list"
@doc.sort.l "sort a list of values"

@nub.l [step.nub.l] fixpoint apply
@step.nub.l
 swap isPair
 [dropd]
 [x copy remove.l swap inline put p]
 ifkm!
@test.nub.l "hello, world!" nub.l "helo, wrd!" assertEQ1

@sort.l [step.sort.l] fixpoint apply
@step.sort.l swap isPair [dropd] [nonEmpty.sort.l] ifkm!
@nonEmpty.sort.l x copy partitionElem.l rot bi& put cons.l append.l
@test.sort.l "hello, World!" sort.l " !,Wdehllloor" assertEQ1

@doc.cons.l "a`L a -- a`L; add element to list"
@cons.l p


@doc.AssocLists
"An 'association list' is a list of (key*value) pairs, where all the keys are comparable. Association lists offer a simple model for data structures. In most cases, association lists are sorted on the key in order to avoid encoding irrelevant information about update order.
~

@doc.ListQueue 
"Model a simple, queue object with a pair of lists.
~
@doc.suffix.lq doc.ListQueue
@sealer.lq [%{:lq}]
@unsealer.lq [%{.lq}]
@seal.lq sealer.lq .apply
@unseal.lq unsealer.lq .apply
@empty.lq 0 0 pw [] pw seal.lq

