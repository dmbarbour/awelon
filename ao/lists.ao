@doc.Lists
"Lists in AO consist of a finite sequence of pairs terminated by a number. For example, a list of four values might have structure:
 
     (a * (b * (c * (d * N(x))))
 
 In type signatures, this structure might be abbreviated as foo`L, and the number ending the list as foo`Nel. Lists are typically processed by asking of each element 'are you a pair?' (a form of dynamic introspection). If so, the first item is an element in the list, and the second is the rest of the list. The terminating number is not an element of the list, but a useful convention of AO is to make use of different numbers to weakly indicate different types, e.g. to support debugging. A few common numbers:
 
     0: generic list terminator
     3: text (list of integers between 0 and 0x10ffff)
     8: binary (list of integers between 0 and 255)
 
 Relevantly, ending with different number does impact comparison functions, and developers may freely assert on list terminals to resist accidents. It is a bad idea to observe a terminal to decide type in any formal sense, but it can be useful in heuristic contexts (e.g. rendering in a debugger).
 
 Lists tend to be reversed every time we process them, and so must be un-reversed when we're done. The list functions tend to include the middle steps with an extra `reverse` in the name. Using the intermediate steps can sometimes be more efficient if one was going to reverse the list again anyway. (Though, this efficiency benefit may eventually vanish if optimizers or ABCD begin to recognize list operations.)
 
 *Aside:* Lists are simplistic, in the sense that they are often overly simple. AO's standard dictionaries should include other data structures more suitable for efficient ad-hoc manipulations. These will include finger-trees, ropes built on finger-trees, and zippers. 
~

@doc.eachT.list "a`L [a --] -- a`Nel; apply block to each element in list, return term"
@doc.reverseT&append.list "d`L s`L -- (reverse s ++ d)`L s`Nel"
@doc.map&reverseT.list "a`L [a -- b] -- b`L(reversed) a`Nel"
@doc.map&reverseT&append.list "b0`L a`L [a--b] -- (b reversed ++ b0)`L a`Nel"
@doc.reverseT.list "a`L -- (reverse a, terminate in 0)`L a`Nel"

@eachT.list [step.eachT.list] bind fixpoint inline
@doc.step.eachT.list "a`L [[a --] step.eachT.list] [a --] -- terminal"
@step.eachT.list
 rot isPair
 [nip2 assertNumber]
 [wx roll p rot dip x inline]
 ifk merged inline

@reverseT&append.list [p] eachT.list
@reverse&append.list reverseT&append.list drop
@reverseT.list 0 swap reverseT&append.list
@map&reverseT.list 0 unrot map&reverseT&append.list
@map&reverseT&append.list hidingDest.map.list eachT.list
@hidingDest.map.list [dip] bind [swap] composel [pw] compose

@doc.each.list "a`L [a --] --; apply block to each element in list"
@doc.map.list "a`L [a -- b] -- b`L; apply block modifying each element in list"

@each.list      eachT.list drop
@map.list       map&reverseT.list swap reverseT&append.list drop

@doc.eachTP.list "x y`L [x y -- x] -- x y`Nel; in 'apply' environment"
@doc.eachP.list "x y`L [x y -- x] -- x; in 'apply' environment"
@doc.mapP.list "x`L [x -- y] -- y`L; in 'apply' environment"
@eachTP.list p p [x x eachT.list p] apply x
@eachP.list eachTP.list drop
@mapP.list [apply] bind p [x map.list] apply 

@length.list 0 swap [drop inc] eachP.list

@test.each.list 0 "World" [.add] eachP.list 520 assertEQ
@test.length.list "hello" length.list 5 assertEQ
@test.map.list "hello" [4 .add] mapP.list "lipps" assertEQ

@doc.lists.todo
" * search lists (with short-circuit)
  * remove duplicates from a list
  * filter list by some criterion
  * sorted merge of two lists
  * stable-sort a list (with a given sort function)
  * association lists
  * list to/from stream
~

@doc.partition.list "(a+b)`L -- a`L b`L"
@partition.list 
 0 0 pw swap 
 [push.partition.list] eachTP.list
 dx dup rot 
 reverse&append.list
 unrot swap
 reverse&append.list
@push.partition.list
 [dx p p]
 [dwx p pw]
 ifk merged inline

@doc.partitionBy.list "a`L [a--(b+c)] -- a`L b`L"
@partitionBy.list mapP.list partition.list

@test.partition.list 
 "hello, World!" [106 gt1] 
 partitionBy.list
 "lloorl" assertEQ drop2 

@doc.filter.list "a`L [a--(b+c)] -- c`L; Droppable b"
@filter.list partitionBy.list dropd

@doc.remove.list "a`L a -- a`L; removes comparable value"
@remove.list [neq1m] bind filter.list

@test.remove.list "hello world" 108 remove.list "heo word" assertEQ 

@doc.nub.list "remove duplicate values from list"
@doc.sort.list "sort a list of values"

@doc.AssocLists
"An 'association list' is a list of (key*value) pairs, where all the keys are comparable. Association lists offer a simple model for data structures. In most cases, association lists are sorted on the key in order to avoid encoding irrelevant information about update order.
~

@doc.ListQueue 
"Model a simple, queue object with a pair of lists.
~
@doc.suffix.lq doc.ListQueue
@sealer.lq [%{:lq}]
@unsealer.lq [%{.lq}]
@seal.lq sealer.lq .apply
@unseal.lq unsealer.lq .apply
@empty.lq 0 0 pw [] pw seal.lq
@copy.lq 

