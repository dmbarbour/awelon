@doc.Lists
"Lists in AO consist of a finite sequence of pairs terminated by a number. For example, a list of four values might have structure:
 
     (a * (b * (c * (d * N(x))))
 
 In type documentation, this structure might be abbreviated as foo`L, and the number ending the list as foo`Nel. Lists are typically processed by asking of each element 'are you a pair?' (a form of dynamic introspection). If so, the first item is an element in the list, and the second is the rest of the list. The terminating number is not an element of the list, but a useful convention of AO is to make use of different numbers to weakly indicate different types, e.g. to support debugging. A few common numbers:
 
     0: generic list terminator
     3: text (list of integers between 0 and 0x10ffff)
     8: binary (list of integers between 0 and 255)
 
 Relevantly, ending with a different number will impact comparison functions. Also, developers might assert on list terminals to resist accidents. It is a bad idea to conditionally observe a terminal to decide behavior at runtime, but it can be useful in more heuristic contexts (e.g. rendering in a debugger).
 
 Lists are simplistic data structures. Their extreme simplicity is sometimes convenient, but can lead to much awkwardness the moment developers pursue performance:
 
 * access to middle or end of a large list is expensive
 * very large lists can be expensive to hold in memory
 * iterative operations on a list tend to reverse the list
 * direct list processing is not incremental or compositional
 
 A consequence is that developers cannot easily compose list words to achieve the same performance as developing a new list word. There may be extra reversals, or full-list processing where a short-circuit is feasible. Consequently, developers are encouraged to seek alternatives to lists that avoid these problems. For example, lists are readily translated into streams or sequences. Streams offer procedural generation and incremental computation. Sequences offer efficient access to the middle and end. There may additionally be some use for multi-dimensional fields that can compute volumes lazily or on demand.
~

@doc.each.l "a`L [a --] --; apply block to each element in list"
@doc.eachUntil.l "a`L [a --] [-- Bool] -- a(rem)`L; each with short circuit (on true)"
@doc.eachWhile.l "a`L [a --] [-- Bool] -- a(rem)`L; each with short circuit (on false)" 
@doc.map.l "a`L [a -- b] -- b`L; apply block modifying each element in list"
@doc.append.l "a1`L a2`L -- (a1 before a2)`L; append two lists"

@each.l    eachT.l drop
@map.l     mapReverseT.l swap reverseAppendT.l drop
@append.l  swap reverse.l reverseAppend.l
@appendl.l swap append.l
@eachWhile.l [not] compose eachUntil.l

@doc.eachT.l "a`L [a --] -- a`Nel; apply block to each element in list, return term"
@doc.reverseAppendT.l "d`L s`L -- (reverse s ++ d)`L s`Nel"

@id.reverseAppendT.l 0 swap reverseAppendT.l swap reverseAppendT.l drop
@test.id.reverseAppendT.l 
 "hello, World!" dup 
 [id.reverseAppendT.l] apply 
 assertEQ1

@doc.mapReverseT.l "a`L [a -- b] -- b`L(reversed) a`Nel"
@doc.mapReverseAppendT.l "b0`L a`L [a--b] -- (b reversed ++ b0)`L a`Nel"
@doc.reverseT.l "a`L -- (reverse a, terminate in 0)`L a`Nel"

@eachT.l [step.eachT.l] bind fixpoint inline
@doc.step.eachT.l "a`L [[a --] step.eachT.l] [a --] -- terminal"
@step.eachT.l
 rot isPair
 [nip2 assertNumber]
 [wx roll pw rot dip wx inline]
 if

@eachUntil.l [step.eachUntil.l] bind2 fixpoint inline
@step.eachUntil.l roll isPair [nip3] [cond.eachUntil.l] if
@cond.eachUntil.l swap dip3 roll [action.eachUntil.l] [nip2] if_
@doc.action.eachUntil.l "[fixed step] [body] (x*xs) -- ..."
@action.eachUntil.l wx roll pw rot dip wx inline

@test.eachUntil.l 
 0 "hello, world!"
 [.add] [dup 600 gtb] eachUntil.l
 "world!" assertEQ1 swap
 608 assertEQ1

@reverseAppendT.l [cons.l] eachTP.l
@reverseAppend.l reverseAppendT.l drop
@reverseT.l 0 swap reverseAppendT.l
@mapReverseT.l 0 unrot mapReverseAppendT.l
@mapReverseAppendT.l hidingDest.map.l eachT.l
@hidingDest.map.l [dip] bind [swap] [pw] wrapfn


@test.append.l 
 "hello, "     "World!"     append.l
 "hello, World!" assertEQ1

@doc.reverse.l "reverse a list (nel 0)"
@doc.reverseText.l "reverse text list (nel 3)"
@doc.reverseBinary.l "reverse binary list (nel 8)"
@reverse.l reverseT.l drop
@reverseText.l 3 swap reverseAppend.l
@reverseBinary.l 8 swap reverseAppend.l

@test.reverseText.l 
 "hello, World!" reverseText.l
 "!dlroW ,olleh" assertEQ1

@doc.eachTP.l "x y`L [x y -- x] -- x y`Nel; in 'apply' environment"
@doc.eachP.l "x y`L [x y -- x] -- x; in 'apply' environment"
@doc.mapP.l "x`L [x -- y] -- y`L; in 'apply' environment"
@eachTP.l [eachT.l] apply3to2
@eachP.l eachTP.l drop
@mapP.l [apply] bind [map.l] apply2to1 

@doc.eqv.mapTwice.compMap
"Rewriting from a composition of map operations to a map of compositions is a difficult challenge for an optimizer. And proving this is difficult for a prover. In general, if developers need this sort of optimization, they should be using a staged programming model that symbolically constructs the map operations, i.e. initially constructing a free, logical list/stream.
~
@eqv.mapTwice.compMap 
 [compose mapP.l] 
 [unrot mapP.l swap mapP.l]

@length.l 0 swap [drop inc] eachP.l

@test.each.l 0 "World" [.add] eachP.l 520 assertEQ
@test.length.l "hello" length.l 5 assertEQ
@test.map.l "hello" [4 .add] mapP.l "lipps" assertEQ

@doc.take.l "a`L N -- a`L; take first N elements of list (or the full list, if N >= length), drop rest of list"
@doc.copy.l "a`L N -- a(orig)`L a(first N)`L; copy first N elements of list"
@doc.drop.l "a`L N -- a`L; drop first N elements of list (or result in empty list, if N >= length)"
@doc.split.l "a`L N -- a(minus first N)`L a(first N)`L; combines result of drop and take; linear."
@doc.splitReverse.l "a`L N -- a(minus first N)`L a(first N reversed)`L"
@doc.splitReverseN.l "a`L N -- a(minus first N)`L a(first N reversed)`L N(remaining; 0 if fully used)"
@doc.splitReverseAppendl.l "a0`L a`L N -- (first N from a ++ a0)`L a(minus first N)`L"

@take.l split.l dropd
@drop.l split.l drop
@copy.l splitReverse.l copy reverseAppend.l put reverse.l
@split.l splitReverse.l reverse.l
@splitReverse.l splitReverseN.l drop
@splitReverseN.l assertNatural [inner.splitReverseN.l] apply2to3
@inner.splitReverseN.l 
  swap 0 swap 
  [cons.l decd] [counter.splitReverseN.l] eachUntil.l
  swap rot
@counter.splitReverseN.l swap dup 1 lt swapd

@takeText.l splitReverse.l reverseText.l dropd
@copyText.l splitReverse.l copy reverseAppend.l put reverseText.l


@doc.unzip.l "(a*b)`L -- a`L b`L"
@doc.scan.l "s a`L [s a -- s b] -- s b`L"

@doc.Lists.todo
"* partition with boolean observer
 * filter with boolean observer
 * nub with boolean comparison
 * compare length to a given number (length up to N, returning (N*n(<N))?
 * 
 * split, take, drop? (
 * find, elem
 * match head of list? (need concept for 'match'; maybe part of grammar instead)
 * zip(2..N), unzip(2..N)
 * association lists (.al?)
 * t
 * search lists (with short-circuit)
 * list to/from stream
 * stable-sort a list (with a given sort function)
 * association lists
 * list to/from stream
~

@doc.partitionAppendReverseT.l "a0`L b0`L (as+bs)`L -- (as(reverse)+a0)`L (bs(reverse)+b0)`L (as+bs)`Nel" 
@doc.partition.l "(a+b)`L -- a`L b`L"
@partitionAppendReverseT.l unrot pw swap [pushrv.partition.l] eachTP.l dwx
@pushrv.partition.l [dx cons.l p] [dwx cons.l pw] if
@partitionReverseT.l 0 0 rot partitionAppendReverseT.l
@partition.l partitionReverseT.l dup rot reverseAppend.l unrot swap reverseAppend.l

@doc.partitionBy.l   "a`L [a--Bool] -- a`L a`L"
@doc.partitionWith.l "a`L [a--(b+c)] -- a`L b`L"
@doc.partitionElem.l "a`L a(m) -- a(â‰¤m)`L a(>m)`L; Comparable a"
@partitionWith.l mapReverseT.l dup rot partitionAppendReverseT.l drop
@partitionElem.l [lte1] bind partitionWith.l swap
@partitionBy.l wrapObserver.b partitionWith.l

@test.partition.l 
 "hello, World!" [106 gt1] 
 partitionWith.l
 "lloorl" assertEQ1 drop2

@doc.filterBy.l "a`L [a--Bool] -- a`L; Droppable a"
@doc.filterWith.l "a`L [a--(b+c)] -- c`L; Droppable b"
@filterWith.l partitionWith.l dropd
@filterBy.l partitionBy.l dropd

@doc.remove.l "a`L a -- a`L; removes values equal by simple comparison"
@remove.l [neq1m] bind filterWith.l
@test.remove.l "hello world" 108 remove.l "heo word" assertEQ 

@doc.nub.l "remove duplicate values from list"
@nub.l [step.nub.l] fixpoint apply
@step.nub.l
 swap isPair
 [dropd]
 [x copy remove.l swap inline put p]
 if
@test.nub.l "hello, world!" nub.l "helo, wrd!" assertEQ1

@doc.sort.l "sort a list of values"
@sort.l [step.sort.l] fixpoint apply
@step.sort.l swap isPair [dropd] [nonEmpty.sort.l] if
@nonEmpty.sort.l x copy partitionElem.l rot bi& put cons.l append.l
@test.sort.l "hello, World!" sort.l " !,Wdehllloor" assertEQ1

@doc.cons.l "a`L a -- a`L; add element to front of list"
@cons.l p

@doc.AssocLists
"An 'association list' is a list of (key*value) pairs, where all the keys are comparable. Association lists offer a simple model for data structures. In most cases, association lists are sorted on the key in order to avoid encoding irrelevant information about update order.
~

@doc.ListQueue 
"Model a simple, queue object with a pair of lists.
~
@doc.suffix.lq doc.ListQueue
@sealer.lq [%{:lq}]
@unsealer.lq [%{.lq}]
@seal.lq sealer.lq .apply
@unseal.lq unsealer.lq .apply
@empty.lq 0 0 pw [] pw seal.lq

