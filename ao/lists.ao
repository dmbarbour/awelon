@doc.Lists
"Lists in AO consist of a finite sequence of pairs terminated by a number. For example, a list of four values might have structure:
 
     (a * (b * (c * (d * N(x))))
 
 In type signatures, this structure might be abbreviated as foo`L, and the number ending the list as foo`Nel. Lists are typically processed by asking of each element 'are you a pair?' (a form of dynamic introspection). If so, the first item is an element in the list, and the second is the rest of the list. The terminating number is not an element of the list, but a useful convention of AO is to make use of different numbers to weakly indicate different types, e.g. to support debugging. A few common numbers:
 
     0: generic list terminator
     3: text (list of integers between 0 and 0x10ffff)
     8: binary (list of integers between 0 and 255)
 
 Relevantly, ending with different number does impact comparison functions, and developers may freely assert on list terminals to resist accidents. It is a bad idea to observe a terminal to decide type in any formal sense, but it can be useful in heuristic contexts (e.g. rendering in a debugger).
 
 Lists tend to be reversed every time we process them, and so must be un-reversed when we're done. The list functions tend to include the middle steps with an extra `reverse` in the name. Using the intermediate steps can sometimes be more efficient if one was going to reverse the list again anyway. (Though, this efficiency benefit may eventually vanish if optimizers or ABCD begin to recognize list operations.)
 
 *Aside:* Lists are simplistic, in the sense that they are often overly simple. AO's standard dictionaries should include other data structures more suitable for efficient ad-hoc manipulations. These will include finger-trees, ropes built on finger-trees, and zippers. 
~

@doc.eachT.list "a`L [a --] -- a`Nel; apply block to each element in list, return term"
@doc.reverseT&append.list "dest`L src`L -- (reverse src ++ dest)`L src`Nel" 
@doc.map&reverseT.list "a`L [a -- b] -- b`L(reverse order) Nterm; eqv. to `map reverseT`"
@doc.reverseT&append.list "d`L s`L -- (reverse s ++ d)`L s`Nel"
@doc.reverseT.list "a`L -- (reverse a, terminate in 0)`L a`Nel"

@eachT.list [step.eachT.list] bind fixpoint inline
@doc.step.eachT.list "a`L [[a --] step.eachT.list] [a --] -- terminal"
@step.eachT.list
 rot isPair
 [nip2 assertNumber]
 [wx roll p rot dip x inline]
 ifk merged inline
@reverseT&append.list [p] eachT
@reverseT.list 0 swap reverseT&append.list

@map&reverseT.list 0 unrot map&reverseT&append.list

[step.map&reverseT] bind fixpoint inline
@doc.step.map&reverseT "a`L [[a--b] step.map&reverseT] [a--b] -- b`L(reversed) term"
@step.map&reverseT
 rot isPair
 [assertNumber 


@doc.each.list "a`L [a --] --; apply block to each element in list, left to right"
@doc.map.list "a`L [a -- b] -- b`L; process elements in list left to right, preserve terminal"
@doc.reverse&append.list "a`L(dest) a`L(src) -- a`L(reverse src ++ dest)"
@doc.map&append.list "b`L a`L [a -- b] -- b`L"
@doc.reverse.list "a`L -- a`L (reverse order); loses information about terminal"

@each.list eachT.list assertNumber drop
@reverse.list reverseT.list assertNumber drop
@reverse&append.list reverseT&append.list assertNumber drop
@map.list map&reverseT.list swap reverse&append.list
@length.list 0 swap [drop inc] each.list

@each each.list
@map map.list
@reverse reverse.list
