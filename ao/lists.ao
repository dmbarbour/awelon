@doc.Lists
"Lists in AO are modeled using a recursive type: 
 
     λa.µL.(1+(a*L))       shorthand: a`L
 
 Of course, AO and ABC don't have direct support for type annotations (not yet, anyway). The list structure is, instead, implicitly encoded in the operations over lists. Lists in ABC are always finite, and are often strictly evaluated. Processing lists generally requires fixpoint functions (see @doc.Loops).
 
 Lists are simplistic data structures. Their extreme simplicity leads to awkwardness and complexity for many use-cases: 
 
 * access to middle or end of a large list is expensive
 * very large lists can be expensive to hold in memory
 * iterative operations on a list tend to reverse the list
 * direct list processing is not incremental or compositional
 
 Developers are encouraged to use alternative data structures - sequences, streams, functions, etc. - rather than struggle with lists in cases where they're awkward. The primary advantage of lists is they have a strong normal form, suitable for structural comparisons.
~

@doc.empty.l "empty list (has same structure as 'false')"
@empty.l intro1 inL

@doc.cons.l "a`L a -- a`L; add element to list"
@cons.l p inR

@doc.each.l "a`L [a --] --; apply block to each element in list"
@doc.eachUntil.l "a`L [a --] [-- Bool] -- a(rem)`L; each with short circuit (on true)"
@doc.eachWhile.l "a`L [a --] [-- Bool] -- a(rem)`L; each with short circuit (on false)" 
@doc.map.l "a`L [a -- b] -- b`L; apply block modifying each element in list"
@doc.mapP.l "a`L [a -- b] -- b`L; map elements in limited `apply` environment"
@doc.fold.l "x a`L [x a -- x] -- x; process each element in constrained environment"
@doc.scan.l "s a`L [s a -- s b] -- s b`L; simultaneous map & fold in limited env"
@doc.length.l "a`L -- a`L integer; return length of list"
@doc.append.l "a1`L a2`L -- (a1 before a2)`L; append two lists"
@doc.reverse.l "a`L -- a`L; reverse order of elements in list"
@doc.reverseAppend.l "a1`L a2`L -- (reverse a2 ++ a1)`L; auxillary"

@each.l [step.each.l] bind fixpoint inline
@step.each.l rot [elim1 drop2] [action.each.l] if
@action.each.l wx roll pw rot dip wx inline
@fold.l [each.l] apply3to1

@map.l mapReverse.l reverse.l
@mapReverse.l empty.l unrot mapReverseAppend.l
@mapReverseAppend.l wrapCons.mapReverseAppend.l each.l
@wrapCons.mapReverseAppend.l [dip] bind [swap] [swap cons.l] wrapfn
@mapP.l [apply] bind [map.l] apply2to1
@scan.l [map.l] apply3to2

@append.l swap reverse.l reverseAppend.l
@appendl.l swap append.l
@reverse.l empty.l swap reverseAppend.l
@reverseAppend.l [cons.l] fold.l

@length.l 0 empty.l rot [cons.l incd] [each.l] apply4to2 reverse.l swap
@id.length.l length.l drop

@test.each.l 0 "World" [.add] fold.l 520 assertEQ1
@test.reverse.l 
 "hello, World!" reverse.l 
 "!dlroW ,olleh" assertEQ1
@test.append.l
 "hello, "  "World!" append.l
 "hello, World!" assertEQ1
@test.reverseAppend.l
 " World!" ",olleh" reverseAppend.l
 "hello, World!" assertEQ1
@test.map.l 
 "hello" [4 .add] mapP.l 
 "lipps" assertEQ1
@test.scan.l
 0 "hello" [dup rot .add swap 4 .add] scan.l
 "lipps" assertEQ1 swap
 532 assertEQ1 swap
@test.length.l
 "hello" length.l 
 5 assertEQ1 swap
 "hello" assertEQ1 swap
@id.reverse.l reverse.l reverse.l
@eqv.dropReverse.l [drop] [reverse.l drop]
@id.append.l.empty empty.l append.l
@id.appendl.l.empty empty.l appendl.l

@eachWhile.l [not.b] compose eachUntil.l
@eachUntil.l [step.eachUntil.l] bind2 fixpoint inline
@step.eachUntil.l roll [nip3 inL] [cond.eachUntil.l] if
@cond.eachUntil.l swap dip3 roll [action.eachUntil.l] [nip2 inR] if_
@action.eachUntil.l wx roll pw rot dip wx inline

@test.eachUntil.l.haltOnCond
 0 "hello, world!"
 [.add] [dup 600 gtb] eachUntil.l
 "world!" assertEQ1 swap
 608 assertEQ1
@test.eachUntil.l.haltOnLength
 0 "hello, world!"
 [.add] [dup 1200 gtb] eachUntil.l
 empty.l assertEQ1 swap
 1193 assertEQ1 swap

@doc.eqv.mapTwice.compMap
"Rewriting from a composition of map operations to a map of compositions is a difficult challenge for an optimizer. And proving this is difficult for a prover. In general, if developers need this sort of optimization, they should be using a staged programming model that symbolically constructs the map operations, i.e. initially constructing a free, logical list/stream.
~
@eqv.mapTwice.compMap 
 [compose mapP.l] 
 [unrot mapP.l swap mapP.l]

@doc.take.l "a`L N -- a`L; take first N elements of list (or the full list, if N >= length), drop rest of list"
@doc.copy.l "a`L N -- a(orig)`L a(first N)`L; copy first N elements of list"
@doc.drop.l "a`L N -- a`L; drop first N elements of list (or result in empty list, if N >= length)"
@doc.split.l "a`L N -- a(minus first N)`L a(first N)`L; combines result of drop and take; linear."
@doc.splitReverse.l "a`L N -- a(minus first N)`L a(first N reversed)`L"
@doc.splitReverseN.l "a`L N -- a(minus first N)`L a(first N reversed)`L N(remaining; 0 if fully used)"
@doc.splitReverseAppendl.l "a0`L a`L N -- (first N from a ++ a0)`L a(minus first N)`L"

@take.l split.l dropd
@drop.l split.l drop
@copy.l splitReverse.l copy reverseAppend.l put reverse.l
@test.take.l "hello world!" 5 take.l "hello" assertEQ1
@test.drop.l "hello world!" 6 drop.l "world!" assertEQ1
@test.copy.l "hello world!" 5 copy.l "hello" assertEQ1 
 swap "hello world!" assertEQ1 swap

@split.l splitReverse.l reverse.l
@splitReverse.l splitReverseN.l drop
@splitReverseN.l assertNatural [inner.splitReverseN.l] apply2to3
@inner.splitReverseN.l
 swap empty.l swap 
 [cons.l decd] [counter.splitReverseN.l] eachUntil.l 
 swap rot
@counter.splitReverseN.l swap dup 1 lt swapd

@doc.unzip.l "(a*b)`L -- a`L b`L"
@unzip.l unzipReverse.l swap reverse.l swap reverse.l
@unzipReverse.l empty.l empty.l rot unzipReverseAppend.l
@unzipReverseAppend.l [inner.unzipReverseAppend.l] apply3to2
@inner.unzipReverseAppend.l [bicons.unzipReverseAppend.l] each.l
@bicons.unzipReverseAppend.l wx swapd cons.l unrot cons.l swap

@test.unzip.l
  empty.l 
  99 102 pw cons.l
  98 101 pw cons.l
  97 100 pw cons.l
  unzip.l
  "def" assertEQ1 swap
  "abc" assertEQ1 swap


@doc.zip.l "a`L b`L -- (a*b)`L; will truncate if one list is smaller than the other"
@zip.l zipReverse.l reverse.l
@zipReverse.l empty.l unrot zipReverseAppend.l
@zipReverseAppend.l [inner.zipReverseAppend.l] apply3to1
@inner.zipReverseAppend.l [openB.zipReverseAppend.l] fixpoint inline
@openB.zipReverseAppend.l unroll [elim1 drop dropd] [openA.zipReverseAppend.l] if
@openA.zipReverseAppend.l swap   [elim1 drop dropd] [jcons.zipReverseAppend.l] if
@jcons.zipReverseAppend.l zip2 swapd cons.l swap wx roll inline
@comments.zip.l
"This is quite inelegant as is. I wonder if translating lists to streams, then zipping streams, would be cleaner."

@id.unzip.zip.l unzip.l zip.l

@doc.Lists.todo
"* compare length up to a given number (length up to N, returning (N+n(<N))?
 * 
 * find, elem
 * match head of list? 
 *   need concept for 'match' 
 *   maybe part of stream-processing grammar instead? (could optimize better)
 * zip(2..N), unzip(2..N)
 * association lists (.al?)
 * t
 * search lists (with short-circuit)
 * list to/from stream
 * stable-sort a list (with a given sort function)
 * association lists
 * list to/from stream
~
@doc.partition.l "(a+b)`L -- a`L b`L; lossy (loses info about interleave)"
@doc.partitionAppendReverse.l "a0`L b0`L (as+bs)`L -- (as(reverse)+a0)`L (bs(reverse)+b0)`L" 
@partitionAppendReverse.l unrot pw swap [pushrv.partition.l] fold.l wx
@pushrv.partition.l [dx cons.l p] [dwx cons.l pw] if
@partitionReverse.l empty.l empty.l rot partitionAppendReverse.l
@partition.l partitionReverse.l reverse.l swap reverse.l swap

@doc.partitionBy.l   "a`L [a--Bool] -- a`L a`L; Copyable a"
@doc.partitionWith.l "a`L [a--(b+c)] -- b`L c`L"
@doc.partitionElem.l "a`L a(m) -- a(≤m)`L a(>m)`L; Comparable a"
@partitionWith.l mapReverse.l partitionReverse.l
@partitionElem.l [lte1] bind partitionWith.l swap
@partitionBy.l wrapObserver.b partitionWith.l

@test.partition.l 
 "hello, World!" [106 gt1] 
 partitionWith.l
 "lloorl" assertEQ1

@doc.filterBy.l "a`L [a--Bool] -- a`L; Copyable&Droppable a"
@doc.filterWith.l "a`L [a--(b+c)] -- c`L; Droppable b"
@filterWith.l partitionWith.l dropd
@filterBy.l partitionBy.l dropd

@doc.remove.l "a`L a -- a`L; removes values equal by simple comparison"
@remove.l [neq1m] bind filterWith.l
@test.remove.l "hello world" 108 remove.l "heo word" assertEQ 

@doc.nub.l "remove duplicate values from list"
@nub.l [step.nub.l] fixpoint apply
@step.nub.l swap [nip inL] [action.nub.l] if
@action.nub.l x copy remove.l swap inline put cons.l
@test.nub.l "hello, world!" nub.l "helo, wrd!" assertEQ1
@eqv.nub.l.idempotent [nub.l] [nub.l nub.l]

@doc.nubBy.l "a`L [eq(a a -- Bool)] -- a`L; value a, provide eq function"
@nubBy.l [step.nubBy.l] bind fixpoint apply
@step.nubBy.l rot [nip2 inL] [action.nubBy.l] if
@action.nubBy.l x copy rot bind partitionBy.l drop swap inline put cons.l
@test.nubBy.l "hello, world!" [eqb] nubBy.l "helo, wrd!" assertEQ1

@doc.sort.l "sort a list of values"
@sort.l [step.sort.l] fixpoint apply
@step.sort.l swap [nip inL] [nonEmpty.sort.l] if
@nonEmpty.sort.l x copy partitionElem.l rot bi& put cons.l append.l
@test.sort.l "hello, World!" sort.l " !,Wdehllloor" assertEQ1
@eqv.sort.idempotent.l [sort.l] [sort.l sort.l]
@eqv.sort.nub.commutes.l [sort.l nub.l] [nub.l sort.l]

@doc.sortBy.l "a`L [lt(a a -- Bool)]; sort list of values given a less-than function (a a -- Bool)"
@sortBy.l [step.sortBy.l] bind fixpoint apply
@step.sortBy.l rot [nip2 inL] [nonEmpty.sortBy.l] if
@nonEmpty.sortBy.l x copy rot bind partitionBy.l swap rot bi& put cons.l append.l
@test.sortBy.l 
    "hello, World!" [ltb] sortBy.l " !,Wdehllloor" assertEQ
    dup reverse.l swap [gtb] sortBy.l assertEQ1


@doc.AssocLists
"An 'association list' is a list of (key*value) pairs, where all the keys are comparable. Association lists offer a simple model for data structures. In most cases, association lists are sorted on the key in order to avoid encoding irrelevant information about update order.
~

@doc.ListQueue 
"Model a simple, queue object with a pair of lists.
~
@doc.suffix.lq doc.ListQueue
@sealer.lq [%{:lq}]
@unsealer.lq [%{.lq}]
@seal.lq sealer.lq .apply
@unseal.lq unsealer.lq .apply
@empty.lq 0 0 pw [] pw seal.lq

