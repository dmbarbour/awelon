bits math streams boolean

@doc.import.random "pseudo random number generators"

@doc.RandomNumberGeneration
"A pseudo-random number generator (PRNG) provides a deterministic stream of seemingly random numbers derived from an initial seed. The basic 'uniform' PRNG is like rolling a fair die, producing discrete values in a fixed range without bias. Nice qualities for a PRNG are bounded space requirements, a very large cycle (such that applications never cycle in practice), and performance. There are also applications for 'secure' PRNGs, whose state or future outputs cannot be guessed from past outputs.
 
 Non-uniform distributions are also valuable, but can usually be computed from a uniform distribution. The bulk of a useful random number library will focus on translating uniform distributions into other interesting values or distributions.
 
 The proposed PRNG is based on a simple object oriented interface:
 
     interface PRNG:
        next  :: PRNG → (PRNG * Bool)
        split :: PRNG → (PRNG * PRNG)
 
 In AO, we'll represent this interface as a dependently typed fixpoint closure:
 
     'next' is encoded as false (unit in left)
     'split' is encoded as true (unit in right)
     type PRNG = µR.[next→(R*Bool) | split→(R*R)]
 
 This is really a uniform boolean (1+1) generator, i.e. flipping a fair coin. Booleans are simple to specify and understand, and will work well for generating other random values. The ability to split the generator is useful for lazy or parallel processing. The PRNG's state is hidden. Code that uses a PRNG should never provide its own PRNG, instead leaving it to a client, i.e. such that the client may systematically explore and test different outcomes by controlling the PRNG.
 
 AO doesn't have any 'global' random number generator, though something like that could be modeled easily using AO's extended multi-stack environment. There may also be access to a secure true-entropy generator via capabilities, though use of true random numbers isn't recommended for most problems.
~

@doc.suffix.r doc.RandomNumberGeneration

@doc.next.r "PRNG -- Bool PRNG"
@next.r false .applyd x

@doc.split.r "PRNG -- PRNG PRNG"
@split.r true .applyd x

@doc.prngToStream "PRNG -- (1+1)`S"
@prngToStream false.b constant.s swap pmap.s

@doc.prngToStreamOfPrng "PRNG -- PRNG`S"
@prngToStreamOfPrng true.b constant.s swap pmap.s

@doc.stdgen.r 
"Generate a standard PRNG, seeded by a (usually small) natural number. 
 
     seed -- PRNG
 
 This PRNG is insecure, and lacks a strong statistical argument for robustness of its 'split' behavior. But it should be suitable for most use cases. It is translated from Haskell's standard random number generator (System.Random), which in turn was transliterated by Lennart Augustsson from Pierre L'Ecuyer's Portable Combined Generator (1988).
~
@stdgen.r fromSeed.stdgen.r 24 wordGenToBoolGen.r
@fromSeed.stdgen.r stateFromSeed.stdgen.r fromState.stdgen.r
@fromState.stdgen.r [step.stdgen.r] .fixfirst .bind

@doc.stateFromSeed.stdgen.r "a pair (s1*s2) modulo distinct large primes"
@stateFromSeed.stdgen.r
 assertNatural
 2147483562 .divMod
 2147483398 .rem
 incd inc pw

@step.stdgen.r %lvrD [next.stdgen.r] %r?VRW [split.stdgen.r] %r?WLCMc

@next.stdgen.r preApply.stdgen.r inner.next.stdgen.r postApply
@inner.next.stdgen.r
  next_s1.stdgen.r take
  next_s2.stdgen.r put
  dup2 next_val.stdgen.r take
  p swap .bind put pw

@doc.next_s1.stdgen.r 
"From Haskell code:
     k1   = s1 `quot` 53668
     s1'  = 40014 * (s1 - k1 * 53668) - 12211 * k1
     s1'' = if s1' < 0 then s1' + 2147483563 else s1'
 We want `s1 -- s1''`. The (s1 - k1*53668) is the same as remainder.
~
@next_s1.stdgen.r
  53668 .divMod 12211 .mul %rw 40014 .mul %wl .sub
  dup 0 lt [2147483563 .add] when_

@doc.next_s2.stdgen.r
"From Haskell code:
     k2   = s1 `quot` 52774
     s2'  = 40692 * (s2 - k2 * 52774) - 3791 * k2
     s2'' = if s2' < 0 then s2' + 2147483399 else s2'
 We want `s2 -- s2''`.
~
@next_s2.stdgen.r
  52774 .divMod 3791 .mul %rw 40692 .mul %wl .sub
  dup 0 lt [2147483399 .add] when_

@doc.next_val.stdgen.r
"From Haskell code:
     z = s1'' - s2''
     z' = if z < 1 then z + 2147483562 else z
 We want `s2 s1 -- z'`.
~
@next_val.stdgen.r swap .sub dup 1 lt [2147483562 .add] when_

@doc.preApply.stdgen.r "(step*(s1*s2))*1 → ((s1*(s2*(step*1)))*(1*1); apply env"
@preApply.stdgen.r %rwrvvr 

@split.stdgen.r preApply.stdgen.r inner.split.stdgen.r postApply
@inner.split.stdgen.r
  rot take 
  [next_s1.stdgen.r] [new_s1.stdgen.r] bi take2
  [next_s2.stdgen.r] [new_s2.stdgen.r] bi 
  put p swap put p 
  paste .bind swap put .bind p
@new_s1.stdgen.r inc dup 2147483563 lt [drop 1] unless_
@new_s2.stdgen.r dec dup 1 lt [drop 2147483398] when_

@doc.wordGenToBoolGen.r
"Given a random number generator (which provides natural numbers), return a random boolean generator (per AO standard), by simply taking the K lowest bits of each number generated. 
        
     NatGen K -- PRNG
 
 In case of 'split', the current number is simply dropped. It isn't essential to preserve bits.
~
@wordGenToBoolGen.r assertNatural+ drop
@~wordGenToBoolGen.r assertNatural+ [step.wordGenToBoolGen.r] .bind .fixfirst .bind
@step.wordGenToBoolGen.r %llvrD [next.wordGenToBoolGen.r] %r?VRW [split.wordGenToBoolGen.r] %r?WLCMc
@preApply.wordGenToBoolGen.r %rrvvr
@next.wordGenToBoolGen.r
 "((K*step)*NatGen)*1" drop
 %rrvvr
@split.wordGenToBoolGen.r
 "((K*step)*NatGen)*1" drop
 
