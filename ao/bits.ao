boolean streams lists

@doc.import.bits "functions for working with bits and bytes and fixed-width words"

@doc.BinaryData
"Awelon Bytecode does not provide a binary literal type. However, Awelon project does have a strategy for efficient storage and transmission of binary data. The idea is simple: 
 
 1. developers encode binary data in a base16 alphabet
 2. a specialized compression pass will recognize large sequences of base16 
 
 The compressed encoding consists of header byte 0xF8, a length byte L (0..253 + 3), followed by L bytes, i.e. two bytes overhead to encode up to 256 raw bytes. (0xF8 is never used by UTF-8 or ABC. However, it may be escaped by following with 0xFE.) The result is that large binary data, e.g. textures or audio files, may be embedded in Awelon bytecode with an overhead of 0.8%. The break-even with base64 is encoding six bytes.
 
 The base16 alphabet, however, is not the conventional `0-9a-f`. We instead use:
 
     bdfg hjkm npqs txyz       i.e. `a-z` minus `aeiou` and `vrwlc`
 
 This minimizes risk of interfering with non-binary data or spelling offensive words. We can be relatively confident that a large string of this base16 alphabet really is intended to represent binary data.
~
@doc.BinariesInABC doc.BinaryData
@doc.abcBase16Alphabet "alphabet used to encode binary data in ABC in base16, representing digits 0..15"
@abcBase16Alphabet "bdfghjkmnpqstxyz"

@doc.ABC16toN16 "convert an ABC base16 character to an integer in 0..15"
@doc.N16toABC16 "convert an integer in 0..15 to the associated ABC character"

@doc.wordToBitList 
"Translate a word to a list of bits. 
 
     N(word) N(width) -- (1+1)`L
 
 A word of width N should be a value in the range 0 to 2^N - 1. For example, an octet is a word of width 8, encoding numbers in range 0..255. This function takes a single word and a given width, and produces a list of bits with big-endian orientation. Each bit is encoded as a (1+1) sum, in the left for a zero bit. 
~
@wordToBitList 
    %rw assertNatural empty.l swap
    [pushBit.wordToBitList] %wl repeat 
    assertEQz drop
@pushBit.wordToBitList 
    %r 2 %rQ 0 %r>l
    toBoolean
    %rzwrzwlVlwl
@x.pushBit.wordToBitList 2 .divMod take 0 .gtb cons.l put

@octetToBitList
 assertOctet empty.l swap
 pushBit.wordToBitList pushBit.wordToBitList
 pushBit.wordToBitList pushBit.wordToBitList
 pushBit.wordToBitList pushBit.wordToBitList
 pushBit.wordToBitList pushBit.wordToBitList
 drop

@doc.bitListToWord "(1+1)`L -- N(word); word size implicit from list"
@bitListToWord 0 swap [pushBit.bitListToWord] each.l
@pushBit.bitListToWord [mul2] [mul2 inc] if_

@test.wordToBitList
    0xa5 9
    wordToBitList
    bitListToText
    "010100101" assertEQ

@test.octetToBitList
    "Pack my box with five dozen liquor jugs." copy
    [[8 wordToBitList] map.l] [[octetToBitList] map.l] bi
    assertEQ1 [bitListToWord] map.l put assertEQ1

@doc.bitListToWordK "(1+1)`L K(width) -- N(word); take or fill K bits from list"
@bitListToWordK 0 unrot [step.bitListToWordK] swap repeat drop
@step.bitListToWordK [pushBit.bitListToWordK] [inR mul2d] if
@pushBit.bitListToWordK wx %rw pushBit.bitListToWord %wl

@bitListToOctet 8 bitListToWordK

@doc.bitListToText
"(1+1)`L -- text; e.g. of form "01100001"
~
@bitListToText [bitToChar] map.l
@bitToChar [0x30] [0x31] if_

@doc.bitStreamToText "(1+1)`S -- char`S; characters '0' and '1'"
@bitStreamToText [bitToChar] map.s

@eqv.bitStreamText [bitStreamToText fromStream.l] [fromStream.l bitListToText]
@eqv.mapStreamOrList [map.s fromStream.l] [swap fromStream.l swap map.l]

@doc.textBitsToList
"textBits -- (1+1)`L; textBits is of form "01100001" (no other characters)
~
@textBitsToList [0x30 gtb] map.l
@textBitsToWord 0 swap [0x30 gt pushBit.bitListToWord] each.l

@doc.wordStreamToBitStream "word`S width -- bool`S (bigendian bit orientation)"
@wordStreamToBitStream [wordToBitList fromList.s] bind map.s flatten.s

@doc.octetStreamToBitStream "octet`S -- bool`S (bigendian bit orientation)"
@octetStreamToBitStream [octetToBitList fromList.s] map.s flatten.s

@test.octetStreamToBitStream
    "woman" dup fromList.s octetStreamToBitStream
    bitStreamToText fromStream.l
    "0111011101101111011011010110000101101110" assertTextEQ1

@doc.bitStreamToWordKStream   "(1+1)`S K(width) -- wordK`S"
@doc.bitStreamToOctetStream   "(1+1)`S -- octet`S"
@bitStreamToWordKStream       copy taking.s put [bitListToWordK] bind map.s 
@bitStreamToOctetStream       8 taking.s [bitListToOctet] map.s

@test.bitStreamToOctetStream
    "pack my box with five dozen liquor jugs" dup
    fromList.s octetStreamToBitStream
    bitStreamToOctetStream fromStream.l
    assertTextEQ1


