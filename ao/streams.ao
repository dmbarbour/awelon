process loops lists blocks conditionals

@doc.Streams
"A stream is an incremental sequence of values. The incremental nature gives stream processing a few advantages for reasoning about space requirements when processing very long running streams. 
 
     µS.[1→((elem*S)+1)]            shorthand: elem`S
 
 This model of streams uses the block to capture the incremental computation of the next element, and exhibits the structure of a list. These streams are also allowed to terminate, by returning unit in the right. In most cases we'll want to work with terminating streams. This also admits the possibility of effectful streams.
 
 The simple streams model isn't ideally efficient, especially with deep composition. A more sophisticated streams model or stream builder might support some rich, symbolic optimizations. There are also useful variations on the model, e.g. augmenting queries and results with time information to limit query depth or support more interesting interleave. But the simple stream model has useful applications (e.g. incremental data processing, or compilation target for integration) and remains worth developing.
 
 Words for this simple stream model use suffix `.s`
~
@doc.suffix.s doc.Streams

@doc.empty.s "-- a`S; add empty stream to stack"
@empty.s [%vvrwlcVVRWLCc]

@doc.cons.s "a`L a -- a`L; add element at head of stream"
@doc.putback.s "synonym for `cons.s`; adds element to front of stream"
@cons.s p inL %r' [%c] %rol
@putback.s cons.s

@doc.fromList.s "a`L -- a`S; treat a list as a stream"
@doc.toStream.l doc.fromList.s
@toStream.l fromList.s
@fromList.s [step.fromList.s] .fixfirst .bind
@step.fromList.s %D [%vrwrwz'wowlc] %r?VRW [%cv%] %r?WLCc

@doc.foreach.s
"Sequentially process every element from a finite stream. The type is roughly:
 
     ..b a`S [..b a -- ..b] -- ..b
 
 That is, we apply the same function with each element of the stream in the current AO environment. A non-terminating stream would cause divergence, and is an error, though it's ultimately up to the developer to avoid this error.
~
@foreach.s [step.foreach.s] .bind .fixfirst inline
@step.foreach.s 
  %wzw intro1 .applyd 
  [onElem.foreach.s] [onFini.foreach.s] if
@onFini.foreach.s elim1 %wl drop %wl drop
@onElem.foreach.s wx %wlwl dpw dip wx inline

@doc.each.s doc.foreach.s
@each.s foreach.s

@test.foreach.s
 "hello, world!" fromList.s
 0 [.add] swapd foreach.s
 1193 assertEQ1.n

@doc.toList.s "a`S -- a`L; extract a list from a finite stream"
@doc.fromStream.l doc.toList.s
@fromStream.l toList.s
@toList.s empty.l swap [cons.l] foreach.s reverse.l

@test.toList.s "hello, world!" dup fromList.s toList.s assertEQ1
@id.listToStreamToList   fromList.s toList.s
@id.streamToListToStream toList.s fromList.s

@doc.fmap.s "a`S [a → b] -- b`S; map a pure function over a stream"
@fmap.s [step.fmap.s] .bind .fixfirst .bind
@step.fmap.s %lw %vvrwlcw$ %wD [onElem.fmap.s] %r?VRW [%%] %r?WLCc
@onElem.fmap.s %rz$vrwrw'wowlc

@test.fmap.s
 "hello" fromList.s
 4 [add\2] .bind fmap.s
 toList.s
 "lipps" assertEQ1

@doc.pmap.s "a`S [a ↣ b] -- b`S; fold a process over a stream"
@pmap.s [step.pmap.s] .fixfirst .bind .bind
@step.pmap.s %wlw %vvrwlcw$ %wD [onElem.pmap.s] %r?VRW [%%] %r?WLCc
@onElem.pmap.s %rz$rz'wovrwrwz'wowlc

@doc.lefts.s 
"Filter a stream, keeping only the left elements.
 
     (a+b)`S -- a`S     (requires droppable b)
 
 In the general case, this is unsafe... e.g. if we filter an infinite stream where all the elements might be in the right, we'll diverge, which is an error. So developers must be careful with filtering of streams.
~
@lefts.s [step.lefts.s] .fixfirst .bind
@step.lefts.s "TODO: step.lefts.s" assert

@doc.rights.s "(a+b)`S -- b`S; see `doc.lefts.s`"


