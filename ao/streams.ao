process loops lists blocks conditionals

@doc.Streams
"A stream is an incremental sequence of values. The incremental nature gives stream processing a few advantages for reasoning about space requirements when processing very long running streams. 
 
     µS.[1→((elem*S)+1)]            shorthand: elem`S
 
 This model of streams uses the block to capture the incremental computation of the next element, and exhibits the structure of a list. These streams are also allowed to terminate, by returning unit in the right. In most cases we'll want to work with terminating streams. This also admits the possibility of effectful streams.
 
 The simple streams model isn't ideally efficient, especially with deep composition. A more sophisticated streams model or stream builder might support some rich, symbolic optimizations. There are also useful variations on the model, e.g. augmenting queries and results with time information to limit query depth or support more interesting interleave. But the simple stream model has useful applications (e.g. incremental data processing, or compilation target for integration) and remains worth developing.
 
 Words for this simple stream model use suffix `.s`
~
@doc.suffix.s doc.Streams

@doc.empty.s "-- a`S; add empty stream to stack"
@empty.s [%vvrwlcVVRWLCc]

@doc.cons.s "a`L a -- a`L; add element at head of stream"
@doc.putback.s "synonym for `cons.s`; adds element to front of stream"
@cons.s p inL %r' [%c] %rol
@putback.s cons.s

@doc.singleton.s "a -- a`S; construct a single element stream"
@singleton.s empty.s swap cons.s

@doc.foreach.s
"Sequentially process every element from a finite stream. The type is roughly:
 
     ..b a`S [..b a -- ..b] -- ..b
 
 That is, we apply the same function with each element of the stream in the current AO environment. A non-terminating stream would cause divergence, and is an error, though it's ultimately up to the developer to avoid this error.
~
@foreach.s [step.foreach.s] .bind .fixfirst inline
@step.foreach.s 
  %wzw intro1 .applyd 
  [onElem.foreach.s] [onFini.foreach.s] if
@onFini.foreach.s elim1 %wl drop %wl drop
@onElem.foreach.s wx %wlwl dpw dip wx inline

@doc.each.s doc.foreach.s
@each.s foreach.s

@test.foreach.s
 "hello, world!" fromList.s
 0 [.add] swapd foreach.s
 1193 assertEQ1.n

@doc.fromList.s "a`L -- a`S; treat a list as a stream"
@doc.toStream.l doc.fromList.s
@toStream.l fromList.s
@fromList.s [step.fromList.s] .fixfirst .bind
@step.fromList.s %D [%vrwrwz'wowlc] %r?VRW [%cv%] %r?WLCc

@doc.fromList\1.s "a`L → a`S; stream to list (without environment)"
@doc.toStream\1.l doc.fromList\1.s
@fromList\1.s %vv fromList.s %cc
@toStream\1.l fromList\1.s

@doc.toList.s "a`S -- a`L; extract a list from a finite stream"
@doc.fromStream.l doc.toList.s
@fromStream.l toList.s
@toList.s empty.l swap [cons.l] foreach.s reverse.l

@doc.toList\1.s "a`S → a`L; list to stream (without environment)"
@doc.fromStream\1.l doc.toList\1.s
@toList\1.s %vv toList.s %cc
@fromStream\1.l toList\1.s

@test.toList.s "hello, world!" dup fromList.s toList.s assertEQ1
@id.listToStreamToList   fromList.s toList.s
@id.streamToListToStream toList.s fromList.s

@doc.fmap.s "a`S [a → b] -- b`S; map a pure function over a stream"
@fmap.s [step.fmap.s] .bind .fixfirst .bind
@step.fmap.s %lw %vvrwlcw$ %wD [onElem.fmap.s] %r?VRW [%%] %r?WLCc
@onElem.fmap.s %rz$vrwrw'wowlc
@doc..fmap.s "([a → b] * (a`S * e))→(b`S * e); map stream primitive"
@.fmap.s [step.fmap.s] %r %w'wo .firstfixfirst %w'wo

@test.fmap.s
 "hello" fromList.s
 4 [add\2] .bind fmap.s
 toList.s
 "lipps" assertEQ1

@doc.fmapE.s "a`S [a -- b] -- b`S; map function in basic `apply` environment"
@fmapE.s applyWrap fmap.s

@doc.map.s doc.fmapE.s
@map.s fmapE.s


@doc.pmap.s "a`S [a ↣ b] -- b`S; fold a process over a stream"
@pmap.s [step.pmap.s] .fixfirst .bind .bind
@step.pmap.s %wlwvvrwlcw$wD [onElem.pmap.s] %r?VRW [%%] %r?WLCc
@onElem.pmap.s %rz$rz'wovrwrwz'wowlc
@doc..pmap.s  "([a↣b]*(a`S*e))→(b`S*e); fold process over stream in primitive environment"
@.pmap.s [step.pmap.s] %r .firstfixfirst %w'wo %w'wo

@doc.addend.s "a`S a`S -- a`S; compose streams end-to-end (stream at top of stack runs last)"
@addend.s [step.addend.s] .fixfirst .bind .bind
@step.addend.s %lwvvrwlcw$wD [onElem.addend.s] %r?VRW [onFini.addend.s] %r?WLCMc
@onElem.addend.s %rw'wovrwrwz'wowlVc
@onFini.addend.s %r%vr$c
@doc..addend.s "(a`S*(a`S*e))→(a`S*e); addend streams (ABC layer stack)"
@.addend.s [step.addend.s] %r .firstfixfirst %w'wo %w'wo

@test.addend.s#empty 
 empty.s empty.s addend.s 
 intro1 .applyd assertInR elim1
@test.addend.s
 "hello," " world!" [fromList.s] bi& 
 addend.s toList.s
 "hello, world!" assertTextEQ1

@doc.flatten.s "(a`S)`S -- a`S; flatten a stream of streams"
@flatten.s [step.flatten.s] .fixfirst .bind
@step.flatten.s %wvvrwlcw$wD [onElem.flatten.s] %r?VRW [%% .inR] %r?WLCMc
@onElem.flatten.s %wvrwrw'wo .addend.s %vr$c
@.flatten.s [step.flatten.s] %r .firstfixfirst %w'wo

@test.flatten.s
  empty.l 
  "" cons.l
  "!" cons.l
  "" cons.l
  "" cons.l
  "world" cons.l
  ", " cons.l
  "hello" cons.l
  [fromList.s] map.l
  fromList.s flatten.s toList.s
  "hello, world!" assertTextEQ1

@doc.lefts.s 
"Filter a stream, keeping only the left elements.
 
     (a+b)`S -- a`S     (requires droppable b)
 
 In the general case, this is unsafe... e.g. if we filter an infinite stream where all the elements might be in the right, we'll diverge, which is an error. Developers must be careful with filtering of simple streams.
~
@lefts.s [toS.lefts.s] map.s flatten.s
@toS.lefts.s [singleton.s] [drop empty.s] if

@doc.rights.s "(a+b)`S -- b`S; see `doc.lefts.s`"
@rights.s [toS.rights.s] map.s flatten.s
@toS.rights.s [drop empty.s] [singleton.s] if

@test.rights.s
  "Hello, World!" fromList.s
  [108 .lt1] map.s rights.s
  toList.s "He, Wd!" assertTextEQ1

@test.lefts.s 
  "Hello, World!" fromList.s
  [108 .lt1] map.s lefts.s
  toList.s "lloorl" assertTextEQ1
  
@doc.filterWith.s "a`S [a -- (b+c)] -- c`S; Droppable b"
@filterWith.s [toS.rights.s] compose map.s flatten.s
@test.filterWith.s
  "Hello, World!" fromList.s
  [108 .gte1] filterWith.s
  toList.s "lloorl" assertTextEQ1

@doc.filterBy.s  "a`S [a -- Bool] -- c`S; Copyable & Droppable a"
@filterBy.s [dup] [toS.filterBy.s] wrapfn map.s flatten.s
@toS.filterBy.s [drop empty.s] [singleton.s] if_
@test.filterBy.s
  "Hello, World!" fromList.s
  [108 .ltb] filterBy.s
  toList.s "He, Wd!" assertTextEQ1



@doc.WordStream
@doc.wordStreamToBitStream.s
@doc.bitStreamToWordStream.s
@doc.octetStreamToBitStream.s 
@doc.bitStreamToOctetStream.s
@doc.bitStreamToText.s


