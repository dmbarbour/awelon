
@doc.Loops
"Loops in AO are ultimately expressed using fixpoint combinators. A loop will repeatedly copy and apply a block (which represents the body of the loop) until a terminating condition is observed. In practice, explicit loops should be avoided whenever possible, except when modeling collections types (streams, lists, etc.). Ultimately, AO should have the flavor of collection-oriented programming languages - i.e. very few loops exposed to programmers - despite the lack of built-in collection types.
 
 Compared to the recursive functions or built-in loops of more conventional programming languages, using fixpoint combinators is very awkward. Convenient loops are simply a low priority for AO's design. Instead, AO favors developing a few common collection types with collection-oriented words (which covers many use-cases for loops), plus incremental application models such that the outer loop is implicit.
 
 Explicit loops in AO are required to terminate. Due to the halting problem, termination cannot always be proven or disproven statically. However, a non-terminating loop is always a bug, and developers are expected to treat one thusly.
~

@doc.repeat "a [a -- a] n -- a; repeat block `n` times"

@repeat assertNatural .rw [step.repeat] bind fixpoint .wl swap inline
@step.repeat rot dup 0 gt  [drop3] [action.repeat] if_
@action.repeat dec unrot dip2 inline 

@test.repeat 4 [inc] 3 repeatP 7 assertEQ.n
@repeatP [repeat] apply3to1

@doc.enumx "a [a ix -- a] n m -- a; apply with ix in range [n,m)."
@doc.enum "a [a ix -- a] n m -- a; apply with ix in range [n,m]."
@enumFromUntil dupd swap .sub rot [keep inc] bind swap repeat drop
@enumFromTo inc enumFromUntil

@doc.while1Sum "b [b -- (a + b)] -- a"
@doc.until1Sum "a [a -- (a + b)] -- b"
@doc.whileSum  "(a + b) [b -- (a + b)] -- a"
@doc.untilSum  "(a + b) [a -- (a + b)] -- b"

@while1Sum inRd whileSum
@until1Sum inLd untilSum
@whileSum notd [not] compose untilSum
@untilSum [step.untilSum] bind fixpoint inline
@step.untilSum composel [] if 

@test.until1Sum 0 10 pw [wx incd gte] until1Sum x assertEQ.n
@test.while1Sum 0 10 pw [wx incd lt] while1Sum x assertEQ.n

@doc.while  "[action(--)] [cond(--Bool)] --; repeat action while boolean condition"
@doc.while1 "[action(--)] [cond(--Bool)] --; as whileCond, but act at least once"
@doc.until  "[action(--)] [cond(--Bool)] --; repeat action until boolean condition"
@doc.until1 "[action(--)] [cond(--Bool)] --; as untilCond, but act at least once"
@doc.repeatWhile "[action(--)] [cond(--Bool)] N -- repeat N times or until some other condition"
@doc.repeatUntil "[action(--)] [cond(--Bool)] N -- repeat N times or while some other condition"

@while1 over dip2 while
@until1 over dip2 until
@while [not.b] compose until
@until [step.until] bind2 fixpoint inline
@step.until dip2 rot [dip inline] [drop2] if_

@test.until     0 [inc] 10 [dupd gtb]  bind until 11 assertEQ1.n
@test.while    10 [dec]  0 [dupd gtb]  bind while  0 assertEQ1.n
@test.until1.1  0 [inc]  0 [dupd gteb] bind until1 1 assertEQ1.n
@test.until1.0  0 [inc]  0 [dupd gteb] bind until  0 assertEQ1.n

@doc.prefix.bench.
"benchmarks; not part of the usual test suite
 
 note: these may cause trouble for partial evaluators (but they're also a nice validation that partial evaluators don't do too much work)
~
@bench.repeat10k   0 [4 .add] 10000        repeat 40000        assertEQ1.n
@bench.repeat100k  0 [4 .add] 100000       repeat 400000       assertEQ1.n
@bench.repeat1M    0 [4 .add] 1000000      repeat 4000000      assertEQ1.n
@bench.repeat10M   0 [4 .add] 10000000     repeat 40000000     assertEQ1.n

@repeatWhile swap [not] compose swap repeatUntil
@repeatUntil assertNatural unrot [tryCount.repeatUntil] bind2 fixpoint inline
@tryCount.repeatUntil over4 0 gt [drop4] [tryCond.repeatUntil] if_
@tryCond.repeatUntil dip3 roll [body.repeatUntil] [drop3] if_
@body.repeatUntil dip2 decd inline

@test.repeatWhile.haltOnCount
    new.stats 
    [1 add.stats] [count.stats 15 lte] 10 repeatWhile 
    count.stats 10 assertEQ1.n
@test.repeatWhile.haltOnCond   
    new.stats 
    [1 add.stats] [count.stats 15 lte] 20 repeatWhile 
    count.stats 16 assertEQ1.n

@doc.fixpoint
"This fixpoint combinator binds a function to receive itself (in fixpoint form) as an argument on the stack. Fixpoint enables expression of recursive behavior.
 
        [foo] fixpoint
            is equivalent to
        [[foo] fixpoint foo]
            is equivalent to
        [[[foo] fixpoint foo] foo]
 
 When invoked, the function `foo` has access to itself (in fixpoint form) as a block on the stack. 
 
 Loops are expressed this way in Awelon to avoid reliance on a namespace, to support streaming programs and AO's simple 'inline everything' semantics. Unfortunately, expressing loops in this manner is relatively awkward, and a direct interpretation will be less efficient than a stored program's jump based loops. The performance issue can be mitigated by a compiler, i.e. recognizing that the same function will be constructed in every step. The awkwardness can be mitigated by good collections libraries and support for collection-oriented programming.
 
 NOTE: Loops in Awelon are required to terminate. Optimizers are allowed to assume termination, and linters or typecheckers are allowed to reject a non-terminating subprogram (if they recognize one). But proof of termination is ultimately left to the developer. Conventional process models - e.g. infinite loops - are not valid in Awelon. Instead, long-running services or applications in Awelon project are generally modeled as bounded RDP behaviors or unbounded streaming code (discussed in detail elsewhere).
 
 NOTE: Loops are also discouraged in Awelon. Instead, developers are encouraged to compose incremental computations. For example, instead of a sequence of operations that each loop over a full list, consider translating a list to a stream and applying a sequence of transforms, filters, etc. to that stream. Loops can be expressed where needed, but can often be avoided or pushed to the 'edges' of a program. Avoiding loops in subprograms is advantageous for composition and extension.
~
@fixpoint %r [%^'ol] %ro %^'ol
@fixpoint.old [dup bind] composel dup bind

@doc..fixfirst "[(f*a)→b] -- [a→b]; fixpoint first argument in pair"
@.fixfirst %r .firstfixfirst %l

@doc..firstfixfirst "([(f*a)→b]*e)→([a→b]*e); a minimal fixpoint"
@.firstfixfirst [%^'o] %ro %^'o

@doc.factorial.fixpoint "mostly this is a test for fixpoint :)"
@factorial.fixpoint assertNatural [step.factorial.fixpoint] fixpoint apply
@step.factorial.fixpoint
 take 2 lt
 [snd dup dec put apply .mul]
 [fst discard]
 if
@test.factorial.fixpoint 720 6 factorial.fixpoint assertEQ
