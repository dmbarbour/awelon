
@doc.Loops
"Loops in AO are ultimately expressed using fixpoint combinators. A loop will repeatedly copy and apply a block (which represents the body of the loop) until a terminating condition is observed.
 
 To the potential user of AO: please avoid explicit loops!
 
 Compared to the recursive functions or built-in loops of more conventional programming languages, using fixpoint combinators is very awkward. Convenient loops are simply a low priority for AO's design. Instead, AO favors developing a few common collection types with collection-oriented words (which covers many use-cases for loops), plus incremental application models such that the outer loop is implicit.
 
 Explicit loops in AO are required to terminate. Due to the halting problem, termination cannot always be proven or disproven statically. However, a non-terminating loop is always a bug, and developers are expected to treat one thusly.
~

@doc.repeat "[] n --; inline block n times"
@doc.enum  "[i --] n m --; loop with integral index in range [n,m)."
@doc.enum1 "enum in range [n,m] - i.e. including m"

@test.repeat 4 7 [incd] 3 repeat assertEQ
@repeat assertNatural swap [step.repeat] bind fixpoint inline
@doc.step.repeat "n [continue] [action] -- ; n counting down"
@step.repeat
 rot dup 1 lt
 [rot p swap dip x decd inline]
 [drop3]
 if!

@test.enum 15 0 [.add] 1 5 enum1 assertEQ
@enum1 inc enum
@enum assertEnumRange pw swap [step.enum] bind fixpoint inline
@assertEnumRange swap assertInteger swap assertInteger assertLTE
@doc.step.enum "(n*m) [continue] [action] -- "
@step.enum
 pick x gt
 [drop3]
 [action.enum]
 if!
@action.enum
 pick x dropd swap
 roll roll p swap
 dip
 wx x inc p swap
 inline

@doc.while1 "b [b -- (a + b)] -- a"
@doc.until1 "a [a -- (a + b)] -- b"
@doc.while  "(a + b) [b -- (a + b)] -- a"
@doc.until  "(a + b) [a -- (a + b)] -- b"

@while1 inRd while
@until1 inLd until
@while notd [not] compose until
@until [step.until] bind fixpoint inline
@step.until composel [] ifk merged inline 

@test.until1 0 10 pw [wx incd gte] until1 x assertEQ
@test.while1 0 10 pw [wx incd lt] while1 x assertEQ

@doc.fixpoint
"This fixpoint combinator binds a function to receive itself (in fixpoint form) as an argument on the stack. AO does not allow cyclic definitions, but a fixpoint enables expression of cyclic behavior.
 
     [foo] fixpoint
         is equivalent to
     [[foo] fixpoint foo]
 
 Naturally, if a fixpoint function unconditionally applies itself, the program will diverge. Thus, any fixpoint function should have conditional behavior and a termination condition.
 
 Fixpoint is one of those patterns that people find difficult to comprehend until they've used it many times. I encourage developers to use, learn, and understand it. But in practice it may often be easier to express most behavior in terms of a few loops (map, each, enum, repeat, until, while, etc.) built above fixpoint.
~
@fixpoint [dup bind] swap compose dup bind

@doc.factorial.fixpoint "mostly this is a test for fixpoint :)"
@factorial.fixpoint assertNatural [step.factorial.fixpoint] fixpoint apply
@step.factorial.fixpoint
 take 2 lt
 [tail dup dec put apply .mul]
 [head discard]
 eitherE
 merge
@test.factorial.fixpoint 720 6 factorial.fixpoint assertEQ
