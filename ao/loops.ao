
@doc.Loops
"Loops in AO are ultimately expressed using fixpoint combinators. A loop will repeatedly copy and apply a block (which represents the body of the loop) until a terminating condition is observed.
 
 To the potential user of AO: please avoid explicit loops!
 
 Compared to the recursive functions or built-in loops of more conventional programming languages, using fixpoint combinators is very awkward. Convenient loops are simply a low priority for AO's design. Instead, AO favors developing a few common collection types with collection-oriented words (which covers many use-cases for loops), plus incremental application models such that the outer loop is implicit.
 
 Explicit loops in AO are required to terminate. Due to the halting problem, termination cannot always be proven or disproven statically. However, a non-terminating loop is always a bug, and developers are expected to treat one thusly.
~

@doc.repeat "[] n --; inline block n times"
@doc.enum  "[i --] n m --; loop with integral index in range [n,m)."
@doc.enum1 "enum in range [n,m] - i.e. including m"

@test.repeat 4 7 [incd] 3 repeat assertEQ
@repeat assertNatural swap [step.repeat] bind fixpoint inline
@doc.step.repeat "n [continue] [action] -- ; n counting down"
@step.repeat
 rot dup 1 lt
 [rot p swap dip x decd inline]
 [drop3]
 if!

@test.enum 15 0 [.add] 1 5 enum1 assertEQ
@enum1 inc enum
@enum assertEnumRange pw swap [step.enum] bind fixpoint inline
@assertEnumRange swap assertInteger swap assertInteger assertLTE
@doc.step.enum "(n*m) [continue] [action] -- "
@step.enum
 pick x gt
 [drop3]
 [action.enum]
 if!
@action.enum
 pick x dropd swap
 roll roll p swap
 dip
 wx x inc p swap
 inline

@doc.while1 "b [b -- (a + b)] -- a"
@doc.until1 "a [a -- (a + b)] -- b"
@doc.while  "(a + b) [b -- (a + b)] -- a"
@doc.until  "(a + b) [a -- (a + b)] -- b"

@while1 inRd while
@until1 inLd until
@while notd [not] compose until
@until [step.until] bind fixpoint inline
@step.until composel [] ifk merged inline 

@test.until1 0 10 pw [wx incd gte] until1 x assertEQ
@test.while1 0 10 pw [wx incd lt] while1 x assertEQ

@doc.fixpoint
"This fixpoint combinator binds a function to receive itself (in fixpoint form) as an argument on the stack. AO does not allow cyclic definitions, but a fixpoint enables expression of recursive behavior.
 
     [foo] fixpoint
         is equivalent to
     [[foo] fixpoint foo]
 
 If the resulting block is unconditionally applied by `foo`, the function will diverge. Divergence is a bug. Loops in AO/ABC are required to terminate. It is necessary that `foo` reach a terminating condition in which the function is not applied. I.e. every fixpoint function must have conditional behavior. 
~
@fixpoint %r [%^'wol] %rwo %^'wol
@fixpoint.old [dup bind] composel dup bind

@doc..fixpoint "(f*e)â†’(ff*e); fixpoint combinator outside stack"
@.fixpoint [%^'wo] %rwo %^'wo

@doc.factorial.fixpoint "mostly this is a test for fixpoint :)"
@factorial.fixpoint assertNatural [step.factorial.fixpoint] fixpoint apply
@step.factorial.fixpoint
 take 2 lt
 [tail dup dec put apply .mul]
 [head discard]
 eitherE
 merge
@test.factorial.fixpoint 720 6 factorial.fixpoint assertEQ
