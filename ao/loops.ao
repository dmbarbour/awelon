
@doc.Loops
"Loops in AO are ultimately expressed using fixpoint combinators. A loop will repeatedly copy and apply a block (which represents the body of the loop) until a terminating condition is observed.
 
 To the potential user of AO: please avoid explicit loops!
 
 Compared to the recursive functions or built-in loops of more conventional programming languages, using fixpoint combinators is very awkward. Convenient loops are simply a low priority for AO's design. Instead, AO favors developing a few common collection types with collection-oriented words (which covers many use-cases for loops), plus incremental application models such that the outer loop is implicit.
 
 Explicit loops in AO are required to terminate. Due to the halting problem, termination cannot always be proven or disproven statically. However, a non-terminating loop is always a bug, and developers are expected to treat one thusly.
~

@doc.repeat "a [a -- a] n -- a; repeat block `n` times"

@repeat
 assertNatural swap
 [dip] bind [p] composel
 [step.repeat] compose fixpoint
 p step.repeat
@step.repeat
 wx dup dec unrot
 0 gt [drop] rot if_

@test.repeat 4 [inc] 3 repeatP 7 assertEQ.n
@repeatP [repeat] apply3to1

@doc.enumx "a [a ix -- a] n m -- a; apply with ix in range [n,m)."
@doc.enum "a [a ix -- a] n m -- a; apply with ix in range [n,m]."
@enumFromUntil dupd swap .sub rot [keep inc] bind swap repeat drop
@enumFromTo inc enumFromUntil

@doc.while1Sum "b [b -- (a + b)] -- a"
@doc.until1Sum "a [a -- (a + b)] -- b"
@doc.whileSum  "(a + b) [b -- (a + b)] -- a"
@doc.untilSum  "(a + b) [a -- (a + b)] -- b"

@while1Sum inRd whileSum
@until1Sum inLd untilSum
@whileSum notd [not] compose untilSum
@untilSum [step.untilSum] bind fixpoint inline
@step.untilSum composel [] if 

@test.until1Sum 0 10 pw [wx incd gte] until1Sum x assertEQ.n
@test.while1Sum 0 10 pw [wx incd lt] while1Sum x assertEQ.n

@doc.while  "[action(--)] [cond(--Bool)] --; repeat action while boolean condition"
@doc.while1 "[action(--)] [cond(--Bool)] --; as whileCond, but act at least once"
@doc.until  "[action(--)] [cond(--Bool)] --; repeat action until boolean condition"
@doc.until1 "[action(--)] [cond(--Bool)] --; as untilCond, but act at least once"
@doc.repeatWhile "[action(--)] [cond(--Bool)] N -- repeat N times or until some other condition"
@doc.repeatUntil "[action(--)] [cond(--Bool)] N -- repeat N times or while some other condition"

@while1 over dip2 while
@until1 over dip2 until
@while [not.b] compose until
@until [step.until] bind2 fixpoint inline
@step.until dip2 rot [dip inline] [drop2] if_

@test.until     0 [inc] 10 [dupd gtb]  bind until 11 assertEQ1.n
@test.while    10 [dec]  0 [dupd gtb]  bind while  0 assertEQ1.n
@test.until1.1  0 [inc]  0 [dupd gteb] bind until1 1 assertEQ1.n
@test.until1.0  0 [inc]  0 [dupd gteb] bind until  0 assertEQ1.n

@doc.prefix.bench 
"benchmarks; not part of the usual test suite
 
 note: these may cause trouble for partial evaluators (but they're also a nice validation that partial evaluators don't do too much work)
~
@bench.repeat10k   0 [4 .add] 10000        repeat 40000        assertEQ1.n
@bench.repeat100k  0 [4 .add] 100000       repeat 400000       assertEQ1.n
@bench.repeat1M    0 [4 .add] 1000000      repeat 4000000      assertEQ1.n
@bench.repeat10M   0 [4 .add] 10000000     repeat 40000000     assertEQ1.n

@repeatWhile swap [not] compose swap repeatUntil
@repeatUntil assertNatural unrot [tryCount.repeatUntil] bind2 fixpoint inline
@tryCount.repeatUntil over4 0 gt [drop4] [tryCond.repeatUntil] if_
@tryCond.repeatUntil dip3 roll [body.repeatUntil] [drop3] if_
@body.repeatUntil dip2 decd inline

@test.repeatWhile.haltOnCount
    new.stats 
    [1 add.stats] [count.stats 15 lte] 10 repeatWhile 
    count.stats 10 assertEQ1.n
@test.repeatWhile.haltOnCond   
    new.stats 
    [1 add.stats] [count.stats 15 lte] 20 repeatWhile 
    count.stats 16 assertEQ1.n

@doc.fixpoint
"This fixpoint combinator binds a function to receive itself (in fixpoint form) as an argument on the stack. Fixpoint enables expression of recursive behavior.
 
     [foo] fixpoint
         is equivalent to
     [[foo] fixpoint foo]
         is equivalent to
     [[[foo] fixpoint foo] foo]
 
 When invoked, the function `foo` has access to itself (in fixpoint form) as a block on the stack. 
 
 Loops are expressed this way in Awelon to avoid reliance on a namespace, to support streaming and simple 'inline everything' semantics. Fortunately, it is not difficult for a compiler to identify fixpoint loops and optimize them for more conventional architectures.
 
 NOTE: Loops in Awelon are required to terminate. Optimizers are allowed to assume termination, and linters or typecheckers are allowed to reject a non-terminating subprogram (if they recognize one). But proof of termination is ultimately left to the developer. Conventional process models - e.g. infinite loops - are not valid in Awelon. Instead, long-running services or applications in Awelon project are generally modeled as bounded RDP behaviors or unbounded streaming code (discussed in detail elsewhere).
 
 NOTE: Loops are also discouraged in Awelon. Instead, developers are encouraged to compose incremental computations. For example, instead of a sequence of operations that each loop over a full list, consider translating a list to a stream and applying a sequence of transforms, filters, etc. to that stream. Loops can be expressed where needed, but can often be avoided or pushed to the 'edges' of a program.
~
@fixpoint %r [%^'wol] %rwo %^'wol
@fixpoint.old [dup bind] composel dup bind

@doc..fixfirst "[(f*a)→b] -- [a→b]; fixpoint first argument in pair"
@.fixfirst %r .firstfixfirst %l

@doc..firstfixfirst "([(f*a)→b]*e)→([a→b]*e); a minimal fixpoint"
@.firstfixfirst [%^'wo] %rwo %^'wo

@doc.fixpointLinear   "fixpoint adding linearity attribute"
@doc.fixpointAffine   "fixpoint adding affine attribute"
@doc.fixpointRelevant "fixpoint adding relevant attribute"
@fixpointLinear   %r [%^'wokfl] %rwo %^'wokfl
@fixpointAffine   %r [%^'wofl]  %rwo %^'wofl
@fixpointRelevant %r [%^'wokl]  %rwo %^'wokl

@doc.factorial.fixpoint "mostly this is a test for fixpoint :)"
@factorial.fixpoint assertNatural [step.factorial.fixpoint] fixpoint apply
@step.factorial.fixpoint
 take 2 lt
 [snd dup dec put apply .mul]
 [fst discard]
 if
@test.factorial.fixpoint 720 6 factorial.fixpoint assertEQ
