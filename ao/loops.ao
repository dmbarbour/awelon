
@doc.Loops
"Loops in AO are ultimately expressed using fixpoint combinators. A loop will repeatedly copy and apply a block (which represents the body of the loop) until a terminating condition is observed.
 
 To the potential user of AO: please avoid explicit loops!
 
 Compared to the recursive functions or built-in loops of more conventional programming languages, using fixpoint combinators is very awkward. Convenient loops are simply a low priority for AO's design. Instead, AO favors developing a few common collection types with collection-oriented words (which covers many use-cases for loops), plus incremental application models such that the outer loop is implicit.
 
 Explicit loops in AO are required to terminate. Due to the halting problem, termination cannot always be proven or disproven statically. However, a non-terminating loop is always a bug, and developers are expected to treat one thusly.
~

@doc.repeat "a [a -- a] n -- a; repeat block `n` times"

@repeat
 assertNatural swap
 [dip] bind [p] composel
 [step.repeat] compose fixpoint
 p step.repeat
@step.repeat
 wx dup dec unrot
 0 gt [drop] rot if!

@test.repeat 4 [inc] 3 repeatP 7 assertEQ
@repeatP p p [x x repeat] apply

@doc.while1 "b [b -- (a + b)] -- a"
@doc.until1 "a [a -- (a + b)] -- b"
@doc.while  "(a + b) [b -- (a + b)] -- a"
@doc.until  "(a + b) [a -- (a + b)] -- b"

@while1 inRd while
@until1 inLd until
@while notd [not] compose until
@until [step.until] bind fixpoint inline
@step.until composel [] ifk merged inline 

@test.until1 0 10 pw [wx incd gte] until1 x assertEQ
@test.while1 0 10 pw [wx incd lt] while1 x assertEQ

@doc.fixpoint
"This fixpoint combinator binds a function to receive itself (in fixpoint form) as an argument on the stack. AO does not allow cyclic definitions, but a fixpoint enables expression of recursive behavior.
 
     [foo] fixpoint
         is equivalent to
     [[foo] fixpoint foo]
 
 If the resulting block is unconditionally applied by `foo`, the function will diverge. Divergence is a bug. Loops in AO/ABC are required to terminate. It is necessary that `foo` reach a terminating condition in which the function is not applied. I.e. every fixpoint function must have conditional behavior. 
~
@fixpoint %r [%^'wol] %rwo %^'wol
@fixpoint.old [dup bind] composel dup bind

@doc..fixpoint "fix functions of form [(f*a)â†’b]; `f` is bound as fixpoint"
@.fixpoint [%^'wo] %rwo %^'wo

@doc.factorial.fixpoint "mostly this is a test for fixpoint :)"
@factorial.fixpoint assertNatural [step.factorial.fixpoint] fixpoint apply
@step.factorial.fixpoint
 take 2 lt
 [tail dup dec put apply .mul]
 [head discard]
 ifk merged inline
@test.factorial.fixpoint 720 6 factorial.fixpoint assertEQ
