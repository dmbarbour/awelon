
@doc.Loops
"Loops in AO are ultimately expressed using fixpoint combinators. A loop will repeatedly copy and apply a block (which represents the body of the loop) until a terminating condition is observed.
 
 To the potential user of AO: please avoid explicit loops!
 
 Compared to the recursive functions or built-in loops of more conventional programming languages, using fixpoint combinators is very awkward. Convenient loops are simply a low priority for AO's design. Instead, AO favors developing a few common collection types with collection-oriented words (which covers many use-cases for loops), plus incremental application models such that the outer loop is implicit.
 
 Explicit loops in AO are required to terminate. Due to the halting problem, termination cannot always be proven or disproven statically. However, a non-terminating loop is always a bug, and developers are expected to treat one thusly.
~

@doc.repeat "a [a -- a] n -- a; repeat block `n` times"

@repeat
 assertNatural swap
 [dip] bind [p] composel
 [step.repeat] compose fixpoint
 p step.repeat
@step.repeat
 wx dup dec unrot
 0 gt [drop] rot if_

@test.repeat 4 [inc] 3 repeatP 7 assertEQ
@repeatP [repeat] apply3to1

@doc.enumx "a [a ix -- a] n m -- a; apply with ix in range [n,m)."
@doc.enum "a [a ix -- a] n m -- a; apply with ix in range [n,m]."
@enumFromUntil dupd swap .sub rot [keep inc] bind swap repeat drop
@enumFromTo inc enumFromUntil

@doc.while1Sum "b [b -- (a + b)] -- a"
@doc.until1Sum "a [a -- (a + b)] -- b"
@doc.whileSum  "(a + b) [b -- (a + b)] -- a"
@doc.untilSum  "(a + b) [a -- (a + b)] -- b"

@while1Sum inRd whileSum
@until1Sum inLd untilSum
@whileSum notd [not] compose untilSum
@untilSum [step.untilSum] bind fixpoint inline
@step.untilSum composel [] if 

@test.until1Sum 0 10 pw [wx incd gte] until1Sum x assertEQ
@test.while1Sum 0 10 pw [wx incd lt] while1Sum x assertEQ

@doc.while  "[action(--)] [cond(--Bool)] --; repeat action while boolean condition"
@doc.while1 "[action(--)] [cond(--Bool)] --; as whileCond, but act at least once"
@doc.until  "[action(--)] [cond(--Bool)] --; repeat action until boolean condition"
@doc.until1 "[action(--)] [cond(--Bool)] --; as untilCond, but act at least once"
@doc.repeatWhile "[action(--)] [cond(--Bool)] N -- repeat N times or until some other condition"
@doc.repeatUntil "[action(--)] [cond(--Bool)] N -- repeat N times or while some other condition"

@while1 over dip2 while
@until1 over dip2 until
@while [not.b] compose until
@until [step.until] bind2 fixpoint inline
@step.until dip2 rot [dip inline] [drop2] if_

@test.until     0 [inc] 10 [dupd gtb]  bind until 11 assertEQ1
@test.while    10 [dec]  0 [dupd gtb]  bind while  0 assertEQ1
@test.until1.1  0 [inc]  0 [dupd gteb] bind until1 1 assertEQ1
@test.until1.0  0 [inc]  0 [dupd gteb] bind until  0 assertEQ1

@repeatWhile swap [not] compose swap repeatUntil
@repeatUntil assertNatural unrot [tryCount.repeatUntil] bind2 fixpoint inline
@tryCount.repeatUntil over4 0 gt [drop4] [tryCond.repeatUntil] if_
@tryCond.repeatUntil dip3 roll [body.repeatUntil] [drop3] if_
@body.repeatUntil dip2 decd inline

@test.repeatWhile.count
    new.stats 
    [1 add.stats] [count.stats 15 lte] 10 repeatWhile 
    count.stats 10 assertEQ1
@test.repeatWhile.cond   
    new.stats 
    [1 add.stats] [count.stats 15 lte] 20 repeatWhile 
    count.stats 16 assertEQ1

@doc.fixpoint
"This fixpoint combinator binds a function to receive itself (in fixpoint form) as an argument on the stack. AO does not allow cyclic definitions, but a fixpoint enables expression of recursive behavior.
 
     [foo] fixpoint
         is equivalent to
     [[foo] fixpoint foo]
         is equivalent to
     [[[foo] fixpoint foo] foo]
 
 I.e. when invoked, the function `foo` has access to its fixpoint form as a block. If this block is unconditionally applied by `foo`, the function will diverge. Divergence is always a bug. Loops in AO/ABC are required to terminate, and long-running behaviors are instead modeled as reactive or incremental processes. It is necessary that `foo` reach a terminating condition in which the function is not applied. I.e. every fixpoint function must be expressed with conditional behavior. 
~
@fixpoint %r [%^'wol] %rwo %^'wol
@fixpoint.old [dup bind] composel dup bind

@doc..fixfirst "[(f*e)→e] -- [e→e]; fixpoint first argument in pair"
@.fixfirst %r [%^'wo] %rwo %^'wol

@doc.fixpointLinear   "fixpoint adding linearity attribute"
@doc.fixpointAffine   "fixpoint adding affine attribute"
@doc.fixpointRelevant "fixpoint adding relevant attribute"
@fixpointLinear   %r [%^'wokfl] %rwo %^'wokfl
@fixpointAffine   %r [%^'wofl]  %rwo %^'wofl
@fixpointRelevant %r [%^'wokl]  %rwo %^'wokl

@doc.factorial.fixpoint "mostly this is a test for fixpoint :)"
@factorial.fixpoint assertNatural [step.factorial.fixpoint] fixpoint apply
@step.factorial.fixpoint
 take 2 lt
 [snd dup dec put apply .mul]
 [fst discard]
 if
@test.factorial.fixpoint 720 6 factorial.fixpoint assertEQ
