{-# LANGUAGE PatternGuards, ViewPatterns #-}

-- | The AOPrelude module provides dependencies for AODict, which is
-- generated by `ao dict2hs`. Different AOPrelude modules could suit
-- different interpretations (functional vs. imperative vs. reactive).
--
-- This implementation is dynamic and imperative, and replicates the
-- behavior from the `ao` library, albeit tweaked for performance over
-- correctness. (The `aoi` implementation is better for debugging.)
--
-- Sadly, I've not been able to fit AO into Haskell's type system. AO
-- assumes partial evaluation, flexible typing strategies (e.g. recognize
-- anonymous recursive types by hypothesis), and exhaustive analysis from
-- the small set of structural types. So we end up with a mostly dynamic
-- implementation of AO in Haskell. I shall also try a dynamic target PL, 
-- such as Python, to see if that will perform better.
--
-- The only goal is, simply, performance - enough for bootstrap compilers
-- and web application servers. 
-- 
module AOPrelude
    ( op_l, op_r, op_w, op_z, op_v, op_c
    , op_L, op_R, op_W, op_Z, op_V, op_C
    , op_drop, op_copy
    , op_ap, op_quote, op_comp, op_rel, op_aff
    , op_add, op_mul, op_neg, op_inv, op_div
    , op_condap, op_distrib, op_factor, op_merge, op_assert, op_gt
    -- Literals and Invocations
    , number, (%), text, block, seal, unseal, anno
    -- Meta
    , (>>>), pass, dynWord

    -- For clients (not used by AODict)
    , V(..), summaryV
    , Number, Program 
    , runAO, stdEnv
    , textToV, charToV, vToText, vToChar
    ) where

import Control.Applicative
import Control.Monad
import Data.Ratio
import Data.Text (Text)
import qualified Data.Text as T

infixr 1 >>>

type Program = V -> IO V
type Number = Double

data V
    = P !V !V -- pair
    | U -- unit
    | N {-# UNPACK #-} !Number -- number
    | L !V -- in left
    | R !V -- in right
    | S !Text !V -- sealed value
    | B Program -- block of code
    | F (IO V) -- future async value or tail call

instance Show V where show = summaryV 12 

-- shallow summary of a value (limited depth)
summaryV :: Int -> V -> String
summaryV _ (N r) = show r
summaryV _ U = "unit"
summaryV _ (L U) = "false"
summaryV _ (R U) = "true"
summaryV _ (vToText -> Just txt) = show txt
summaryV n _ | (n < 1) = "..."
summaryV n (L a) = "(" ++ summaryV (n-1) a ++ "+_)"
summaryV n (R b) = "(_+" ++ summaryV (n-1) b ++ ")"
summaryV n (P a b) = "(" ++ summaryV (n-1) a ++ "*" ++ summaryV (n-1) b ++ ")"
summaryV n (S t v) = T.unpack t ++ ":" ++ summaryV (n-1) v
summaryV _ (B _) = "[fn]"
summaryV _ (F _) = "~IO~"

runAO :: V -> Program -> IO V
runAO v prog = prog v >>= finish

stdEnv :: V
stdEnv = stdEnvP stdPower

stdEnvP :: Program -> V
stdEnvP power = s `P` (h `P` (pb `P` (ns `P` ex))) where
    s = U
    h = U
    pb = B power
    ns = (L U `P` U)
    ex = U

stdPower :: Program
stdPower v = 
    getPair v >>= \ (msg,arg) ->
    getText msg >>= \ (cmd) ->
    runStdCmd (T.unpack cmd) arg >>= \ result ->
    return (B stdPower `P` result)

runStdCmd :: String -> V -> IO V
runStdCmd cmd _ = fail ("todo: command " ++ cmd)

-- 'finish' will deeply compute all future values
-- (in general, a value should be 'finished' before printing)
-- TODO: consider asynchronous (multi-threaded) finish across P
finish :: V -> IO V
finish v | isFinished v = return v
finish (F action) = action >>= finish
finish (P x y) = P <$> finish x <*> finish y
finish (L x) = L <$> finish x
finish (R y) = R <$> finish y
finish (S t v) = S t <$> finish v
finish _v = fail ("value " ++ show _v ++ " not recognized by 'isFinished'")

-- quick scan, so I can avoid constructing a new value when
-- nothing has changed (and reduce stack overheads). 
isFinished :: V -> Bool
isFinished (F _) = False
isFinished (P a b) = isFinished a && isFinished b
isFinished (L a) = isFinished a
isFinished (R b) = isFinished b
isFinished (S _ v) = isFinished v
isFinished _ = True

textToV :: Text -> V
textToV t = case T.uncons t of
    Nothing -> L U
    Just (c, t') -> R (P (charToV c) (textToV t'))

charToV :: Char -> V
charToV = N . fromIntegral . fromEnum 

vToText :: V -> Maybe Text
vToText (L U) = Just T.empty
vToText (R (P c t)) = T.cons <$> vToChar c <*> vToText t
vToText _ = Nothing

vToChar :: V -> Maybe Char
vToChar (N f) =
    let n = floor f in
    if ((0 <= n) && (n <= 1114111)) 
        then Just (toEnum n) 
        else Nothing
vToChar _ = Nothing

getPair :: V -> IO (V,V)
getSum  :: V -> IO (Either V V)
getText :: V -> IO Text
getUnit :: V -> IO ()
getNumber :: V -> IO Number

getPair (P a b) = return (a,b)
getPair (F action) = action >>= getPair
getPair _v = fail ("expecting pair, got " ++ show _v)

getSum (L a) = return (Left a)
getSum (R b) = return (Right b)
getSum (F action) = action >>= getSum
getSum _v = fail ("expecting sum, got " ++ show _v)

getText v = 
    finish v >>= \ v' ->
    case vToText v' of
        Just txt -> return txt
        Nothing -> fail ("expecting text, got " ++ show v')

getUnit U = return ()
getUnit (F action) = action >>= getUnit
getUnit _v = fail ("expecting unit, got " ++ show _v)

getNumber (N n) = return n
getNumber (F action) = action >>= getNumber
getNumber _v = fail ("expecting number, got " ++ show _v)

-- | The '>>>' operator is the composition operator used by AODict.
-- This operator conventionally is provided by Control.Category, where
-- its meaning is simply 'flip (.)'. For AOPrelude, it has a similar
-- meaning, but might include implicit conversions (if necessary).
(>>>) :: Program -> Program -> Program 
(>>>) = (>=>) -- programs are monadic

-- | pass: corresponds to the empty program, and also to ABC whitespace
-- operators ' ' and '\n'. This program will simply output its input, 
-- unaltered and unobserved. This is mostly needed by empty blocks `[]`.
pass :: Program -- x x 
pass = return

-- | op_l: ABC operator 'l' has type (a*(b*c))→((a*b)*c)
op_l :: Program -- (a:*:(b:*:c)) ((a:*:b):*:c)
op_l = mkOp 'l' $ undefined

-- | op_r: ABC operator 'r' has type ((a*b)*c)→(a*(b*c))
op_r :: Program -- ((a:*:b):*:c) (a:*:(b:*:c))
op_r = mkOp 'r' $ undefined

-- | op_w: ABC operator 'w' has type (a*(b*c))→(b*(a*c))
op_w :: Program -- (a:*:(b:*:c)) (b:*:(a:*:c))
op_w = mkOp 'w' $ undefined

-- | op_z: ABC operator 'z' has type (a*(b*(c*d)))→(a*(c*(b*d)))
op_z :: Program -- (a:*:(b:*:(c:*:d))) (a:*:(c:*:(b:*:d)))
op_z = mkOp 'z' $ undefined

-- | op_v: ABC operator 'v' has type a→(a*1)  (type '1' means unit)
op_v :: Program -- a (a:*:Unit)
op_v = mkOp 'v' $ undefined

-- | op_c: ABC operator 'c' has type (a*1)→a
op_c :: Program -- (a:*:Unit) a
op_c = mkOp 'c' $ undefined

-- | op_L: ABC operator 'L' has type ((a+(b+c))*e)→(((a+b)+c)*e)
op_L :: Program -- ((a:+:(b:+:c)):*:e) (((a:+:b):+:c):*:e)
op_L = mkOp 'L' $ undefined

-- | op_R: ABC operator 'R' has type (((a+b)+c)*e)→((a+(b+c))*e)
op_R :: Program -- (((a:+:b):+:c):*:e) ((a:+:(b:+:c)):*:e)
op_R = mkOp 'R' $ undefined

-- | op_W: ABC operator 'W' has type ((a+(b+c))*e)→((b+(a+c))*e)
op_W :: Program -- ((a:+:(b:+:c)):*:e) ((b:+:(a:+:c)):*:e)
op_W = mkOp 'W' $ undefined

-- | op_Z: ABC operator 'Z' has type ((a+(b+(c+d)))*e)→((a+(c+(b+d)))*e)
op_Z :: Program -- ((a:+:(b:+:(c:+:d))):*:e) ((a:+:(c:+:(b:+:d))):*:e)
op_Z = mkOp 'Z' $ undefined

-- | op_V: ABC operator 'V' has type (a*e)→((a+0)*e); type '0' is void of any type
op_V :: Program -- (a:*:e) ((a:+:void):*:e)
op_V = mkOp 'V' $ undefined

-- | op_C: ABC operator 'C' has type ((a+0)*e)→(a*e)
op_C :: Program -- ((a:+:void):*:e) (a:*:e)
op_C = mkOp 'C' $ undefined

-- | op_drop: ABC operator '%' has type (Droppable a) ⇒ (a*e)→e
-- The droppability of 'a' is not validated by this implementation.
op_drop :: Program -- (a:*:e) e
op_drop = mkOp '%' $ undefined

-- | op_copy: ABC operator '^' has type (Copyable a) ⇒ (a*e)→(a*(a*e))
-- The copyability of 'a' is not validated by this implementation.
op_copy :: Program -- (a:*:e) (a:*:(a:*:e))
op_copy = mkOp '^' $ undefined

-- | op_ap: ABC operator '$' has type ([a→a']*(a*e))→(a'*e)
-- Type [a→a'] means a Block (roughly, a Haskell function)
op_ap :: Program -- (Block:*:(a:*:e)) (a':*:e)
op_ap = mkOp '$' $ undefined

-- | op_quote: ABC operator '\'' has type (Quotable a) ⇒ (a*e)→([s→(a*s)]*e)
-- This is to say, the value for 'a' is captured in a block.
--
-- Type 'a' is only unquotable in rare circumstances, involving distributed
-- data models. In this Haskell implementation, all values are quotable.
op_quote :: Program -- (a:*:e) (Block:*:e)
op_quote = mkOp '\'' $ undefined

-- | op_comp: ABC operator 'o' has type ([b→c]*([a→b]*e))→([a→c]*e)
--
-- The specification within ABC is trivial: simply addend the code.
-- But in an implementation, this might be a bit more sophisticated
-- e.g. to perform specialization and partial evaluation.
--
-- Composition is heavily used in AO and ABC. It is necessary for 
-- expressing fixpoints and loops, and also for binding constants
-- (i.e. partial application or currying). 
op_comp :: Program -- (Block:*:(Block:*:e)) (Block:*:e)
op_comp = mkOp 'o' $ undefined

-- | op_rel: ABC operator 'k' has type (block*e)→(block*e), modifying an
-- attribute of the block so that it may not be dropped (not Droppable). But
-- since droppability isn't checked, this is undefined for now. 
op_rel :: Program -- (Block:*:e) (Block:*:e) 
op_rel = mkOp 'k' $ pass -- ignore relevance properties for now

-- | op_aff: ABC operator 'f' has type (block*e)→(block*e), modifying an
-- attribute of the block so that it may not be copied (not Copyable). But
-- since copyability isn't checked, this is  
op_aff :: Program -- (Block:*:e) (Block:*:e)
op_aff = mkOp 'f' $ pass -- ignore affine properties for now

op_add :: Program -- (Number:*:(Number:*:e)) (Number:*:e)
op_add = mkOp '+' $ undefined

op_mul :: Program -- (Number:*:(Number:*:e)) (Number:*:e)
op_mul = mkOp '*' $ undefined

op_neg :: Program -- (Number:*:e) (Number:*:e)
op_neg = mkOp '-' $ undefined

op_inv :: Program -- (Number:*:e) (Number:*:e)
op_inv = mkOp '/' $ undefined

-- | op_div: ABC operator 'Q' has type 
--
--     (divisor*(dividend*e))→(remainder*(quotient*e))
--        such that quotient is rational, remainder is between 0 and divisor
--        and divisor*quotient+remainder = dividend
-- 
-- This is really a divMod or quotRem operation, albeit one that works for
-- a rational divisor or dividend. 
--
op_div :: Program -- (Number:*:(Number:*:e)) (Number:*:(Number:*:e))
op_div = mkOp 'Q' $ undefined

op_condap :: Program -- (Block:*:((a:+:b):*:e)) ((a':+:b):*:e)
op_condap = mkOp '?' $ undefined

op_distrib :: Program -- (a:*:((b:+:c):*:e)) (((a:*:b):+:(a:*:c)):*:e)
op_distrib = mkOp 'D' $ undefined

op_factor :: Program -- (((a:*:b):+:(c:*:d)):*:e) ((a:+:c):*:((b:+:c):*:e))
op_factor = mkOp 'F' $ undefined

op_merge :: Program -- ((a:+:a):*:e) (a:*:e)
op_merge = mkOp 'M' $ undefined

op_assert :: Program -- ((a:+:b):*:e) (b:*:e)
op_assert = mkOp 'K' $ undefined

op_gt :: Program -- (a:*:(b:*:e)) (((b:*:a):+:(a:*:b)):*:e)
op_gt = mkOp '>' $ undefined

-- for now, 'mkOp' is just for some inline static documentation
--  but might overload later for runtime docs
mkOp :: Char -> Program -> Program
mkOp _ = id

-- | 'number' here corresponds to a number literal in AO or ABC. The
-- resulting subprogram should have type e→(Number*e). In AO, the 
-- number literal actually has type `(s*e)→((Number*s)*e)`, but this
-- is handled by the `ao dict2hs` conversion program, which will add
-- '>>> op_l' after each number, text, or block literal.
number :: Rational -> Program
number = undefined

-- | 'text' corresponds to a text literal in ABC, with type e→(Text*e).
-- The type of Text is µT.(1+(Char*T)), where Char is a natural number
-- between 0 and 1114111 (inclusive). (AO ignores surrogate pairs and
-- so on; the semantics of text is a static list of small numbers.)
text :: String -> Program
text = undefined 

-- | 'block' corresponds to a block literal in ABC, with type e→(Block*e).
-- The argument to 'block' is the subprogram contained by the block.
block :: Program -> Program
block = undefined

-- | 'seal' will seal a value so that it cannot be manipulated without 
-- first unsealing it. This serves a similar role in AO and ABC as does
-- 'newtype' in Haskell. 
--
-- TODO: consider use of GHC's type literals. This might require a change
-- to the code generator, of course. 
seal :: String -> Program
seal = undefined 

-- | 'unseal' a previously sealed value. 
unseal :: String -> Program
unseal = undefined

-- | annotate code or value; string is type of annotation {&string}
anno :: String -> Program
anno _ = pass

dynWord = undefined

-- some toplevel optimization rules
{-# RULES
">>>pass" forall f. f >>> pass = f
"pass>>>" forall f. pass >>> f = f

"%lr" op_l >>> op_r = pass
"%rl" op_r >>> op_l = pass
"%ww" op_w >>> op_w = pass
"%zz" op_z >>> op_z = pass
"%vc" op_v >>> op_c = pass
"%cv" op_c >>> op_v = pass
"%LR" op_L >>> op_R = pass
"%RL" op_R >>> op_L = pass
"%WW" op_W >>> op_W = pass
"%ZZ" op_Z >>> op_Z = pass
"%VC" op_V >>> op_C = pass
"%CV" op_C >>> op_V = pass
 #-}

-- Consider optimizing common sequences of operations, and specific
-- word or function definitions, i.e. something like:
{-
{-# RULES
"%vr$c" op_v >>> op_r >>> op_ap >>> op_c = jet_inline
"%vvrwlc" op_v >>> op_v >>> op_w >>> op_r >>> op_l >>> op_c = jet_introUnit
"%vrwlc" op_v >>> op_r >>> op_w >>> op_l >>> op_c = jet_pswap
"%VRWLC" op_V >>> op_R >>> op_W >>> op_L >>> op_C = jet_pmirror
 #-}

jet_introUnit = mkJet "vvrwlc" $ op_v >>> jet_pswap
jet_inline = mkJet "vr$c" $ op_v >>> op_r >>> op_ap >>> op_c
jet_pswap = mkJet "vrwlc" $ op_v >>> op_r >>> op_w >>> op_l >>> op_c
jet_pmirror = mkJet "VRWLC" $ op_V >>> op_R >>> op_W >>> op_L >>> op_C

mkJet :: String -> a -> a
mkJet _ = id
-}

