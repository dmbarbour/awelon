
-- | The AOPrelude module is implicitly imported by AODict. It is feasible
-- to have many different AOPreludes depending on how we wish to interpret
-- the AO code (i.e. functional vs. imperative vs. reactive), and to what
-- extent we wish to leverage typing or staged computation, etc.. To create
-- an alternative prelude, one should follow this one as an example.
--
-- This particular AOPrelude is oriented towards imperative code. The aim
-- is to leverage some of Haskell's optimizers, such that we can achieve
-- competitive performance from AO code for a few specific use cases:
--
--  * bootstrap compiler
--  * AO based web app server (for wiki based IDE and OS)
--
-- If that much is accomplished, we'll be able to implement more of AO's 
-- development environment from within AO. If not, I can still bootstrap
-- but it will take a lot longer to reach a usable condition.
--
-- AODict is a Haskell module generated by `ao dict2hs`. It exports a set
-- of mangled words, in addition to an 'allWords' association list. For
-- most use cases, developers shouldn't directly work with mangled words,
-- and instead should use 'allWords' to access tests or web apps or so on.
-- But, if desired, developers can use `ao ao2hs "AO code here"` to access 
-- a mangled form for Haskell (e.g. for ghci).
-- 
module AOPrelude
    ( op_l, op_r, op_w, op_z, op_v, op_c
    , op_L, op_R, op_W, op_Z, op_V, op_C
    , op_id, op_drop, op_copy
    , op_ap, op_quote, op_comp, op_rel, op_aff
    , op_add, op_mul, op_neg, op_inv, op_div
    , op_condap, op_distrib, op_factor, op_merge, op_assert, op_gt
    -- Literals and Invocations
    , number, (%), text, block, seal, unseal, anno
    -- Meta
    , amb, (>>>), dynWord
    -- Types...
    ) where

import Data.Ratio ((%)) -- re-exported for AODict

infixr 1 >>>

-- | op_id: ABC operators ' ' and '\n', and also the absence of code
-- will pass an argument along unaltered
op_id = mkOp ' ' $ undefined

-- | op_l: ABC operator 'l' has type (a*(b*c))→((a*b)*c)
op_l = mkOp 'l' $ undefined

-- | op_r: ABC operator 'r' has type ((a*b)*c)→(a*(b*c))
op_r = mkOp 'r' $ undefined

-- | op_w: ABC operator 'w' has type (a*(b*c))→(b*(a*c))
op_w = mkOp 'w' $ undefined

-- | op_z: ABC operator 'z' has type (a*(b*(c*d)))→(a*(c*(b*d)))
op_z = mkOp 'z' $ undefined

-- | op_v: ABC operator 'v' has type a→(a*1)  (type '1' means unit)
op_v = mkOp 'v' $ undefined

-- | op_c: ABC operator 'c' has type (a*1)→a
op_c = mkOp 'c' $ undefined

-- | op_L: ABC operator 'L' has type ((a+(b+c))*e)→(((a+b)+c)*e)
op_L = mkOp 'L' $ undefined

-- | op_R: ABC operator 'R' has type (((a+b)+c)*e)→((a+(b+c))*e)
op_R = mkOp 'R' $ undefined

-- | op_W: ABC operator 'W' has type ((a+(b+c))*e)→((b+(a+c))*e)
op_W = mkOp 'W' $ undefined

-- | op_Z: ABC operator 'Z' has type ((a+(b+(c+d)))*e)→((a+(c+(b+d)))*e)
op_Z = mkOp 'Z' $ undefined

-- | op_V: ABC operator 'V' has type (a*e)→((a+0)*e); type '0' is void of any type
op_V = mkOp 'V' $ undefined

-- | op_C: ABC operator 'C' has type ((a+0)*e)→(a*e)
op_C = mkOp 'C' $ undefined

-- | op_drop: ABC operator '%' has type (Droppable a) ⇒ (a*(b*c))→(b*c)
-- The droppability of 'a' is not validated by this implementation.
op_drop = mkOp '%' $ undefined

-- | op_copy: ABC operator '^' has type (Copyable a) ⇒ (a*e)→(a*(a*e))
-- The copyability of 'a' is not validated by this implementation.
op_copy = mkOp '^' $ undefined

-- | op_ap: ABC operator '$' has type ([a→a']*(a*e))→(a'*e)
-- Type [a→a'] means a Block (roughly, a Haskell function)
op_ap = mkOp '$' $ undefined

-- | op_quote: ABC operator '\'' has type (Quotable a) ⇒ (a*e)→([s→(a*s)]*e)
-- This is to say, the value for 'a' is captured in a block.
--
-- Type 'a' is only unquotable in rare circumstances, involving distributed
-- data models. In this Haskell implementation, all values are quotable.
op_quote = mkOp '\'' $ undefined

-- | op_comp: ABC operator 'o' has type ([b→c]*([a→b]*e))→([a→c]*e)
--
-- The specification within ABC is trivial: simply addend the code.
-- But in an implementation, this might be a bit more sophisticated
-- e.g. to perform specialization and partial evaluation.
--
-- Composition is heavily used in AO and ABC. It is necessary for 
-- expressing fixpoints and loops, and also for binding constants
-- (i.e. partial application or currying). 
op_comp = mkOp 'o' $ undefined

-- | op_rel: ABC operator 'k' has type (block*e)→(block*e), modifying an
-- attribute of the block so that it may not be dropped (not Droppable). But
-- since droppability isn't checked, this is undefined for now.  
op_rel = mkOp 'k' $ id -- ignore relevance properties for now

-- | op_aff: ABC operator 'f' has type (block*e)→(block*e), modifying an
-- attribute of the block so that it may not be copied (not Copyable). But
-- since copyability isn't checked, this is  
op_aff = mkOp 'f' $ id -- ignore affine properties for now

op_add = mkOp '+' $ undefined
op_mul = mkOp '*' $ undefined
op_neg = mkOp '-' $ undefined
op_inv = mkOp '/' $ undefined
op_div = mkOp 'Q' $ undefined
op_condap = mkOp '?' $ undefined
op_distrib = mkOp 'D' $ undefined
op_factor = mkOp 'F' $ undefined
op_merge = mkOp 'M' $ undefined
op_assert = mkOp 'K' $ undefined
op_gt = mkOp '>' $ undefined

-- for now, 'mkOp' is just for some inline static documentation
--  but might overload later for runtime docs
mkOp :: Char -> a -> a
mkOp _ = id

-- | 'number' here corresponds to a number literal in AO or ABC. The
-- resulting subprogram should have type e→(Number*e). In AO, the 
-- number literal actually has type `(s*e)→((Number*s)*e)`, but this
-- is handled by the `ao dict2hs` conversion program, which will add
-- '>>> op_l' after each number, text, or block literal.
number :: Rational -> a
number = undefined

-- | 'text' corresponds to a text literal in ABC, with type e→(Text*e).
-- The type of Text is µT.(1+(Char*T)), where Char is a natural number
-- between 0 and 1114111 (inclusive). (AO ignores surrogate pairs and
-- so on; the semantics of text is a static list of small numbers.)
text :: String -> a
text = undefined 

-- | 'block' corresponds to a block literal in ABC, with type e→(Block*e).
-- The argument to 'block' is the subprogram contained by the block.
block :: b -> a
block = undefined

-- | 'seal' will seal a value so that it cannot be manipulated without 
-- first unsealing it. This serves a similar role in AO and ABC as does
-- 'newtype' in Haskell.
seal :: String -> a
seal = undefined 

-- | 'unseal' a previously sealed value. 
unseal :: String -> a
unseal = undefined

-- | annotate code or value; string is type of annotation {&string}
anno :: String -> a
anno _ = op_id

-- | AO can potentially represent ambiguous code, using (foo|bar).
-- The intention is to resolve this typefully, and by soft heuristics.
-- But this particular implementation does not support ambiguity.
amb :: [a] -> a
amb = error "ambiguous AO code is not supported by this AOPrelude"

(>>>) = undefined
dynWord = undefined

-- some toplevel optimization rules
{-# RULES
"op_id." forall f. f >>> op_id = f
".op_id" forall f. op_id >>> f = f

"%lr" op_l >>> op_r = id
"%rl" op_r >>> op_l = id
"%ww" op_w >>> op_w = id
"%zz" op_z >>> op_z = id
"%vc" op_v >>> op_c = id
"%cv" op_c >>> op_v = id
"%LR" op_L >>> op_R = id
"%RL" op_R >>> op_L = id
"%WW" op_W >>> op_W = id
"%ZZ" op_Z >>> op_Z = id
"%VC" op_V >>> op_C = id
"%CV" op_C >>> op_V = id
 #-}

-- optimize other common sequences? give it a try, maybe
{-# RULES
"%vr$c" op_v >>> op_r >>> op_ap >>> op_c = jet_inline
"%vvrwlc" op_v >>> op_v >>> op_w >>> op_r >>> op_l >>> op_c = jet_introUnit
"%vrwlc" op_v >>> op_r >>> op_w >>> op_l >>> op_c = jet_pswap
"%VRWLC" op_V >>> op_R >>> op_W >>> op_L >>> op_C = jet_pmirror
 #-}

jet_introUnit = mkJet "vvrwlc" $ op_v >>> jet_pswap
jet_inline = mkJet "vr$c" $ op_v >>> op_r >>> op_ap >>> op_c
jet_pswap = mkJet "vrwlc" $ op_v >>> op_r >>> op_w >>> op_l >>> op_c
jet_pmirror = mkJet "VRWLC" $ op_V >>> op_R >>> op_W >>> op_L >>> op_C

mkJet :: String -> a -> a
mkJet _ = id
