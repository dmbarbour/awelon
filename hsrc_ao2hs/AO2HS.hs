{-# LANGUAGE PatternGuards, ViewPatterns #-}

-- NOTE: This code is not in use at the moment, and is broken.

-- | The `ao2hs` executable takes a single dictionary name, imports
-- said dictionary, then compiles to 'Dict.hs'.
-- The compiler does name mangling as needed.
--
-- Annotations are ignored, but value sealing is supported.
module Main
    ( main
    ) where

--import qualified Data.List as L
import qualified Data.Text as T
import Data.Text (Text)
import qualified Data.Map as M
import qualified Data.Sequence as S
import qualified Data.Foldable as S
import qualified System.IO as Sys
import qualified System.Exit as Sys
import qualified System.Environment as Env
import qualified Filesystem as FS
import qualified Filesystem.Path.CurrentOS as FS
import AO.AO
--import AO.AOTypes

-- the resulting module is independent of the dictionary constructed.
targetModule :: Text
targetModule = T.pack "AODict"

targetFile :: FS.FilePath
targetFile = FS.fromText targetModule FS.<.> T.pack "hs"

main :: IO ()
main = 
    selectDictionary >>= \ imp ->
    loadDictionary imp >>= \ dict ->
    let dict' = mangleWords hsMangle dict in
    FS.writeTextFile targetFile (hsText imp dict')

selectDictionary :: IO Import
selectDictionary = 
    Env.getArgs >>= \ args ->
    case args of
        (dict:[]) -> return (T.pack dict)
        _ -> printHelp >> Sys.exitFailure

printHelp :: IO ()
printHelp = Sys.putStrLn helpMsg where
    helpMsg = "ao2hs takes one argument, dictionary name; compiles to " 
              ++ T.unpack targetModule ++ ".hs"


hsText :: Import -> Dictionary -> Text
hsText imp dict = 
    hsHeader imp dict `T.append`
    hsImports `T.append`
    hsBody dict

hsHeader :: Import -> Dictionary -> Text
hsHeader imp dict = 
    langSpec `T.append`
    openingComment imp `T.append`
    T.pack "\nmodule " `T.append` targetModule `T.append`
    hsExports dict `T.append` 
    T.pack " where\n\n"

langSpec :: Text
langSpec = T.empty

openingComment :: Import -> Text
openingComment imp = 
    T.pack "\n-- (THIS FILE GENERATED BY `ao2hs`; DO NOT MODIFY BY HAND)" `T.append`
    T.pack "\n-- AO dictionary: " `T.append` imp
   
hsExports :: Dictionary -> Text
hsExports dict = 
    T.pack "\n    (" `T.append`
    T.intercalate (T.pack "\n    ,") (M.keys dict) `T.append`
    T.pack "\n    )"

hsImports :: Text
hsImports = T.intercalate (T.pack "\nimport ") (map T.pack hsImportsList)

hsImportsList :: [String]
hsImportsList =
    ["AO.Op"
    ,"AO.V"
    ,"Control.Monad ((>=>))"
    ]

hsBody :: Dictionary -> Text
hsBody = T.concat . fmap aoToHS1 . M.toList 

aoToHS1 :: (W,(Locator,AODef)) -> Text
aoToHS1 (w,(loc,def)) = 
    T.pack "\n-- " `T.append` wordLocatorText w loc `T.snoc` '\n'
    `T.append` hsTypeDef w `T.snoc` '\n' 
    `T.append` hsDef w def `T.snoc` '\n'

hsTypeDef :: W -> Text
hsTypeDef w = w `T.append` T.pack " :: (Monad c) => V c -> c (V c)"

hsDef :: W -> S.Seq Action -> Text
hsDef w ao = w `T.append` T.pack " = " `T.append` ao2hs ao

ao2hs :: S.Seq Action -> Text
ao2hs = T.intercalate (T.pack " >=> ") . S.toList . fmap action2hs

action2hs :: Action -> Text
action2hs (Word w) = w
action2hs (Num r) = T.pack $ "(return . P (N (" ++ show r ++ "))) >=> op_l"
action2hs (Lit txt) = T.pack $ "(return . P (textToVal " ++ show txt ++ ")) >=> op_l"
action2hs (BAO aoDef) = T.pack $ "(return . P (" ++ bTxt ++ ")) >=> op_l" where
    bTxt = "

"(return . (P (N r)))"
    T.intercalate (T.pack " >=> ") (fmap action2hs (S.toList actions))

action2hs :: Action -> Text
action2hs 

data Action 
    = Word W -- a plain old word
    | Num Rational -- literal number, many formats accepted
    | Lit Text -- text literal (inline or multi-line)
    | BAO AODef -- block of AO code
    | Prim (S.Seq Op) -- %inlineABC
    | Amb [AODef] -- ambiguous choice, or maybe just one choice

T.pack " = undefined"

-- Many of AO's naming conventions are invalid in Haskell's syntax.
-- So we manipulate the names a bit. We also precede every name with
-- 'w_' to avoid issues with capitalization and keywords.
--
hsMangle :: W -> W
hsMangle = T.cons 'w' . T.cons '_' . T.concatMap mangleC

mangleC :: Char -> Text
mangleC c | isAlphaNum c = T.singleton c
mangleC c = T.pack $ toHex "_" (fromEnum c)

isAlphaNum, isUpper, isLower, isNum :: Char -> Bool
isAlphaNum c = isUpper c || isLower c || isNum c
isUpper c = ('A' <= c) && (c <= 'Z')
isLower c = ('a' <= c) && (c <= 'z')
isNum c = ('0' <= c) && (c <= '9')

toHex :: String -> Int -> String
toHex s n =
    if (n < 1) then s else
    let (d,q) = n `divMod` 16 in
    toHex (toHexC q : s) d

toHexC :: Int -> Char
toHexC c | ((0 <= c) && (c <= 9)) = toEnum (c + 48) 
toHexC c | ((10 <= c) && (c <= 15)) = toEnum (c + 55)
toHexC c = error ("invalid hex digit value: " ++ show c)
