{-# LANGUAGE PatternGuards, ViewPatterns, GeneralizedNewtypeDeriving #-}
{-# OPTIONS_GHC -fno-warn-orphans #-}

-- | The AOPrelude module provides dependencies for AODict, which is
-- generated by `ao dict2hs`. Different AOPrelude modules could suit
-- different interpretations (functional vs. imperative vs. reactive).
--
-- This implementation is dynamic and imperative, and replicates most
-- behavior from the `ao` library (there is no dependency).
--
-- Sadly, I've not been able to fit AO into Haskell's type system. AO
-- assumes partial evaluation, flexible typing strategies (e.g. recognize
-- anonymous recursive types by hypothesis), and exhaustive analysis from
-- the small set of structural types. So we end up with a mostly dynamic
-- implementation of AO in Haskell. I shall also try a dynamic target PL, 
-- such as Python, to see if that will perform better.
--
-- The only goal is, simply, performance - enough for bootstrap compilers
-- and web application servers and early AO constructs.
-- 
module AOPrelude
    ( op_l, op_r, op_w, op_z, op_v, op_c
    , op_L, op_R, op_W, op_Z, op_V, op_C
    , op_drop, op_copy
    , op_ap, ops_apc, op_quote, op_comp, op_rel, op_aff
    , op_add, op_mul, op_neg, op_inv, op_div
    , op_condap, op_distrib, op_factor, op_merge, op_assert, op_gt
    -- Literals and Invocations
    , number, (%), text, block, seal, unseal, anno
    -- Meta
    , (>>>), pass, dynWord

    -- For clients (not used by AODict)
    , V(..), summaryV
    , Number, Program, Block(..)
    , runAO, stdEnvPure, stdEnvWithPB
    , textToV, charToV, vToText, vToChar
    , divModQ, quoteVal, mkAsync
    ) where

import Prelude hiding ((.),id)
import Control.Applicative
--import Control.Monad
import Control.Category
import Data.Ratio

-- Quick and Dirty '{&async}' implementation
import System.IO.Unsafe (unsafeInterleaveIO)
import Control.Concurrent
--import Control.Concurrent.MVar

type AO = IO -- for now
type Program = AO V -> AO V
type Number = Rational

data V
    = P V V -- pair
    | U -- unit
    | N {-# UNPACK #-} !Number -- number
    | L V -- in left
    | R V -- in right
    | S String V -- sealed value
    | B Block

data Block = Block 
    { b_aff  :: Bool
    , b_rel  :: Bool
    , b_prog :: Program 
    }

instance Show V where show = summaryV 12 

-- shallow summary of a value (limited depth, lossy)
summaryV :: Int -> V -> String
summaryV _ (N r) = show r
summaryV _ U = "unit"
summaryV _ (L U) = "false"
summaryV _ (R U) = "true"
summaryV _ (vToText -> Just txt) = show txt
summaryV n _ | (n < 1) = "..."
summaryV n (L a) = "(" ++ summaryV (n-1) a ++ "+_)"
summaryV n (R b) = "(_+" ++ summaryV (n-1) b ++ ")"
summaryV n (P a b) = "(" ++ summaryV (n-1) a ++ "*" ++ summaryV (n-1) b ++ ")"
summaryV n (S t v) = t ++ ":" ++ summaryV (n-1) v
summaryV _ (B b) = 
    let addK = if b_rel b then (++"k") else id in
    let addF = if b_aff b then (++"f") else id in
    (addF . addK) "[fn]"

runAO :: V -> Program -> IO V
runAO v prog = prog (pure v)

stdEnvPure :: V
stdEnvPure = stdEnvWithPB pbReject where
    pbReject = Block True True (reject =<<)
    reject v = fail $ "command rejected: " ++ show v

stdEnvWithPB :: Block -> V
stdEnvWithPB pb = s `P` (h `P` (B pb `P` (ns `P` ex))) where
    s = U
    h = U
    ns = (L U `P` U)
    ex = U

textToV :: String -> V
textToV (c:cs) = R (P (charToV c) (textToV cs))
textToV [] = L U

charToV :: Char -> V
charToV = N . fromIntegral . fromEnum 

vToText :: V -> Maybe String
vToText (L U) = pure []
vToText (R (P c t)) = (:) <$> vToChar c <*> vToText t
vToText _ = Nothing

vToChar :: V -> Maybe Char
vToChar (N f) =
    let n = floor f in
    if ((0 <= n) && (n <= 1114111)) 
        then Just (toEnum n) 
        else Nothing
vToChar _ = Nothing

-- simple op errors; most debug info from v
opError :: Char -> V -> a
opError c v = error (c : " @ " ++ show v)

-- | pass: corresponds to the empty program, and also to ABC whitespace
-- operators ' ' and '\n'. This program will simply output its input, 
-- unaltered and unobserved. This is mostly needed by empty blocks `[]`.
pass :: Program -- x→x 
pass = id

-- | op_l: ABC operator 'l' has type (a*(b*c))→((a*b)*c)
op_l :: Program -- (a:*:(b:*:c)) ((a:*:b):*:c)
op_l = fmap pop_l

pop_l :: V -> V
pop_l (P a (P b c)) = (P (P a b) c)
pop_l v = opError 'l' v

-- | op_r: ABC operator 'r' has type ((a*b)*c)→(a*(b*c))
op_r :: Program -- ((a:*:b):*:c) (a:*:(b:*:c))
op_r = fmap pop_r

pop_r :: V -> V
pop_r (P (P a b) c) = (P a (P b c))
pop_r v = opError 'r' v

-- | op_w: ABC operator 'w' has type (a*(b*c))→(b*(a*c))
op_w :: Program -- (a:*:(b:*:c)) (b:*:(a:*:c))
op_w = fmap pop_w

pop_w :: V -> V
pop_w (P a (P b c)) = (P b (P a c))
pop_w v = opError 'w' v

-- | op_z: ABC operator 'z' has type (a*(b*(c*d)))→(a*(c*(b*d)))
op_z :: Program -- (a:*:(b:*:(c:*:d))) (a:*:(c:*:(b:*:d)))
op_z = fmap pop_z

pop_z :: V -> V
pop_z (P a (P b (P c d))) = (P a (P c (P b d)))
pop_z v = opError 'z' v

-- | op_v: ABC operator 'v' has type a→(a*1)  (type '1' means unit)
op_v :: Program -- a (a:*:Unit)
op_v = fmap pop_v

pop_v :: V -> V
pop_v a = (P a U)

-- | op_c: ABC operator 'c' has type (a*1)→a
op_c :: Program -- (a:*:Unit) a
op_c = fmap pop_c

pop_c :: V -> V
pop_c (P a U) = a
pop_c v = opError 'c' v

onFst :: (V -> V) -> (V -> V)
onFst f (P a e) = P (f a) e
onFst _ v = error ("onFst @ " ++ show v)

-- | op_L: ABC operator 'L' has type ((a+(b+c))*e)→(((a+b)+c)*e)
op_L :: Program -- ((a:+:(b:+:c)):*:e) (((a:+:b):+:c):*:e)
op_L = fmap (onFst pop_L)

pop_L :: V -> V
pop_L v@(L _a) = (L v)
pop_L (R (L b)) = (L (R b))
pop_L (R v@(R _c)) = v
pop_L v = opError 'L' v

-- | op_R: ABC operator 'R' has type (((a+b)+c)*e)→((a+(b+c))*e)
op_R :: Program -- (((a:+:b):+:c):*:e) ((a:+:(b:+:c)):*:e)
op_R = fmap (onFst pop_R)

pop_R :: V -> V
pop_R (L v@(L _a)) = v
pop_R (L (R b)) = (R (L b))
pop_R v@(R _c) = (R v)
pop_R v = opError 'R' v

-- | op_W: ABC operator 'W' has type ((a+(b+c))*e)→((b+(a+c))*e)
op_W :: Program -- ((a:+:(b:+:c)):*:e) ((b:+:(a:+:c)):*:e)
op_W = fmap (onFst pop_W)

pop_W :: V -> V
pop_W v@(L _a) = (R v)
pop_W (R v@(L _b)) = v
pop_W v@(R (R _c)) = v
pop_W v = opError 'W' v

-- | op_Z: ABC operator 'Z' has type ((a+(b+(c+d)))*e)→((a+(c+(b+d)))*e)
op_Z :: Program -- ((a:+:(b:+:(c:+:d))):*:e) ((a:+:(c:+:(b:+:d))):*:e)
op_Z = fmap (onFst pop_Z)

pop_Z, pop_ZW :: V -> V
pop_Z v@(L _a) = v
pop_Z (R v) = (R (pop_ZW v))
pop_Z v = opError 'Z' v

pop_ZW v@(L _a) = (R v)
pop_ZW (R v@(L _b)) = v
pop_ZW v@(R (R _c)) = v
pop_ZW v = opError 'Z' v

-- | op_V: ABC operator 'V' has type (a*e)→((a+0)*e); type '0' is void of any type
op_V :: Program -- (a:*:e) ((a:+:void):*:e)
op_V = fmap (onFst pop_V)

pop_V :: V -> V
pop_V = L

-- | op_C: ABC operator 'C' has type ((a+0)*e)→(a*e)
op_C :: Program -- ((a:+:void):*:e) (a:*:e)
op_C = fmap (onFst pop_C)

pop_C :: V -> V
pop_C (L a) = a
pop_C v = opError 'C' v

-- | op_drop: ABC operator '%' has type (Droppable a) ⇒ (a*e)→e
op_drop :: Program -- (a:*:e) e
op_drop = fmap pop_drop

pop_drop :: V -> V
pop_drop (P a e) | droppable a = e
pop_drop v = opError '%' v

droppable :: V -> Bool
droppable (P a b) = droppable a && droppable b
droppable (R b) = droppable b
droppable (N _) = True
droppable (L a) = droppable a
droppable U = True
droppable (B b) = not (b_rel b) where
droppable (S _ v) = droppable v

-- | op_copy: ABC operator '^' has type (Copyable a) ⇒ (a*e)→(a*(a*e))
op_copy :: Program -- (a:*:e) (a:*:(a:*:e))
op_copy = fmap pop_copy

pop_copy :: V -> V
pop_copy v@(P a _e) | copyable a = (P a v)
pop_copy v = opError '^' v

copyable :: V -> Bool
copyable (P a b) = copyable a && copyable b
copyable (R b) = copyable b
copyable (N _) = True
copyable (L a) = copyable a
copyable U = True
copyable (B b) = not (b_aff b)
copyable (S _ v) = copyable v

-- | op_ap: ABC operator '$' has type ([a→a']*(a*e))→(a'*e)
-- Type [a→a'] means a Block (roughly, a Haskell function).
--
-- Note that '$c' sequences will be rewritten to 'ops_apc' both
-- by `ao dict2hs` and by GHC's rewrite rules (when enabled).
-- This (hopefully) supports tail call optimization.
--
op_ap :: Program -- (Block:*:(a:*:e)) (a':*:e)
op_ap = (=<<) run where
    run (P (B b) (P a e)) = (`P` e) <$> b_prog b (pure a)
    run v = opError '$' v

-- | ops_apc: a sequence of two ABC operators, '$c', which corresponds
-- to inline application; most relevant for tail-call optimization.
ops_apc :: Program
ops_apc = (=<<) run where
    run (P (B b) (P a U)) = b_prog b (return a)
    run v = error ("$c @ " ++ show v)

-- | op_quote: ABC operator '\'' has type (Quotable a) ⇒ (a*e)→([s→(a*s)]*e)
-- This is to say, the value for 'a' is captured in a block.
--
-- Type 'a' is only unquotable in rare circumstances, involving distributed
-- data models. In this Haskell implementation, all values are quotable.
op_quote :: Program -- (a:*:e) (Block:*:e)
op_quote = fmap (onFst quoteVal)

quoteVal :: V -> V
quoteVal v = B b where
    b = Block { b_aff = aff, b_rel = rel, b_prog = prog }
    aff = not (copyable v)
    rel = not (droppable v)
    prog = fmap (P v)
    
-- | op_comp: ABC operator 'o' has type ([b→c]*([a→b]*e))→([a→c]*e)
--
-- The specification within ABC is trivial: simply addend the code.
-- But in an implementation, this might be a bit more sophisticated
-- e.g. to perform specialization and partial evaluation.
--
-- Composition is heavily used in AO and ABC. It is necessary for 
-- expressing fixpoints and loops, and also for binding constants
-- (i.e. partial application or currying). 
op_comp :: Program -- (Block:*:(Block:*:e)) (Block:*:e)
op_comp = fmap pop_comp

pop_comp :: V -> V
pop_comp (P (B yz) (P (B xy) e)) = (P (B xz) e) where
    xz = Block { b_aff = aff, b_rel = rel, b_prog = prog }
    aff = b_aff yz || b_aff xy
    rel = b_rel yz || b_rel xy
    prog = b_prog xy >>> b_prog yz
pop_comp v = opError 'o' v

-- | op_rel: ABC operator 'k' has type (block*e)→(block*e), modifying an
-- attribute of the block so that it may not be dropped (not Droppable).
op_rel :: Program -- (Block:*:e) (Block:*:e) 
op_rel = fmap (onFst (onBlock mkRel))

onBlock :: (Block -> Block) -> (V -> V)
onBlock f (B b) = B (f b)
onBlock _ v = error $ "block expected @ " ++ show v

mkRel :: Block -> Block
mkRel b = b { b_rel = True }

-- | op_aff: ABC operator 'f' has type (block*e)→(block*e), modifying an
-- attribute of the block so that it may not be copied (not Copyable).
op_aff :: Program -- (Block:*:e) (Block:*:e)
op_aff = fmap (onFst (onBlock mkAff))

mkAff :: Block -> Block
mkAff b = b { b_aff = True }

op_add :: Program -- (Number:*:(Number:*:e)) (Number:*:e)
op_add = fmap pop_add

pop_add :: V -> V
pop_add (P (N a) (P (N b) e)) = (P (N (a+b)) e)
pop_add v = opError '+' v

op_mul :: Program -- (Number:*:(Number:*:e)) (Number:*:e)
op_mul = fmap pop_mul

pop_mul :: V -> V
pop_mul (P (N a) (P (N b) e)) = (P (N (a*b)) e)
pop_mul v = opError '*' v

op_neg :: Program -- (Number:*:e) (Number:*:e)
op_neg = fmap pop_neg

pop_neg :: V -> V
pop_neg (P (N a) e) = (P (N (negate a)) e)
pop_neg v = opError '-' v

op_inv :: Program -- (Number:*:e) (Number:*:e)
op_inv = fmap pop_inv

pop_inv :: V -> V
pop_inv (P (N a) e) | (0 /= a) = (P (N (recip a)) e)
pop_inv v = opError '/' v

-- | op_div: ABC operator 'Q' has type 
--
--     (divisor*(dividend*e))→(remainder*(quotient*e))
--        such that quotient is rational, remainder is between 0 and divisor
--        and divisor*quotient+remainder = dividend
-- 
-- This is really a divMod or quotRem operation, albeit one that works for
-- a rational divisor or dividend. 
--
op_div :: Program -- (Number:*:(Number:*:e)) (Number:*:(Number:*:e))
op_div = fmap pop_div 

pop_div :: V -> V
pop_div (P (N divisor) (P (N dividend) e)) | (0 /= divisor) =
    let (quotient, remainder) = divModQ dividend divisor in
    (P (N remainder) (P (N (fromInteger quotient)) e))
pop_div v = opError 'Q' v

divModQ :: Rational -> Rational -> (Integer, Rational)
divModQ dividend divisor = 
    let num = numerator dividend * denominator divisor in
    let den = denominator dividend * numerator divisor in
    let (quotient, rNum) = num `divMod` den in
    let rDen = denominator dividend * denominator divisor in
    (quotient, rNum % rDen)

op_condap :: Program -- (Block:*:((a:+:b):*:e)) ((a':+:b):*:e)
op_condap = (=<<) run where
    run (P (B fn) e) | (not (b_rel fn)) = run' (b_prog fn) e
    run v = opError '?' v
    run' prog (P (L a) e) = ((`P` e) . L) <$> prog (pure a)
    run' _  v@(P (R _) _) = return v -- ~drop block
    run' _ v = opError '?' v

op_distrib :: Program -- (a:*:((b:+:c):*:e)) (((a:*:b):+:(a:*:c)):*:e)
op_distrib = fmap pop_distrib

pop_distrib :: V -> V
pop_distrib (P a (P (L b) e)) = P (L (P a b)) e
pop_distrib (P a (P (R c) e)) = P (R (P a c)) e
pop_distrib v = opError 'D' v

op_factor :: Program -- (((a:*:b):+:(c:*:d)):*:e) ((a:+:c):*:((b:+:c):*:e))
op_factor = fmap pop_factor

pop_factor :: V -> V
pop_factor (P (L (P a b)) e) = (P (L a) (P (L b) e))
pop_factor (P (R (P c d)) e) = (P (R c) (P (R d) e))
pop_factor v = opError 'F' v

op_merge :: Program -- ((a:+:a):*:e) (a:*:e)
op_merge = fmap pop_merge

pop_merge :: V -> V
pop_merge (P (L a) e) = (P a e)
pop_merge (P (R a') e) = (P a' e)
pop_merge v = opError 'M' v

op_assert :: Program -- ((a:+:b):*:e) (b:*:e)
op_assert = fmap pop_assert

pop_assert :: V -> V
pop_assert (P (R b) e) = (P b e)
pop_assert v = opError 'K' v

op_gt :: Program -- (a:*:(b:*:e)) (((b:*:a):+:(a:*:b)):*:e)
op_gt = fmap pop_gt

pop_gt :: V -> V
pop_gt (P a (P b e)) = 
    if testGT b a then (P (R (P a b)) e) 
                  else (P (L (P b a)) e)
pop_gt v = opError '>' v

testGT :: V -> V -> Bool
testGT (R a) (R b) = testGT a b
testGT (P a1 a2) (P b1 b2) =
    if testGT a1 b1 then True else
    if testGT b1 a1 then False else
    testGT a2 b2
testGT (N a) (N b) = (a > b)
testGT (L a) (L b) = testGT a b
testGT U U = False
testGT (L _) (R _) = False
testGT (R _) (L _) = True
testGT a b = error ("cannot compare " ++ show a ++ " with " ++ show b)


-- | 'number' here corresponds to a number literal in AO or ABC. The
-- resulting subprogram should have type e→(Number*e). In AO, the 
-- number literal actually has type `(s*e)→((Number*s)*e)`, but this
-- is handled by the `ao dict2hs` conversion program, which will add
-- '>>> op_l' after each number, text, or block literal.
number :: Rational -> Program
number = fmap . P . N

-- | 'text' corresponds to a text literal in ABC, with type e→(Text*e).
-- The type of Text is µT.(1+(Char*T)), where Char is a natural number
-- between 0 and 1114111 (inclusive). (AO ignores surrogate pairs and
-- so on; the semantics of text is a static list of small numbers.)
text :: String -> Program
text = fmap . P . textToV

-- | 'block' corresponds to a block literal in ABC, with type e→(Block*e).
-- The argument to 'block' is the subprogram contained by the block.
block :: Program -> Program
block = fmap . P . B . Block False False

-- | 'seal' will seal a value so that it cannot be manipulated without 
-- first unsealing it. This serves a similar role in AO and ABC as does
-- 'newtype' in Haskell. 
--
-- TODO: consider use of GHC's type literals. This might require a change
-- to the code generator, of course. 
seal :: String -> Program
seal = fmap . S -- seals entire input (no `P`)

-- | 'unseal' a previously sealed value. 
unseal :: String -> Program
unseal = fmap . p_unseal

p_unseal :: String -> V -> V
p_unseal s (S s' v) | (s == s') = v
p_unseal s v = error $ "{." ++ s ++ "} @ " ++ show v

-- | annotate code or value; string is type of annotation {&anno}
-- Annotations must return their input without any observable changes.
-- Though, it is also acceptable if an annotation fails to return,
-- e.g. due to a type error.
--
-- Annotations can be used for debugging, memoizations, to guide
-- parallelism, etc.. 
anno :: String -> Program
anno "async" = fmap (onFst (onBlock mkAsync))
anno _ = pass

-- For now, {&async} will mark a block on the stack to operate 
-- asynchronously, such that `{&async}$` will fork a new thread 
-- to apply the block. 'async' can be applied to just part of a
-- block via composition of async pieces. 
mkAsync :: Block -> Block
mkAsync b = b { b_prog = wrap (b_prog b) } where
    wrap prog arg = 
        newEmptyMVar >>= \ mv -> 
        forkIO (prog arg >>= putMVar mv) >>
        unsafeInterleaveIO (takeMVar mv)

-- | dynWord is used by the 'allWords' list, and is only relevant if
-- programs track Haskell types. In which case the types of words
-- would be heterogeneous and would need to be wrapped for inclusion
-- in a homogeneous list. If a generic program type is used, dynWord
-- can simply be 'id'.
dynWord :: Program -> Program
dynWord = id

-- optimization rules
-- some may be redundant with standard library, but that's okay.
{-# RULES
".id" forall f. f . id = f
"id." forall f. id . f = f
"fmap.fmap"   forall f g . fmap f . fmap g = fmap (f . g)
"fmap id"     fmap id = id
"onFst.onFst" forall f g . onFst f . onFst g = onFst (f . g)
"onFst id"    onFst id = id
"onBlock.onBlock" forall f g . onBlock f . onBlock g = onBlock (f . g)

"%lr" op_l >>> op_r = pass
"%rl" op_r >>> op_l = pass
"%ww" op_w >>> op_w = pass
"%zz" op_z >>> op_z = pass
"%vc" op_v >>> op_c = pass
"%cv" op_c >>> op_v = pass
"%LR" op_L >>> op_R = pass
"%RL" op_R >>> op_L = pass
"%WW" op_W >>> op_W = pass
"%ZZ" op_Z >>> op_Z = pass
"%VC" op_V >>> op_C = pass
"%CV" op_C >>> op_V = pass

"%$c" op_ap >>> op_c = ops_apc
".$c" op_c . op_ap = ops_apc

".lr" op_l . op_r = pass
".rl" op_r . op_l = pass
".ww" op_w . op_w = pass
".zz" op_z . op_z = pass
".vc" op_v . op_c = pass
".cv" op_c . op_v = pass
".LR" op_L . op_R = pass
".RL" op_R . op_L = pass
".WW" op_W . op_W = pass
".ZZ" op_Z . op_Z = pass
".VC" op_V . op_C = pass
".CV" op_C . op_V = pass

"lr" pop_l . pop_r = id
"rl" pop_r . pop_l = id
"ww" pop_w . pop_w = id
"zz" pop_z . pop_z = id
"vc" pop_v . pop_c = id
"cv" pop_c . pop_v = id
"LR" pop_L . pop_R = id
"RL" pop_R . pop_L = id
"WW" pop_W . pop_W = id
"ZZ" pop_Z . pop_Z = id
"VC" pop_V . pop_C = id
"CV" pop_C . pop_V = id
 #-}

